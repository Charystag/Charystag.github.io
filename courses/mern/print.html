<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MERN Stack APP</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="backend/backend.html"><strong aria-hidden="true">1.</strong> Express + MongoDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="backend/exercises/exercise_1.html"><strong aria-hidden="true">1.1.</strong> Exercise 1</a></li><li class="chapter-item expanded "><a href="backend/exercises/exercise_2.html"><strong aria-hidden="true">1.2.</strong> Exercise 2</a></li><li class="chapter-item expanded "><a href="backend/exercises/exercise_3.html"><strong aria-hidden="true">1.3.</strong> Exercise 3</a></li><li class="chapter-item expanded "><a href="backend/final_project.html"><strong aria-hidden="true">1.4.</strong> Project Backend</a></li></ol></li><li class="chapter-item expanded "><a href="react/react.html"><strong aria-hidden="true">2.</strong> React Basics</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MERN Stack APP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="styles.css">
<h1 id="mern-stack-app"><a class="header" href="#mern-stack-app">MERN Stack app</a></h1>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment setup</a></h2>
<p>setup project through Docker [create a docker image with all dependancies and then run container]
run a bind mount between your host and the container for the folder where your app will
live</p>
<p>run the container with the command :</p>
<pre><code class="language-bash">docker run -it --name node-dev -p 5000:5000 --mount type=bind,src=path/to/project,target=/app your-image zsh
</code></pre>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic setup</a></h2>
<p>create two dirs : backend frontend
npm init -y [You can optionally change project name in package.json]
npm install express mongoose dotenv
edit 'package.json' to add the <code>"type": "module",</code> variable</p>
<h2 id="node-setup-backend"><a class="header" href="#node-setup-backend">Node setup (Backend)</a></h2>
<h3 id="first-server-file"><a class="header" href="#first-server-file">First server file</a></h3>
<p>Create <code>server.js</code> in the backend directory and paste the following code :</p>
<pre><code class="language-js">import express from 'express';

const app = express();

app.listen(5000, () =&gt; {
	console.log('Server started at http://localhost:5000');
});
</code></pre>
<p>You can run the server script by typing <code>node backend/server.js</code> in the container
terminal (from within the <code>/app</code> directory)</p>
<p>However, there is an easier way to run this command : Go to
<code>package.json</code> and in the <code>scripts</code> variable, add a <code>,</code> at the end of the <code>test</code>
script and write on a new line : <code>"dev": "node backend/server.js"</code></p>
<p>You can now run : <code>npm run dev</code> to run the <code>dev</code> script</p>
<h3 id="nodemon-install"><a class="header" href="#nodemon-install">Nodemon install</a></h3>
<p>To monitor the changes in the server we'll install nodemon with</p>
<p><code>npm install -D nodemon</code></p>
<p>This will add nodemon to our <code>devDependancies</code> (thanks to the <code>-D</code> option). These are the
dependancies needed to develop the app.</p>
<p>You can now update your script to <code>nodemon backend/server.js</code></p>
<blockquote>
<p>If the application is not restarting when a file changes, update your script to:
<code>nodemon -L backend/server.js</code> (the <code>-L</code> option is to
enable the <a href="https://github.com/remy/nodemon?tab=readme-ov-file#application-isnt-restarting">legacy-watch</a>)</p>
</blockquote>
<h3 id="first-route"><a class="header" href="#first-route">First route</a></h3>
<p>Let's now add a route to visit the homepage :</p>
<p>add this above your <code>app.listen</code> function :</p>
<pre><code class="language-js">app.get("/", (req, res) =&gt; {
	res.send("Server is ready");
});
</code></pre>
<h3 id="testing-the-first-route"><a class="header" href="#testing-the-first-route">Testing the first route</a></h3>
<p>You can test this route by running  either :</p>
<ol>
<li><code>curl localhost:5000</code> in your docker container</li>
<li><code>curl localhost:5001</code> in your machine terminal</li>
<li><code>visiting localhost:5001</code> in your favorite browser</li>
</ol>
<h2 id="mongodb-database-setup"><a class="header" href="#mongodb-database-setup">Mongodb Database Setup</a></h2>
<p>As we aim to deploy our app in the simplest way possible, we'll setup our mongodb
database taking advantage of the fact that Mongodb is an OpenSource database engine
and use the Official <a href="https://hub.docker.com/_/mongo/">Mongodb Docker Image</a></p>
<h3 id="env-file-creation"><a class="header" href="#env-file-creation"><code>.env</code> file creation</a></h3>
<p>First, let's define a few variables in a <code>.env</code> file within our app directory.</p>
<p>Paste the following in your <code>.env</code> file:</p>
<pre><code class="language-bash">MONGO_INITDB_ROOT_USERNAME="root"
MONGO_INITIDB_ROOT_PASSWORD="bonjour"
</code></pre>
<h3 id="docker-network-creation"><a class="header" href="#docker-network-creation">Docker Network creation</a></h3>
<p>Now that we have two containers over the network, we need to make them communicate.</p>
<blockquote>
<p>:warning: From now on, you won't be able to run the project if the mongodb container
isn't up <strong>before</strong> you start the node server</p>
</blockquote>
<p>First, let's create a network so our containers can exchange data. To do so, let's run
the command :</p>
<pre><code class="language-bash">docker network create mern-app-network
</code></pre>
<h3 id="attaching-the-server-container-to-the-network"><a class="header" href="#attaching-the-server-container-to-the-network">Attaching the server-container to the network</a></h3>
<p>Now we are going to stop and remove our first container (we need to do so in order
to recreate it)</p>
<pre><code class="language-bash">docker stop node-dev &amp;&amp; docker rm node-dev
</code></pre>
<p>We can now recreate it and attach it to the newly created network (here we'll give it the
same network alias as its name):</p>
<pre><code class="language-bash">docker run -it --name node-dev --network mern-app-network --network-alias node-dev -p 5000:5000 --mount type=bind,src=path/to/project,target=/app your-image zsh
</code></pre>
<h3 id="instanciating-our-database-container"><a class="header" href="#instanciating-our-database-container">Instanciating our database container</a></h3>
<p>Now that our environement is ready, let's create our database container and attach it to
the network. To do so let's type in the following commands :</p>
<pre><code class="language-bash">docker run -d --network mern-app-network --network-alias database --name database mongo:latest
</code></pre>
<blockquote>
<p>:bulb: For now, we don't use our authentication configuration from the environment in
order to get used to the database</p>
</blockquote>
<h3 id="testing-the-connection"><a class="header" href="#testing-the-connection">Testing the connection</a></h3>
<p>To test the connection, let's run the following command :</p>
<pre><code class="language-bash">docker run -it --network mern-app-network --rm mongo mongosh --host database test
</code></pre>
<p>It :</p>
<ol>
<li>Connects to the database running on the <code>database</code> host</li>
<li>Creates the table <code>test</code></li>
<li>Puts us into the table, ready to insert some data</li>
</ol>
<h3 id="connecting-to-the-database-with-mongoose"><a class="header" href="#connecting-to-the-database-with-mongoose">Connecting to the database with mongoose</a></h3>
<p>Let's add a new variable in our <code>.env</code> file :</p>
<pre><code class="language-bash">MONGO_URI="mongodb://database:27017/mern-stack-app"
</code></pre>
<p>The format of the connection string is the following :</p>
<pre><code class="language-bash">mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]
</code></pre>
<p>Which is fully described in the <a href="https://www.mongodb.com/docs/manual/reference/connection-string/#standard-connection-string-format">docs</a></p>
<h3 id="importing-the-config-in-the-serverjs-file"><a class="header" href="#importing-the-config-in-the-serverjs-file">Importing the config in the <code>server.js</code> file</a></h3>
<p>Go in <code>server.js</code> and paste the following right after <code>import express from 'express'</code>:</p>
<pre><code class="language-js">import dotenv from 'dotenv';

dotenv.config();
</code></pre>
<p>This will use the <code>config</code> function from the <code>dotenv</code> module to read all the environment
variable stored in our <code>.env</code> file.</p>
<p>All the files that will be imported by <code>server.js</code> will then have access to our
environment variables.</p>
<p>For now on, we'll use our newly created <code>MONGO_URI</code> variable</p>
<h3 id="creating-the-configdbjs-file"><a class="header" href="#creating-the-configdbjs-file">Creating the <code>config/db.js</code> file</a></h3>
<p>Let's create a new directory within the backend directory called <code>config</code> and paste the
following into the <code>db.js</code> file :</p>
<pre><code class="language-js">import mongoose from 'mongoose';

export const connectDB = async () =&gt; {
    try {
        const conn = await mongoose.connect(process.env.MONGO_URI);
        console.log(`MongoDB Connected: ${conn.connection.host}`);
    } catch (error) {
        console.error(`Error: ${error.message}`);
        process.exit(1);
    }
}
</code></pre>
<p>This will use the <code>MONGO_URI</code> variable and connect to the database <code>mern-stack-app</code></p>
<h3 id="connecting-the-database"><a class="header" href="#connecting-the-database">Connecting the database</a></h3>
<p>Add the following import statement to <code>server.js</code> :</p>
<pre><code class="language-js">import { connectDB } from './config/db.js';
</code></pre>
<p>add also the following statement, right at the beginning of the <code>app.listen</code> function
(after the <code>{</code>) :</p>
<pre><code class="language-js">connectDB();
</code></pre>
<p>You should now see the following line in your server terminal (which runs in your docker
container)</p>
<pre><code class="language-bash">MongoDB Connected: database
</code></pre>
<blockquote>
<p>:warning: In case you can't connect to the database, make sure you deleted and restarted
the <code>node-dev</code> container and attached it to the <code>mern-app-network</code>
You should have added the options <code>--network mern-app-network</code> and
<code>--network-alias node-dev</code> to your <code>docker run</code> command</p>
</blockquote>
<h2 id="creating-our-models"><a class="header" href="#creating-our-models">Creating our models</a></h2>
<p>To create our database models, we'll use the <code>mongoose</code> package. For now, let's create a
<code>product</code> model into a new <code>backend/models</code> directory (from now on, we'll refer to
<code>backend/models</code> as <code>models</code>)</p>
<h3 id="creating-our-first-schema"><a class="header" href="#creating-our-first-schema">Creating our first Schema</a></h3>
<p>Paste the following code in <code>models/Product.js</code>:</p>
<pre><code class="language-js">import mongoose from 'mongoose';

const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true
    },
    image: {
        type: String,
        required: true
    },
}, {
    timestamp: true //createdAt, updatedAt
});
</code></pre>
<p>What it does is that it takes a <a href="https://mongoosejs.com/docs/guide.html#schemas">schema</a>
definition that every object of our database will have to adhere to. It also adds a
<a href="https://mongoosejs.com/docs/timestamps.html">timestamp</a> to each object when it is
either created or updated. The schema specification is in the
<a href="https://www.json.org/json-en.html">json</a> format.</p>
<p>From this schema we can see that <strong>each</strong> product will have :</p>
<ul>
<li>A name, which is a String</li>
<li>A price, which is a Number</li>
<li>An image, which is a String (and will be the url of a resource that represents our
product)</li>
</ul>
<h3 id="compiling-our-schema-into-a-model"><a class="header" href="#compiling-our-schema-into-a-model">Compiling our schema into a model</a></h3>
<p>Now that our schema is ready, we need to compile it into a
<a href="https://mongoosejs.com/docs/models.html">model</a> we can work with in our code</p>
<p>Add the following line at the end of <code>models/Product.js</code>:</p>
<pre><code class="language-js">const Product = mongoose.model('Product', productSchema);
</code></pre>
<p>This will compile our <em>schema</em> into a <em>model</em>. We our now able to export it to be usable
by other js scripts with the following line :</p>
<pre><code class="language-js">export default Product;
</code></pre>
<p>That you should add at the end of <code>Product.js</code></p>
<blockquote>
<p>:bulb: The model name is <code>Product</code> and not <code>products</code> as mongoose will automatically
look for the lowercased and plural version of your model name in the collections and
create it for you. So for example, if you were to create the <code>cars</code> collection, you'd
be required to create the <code>Car</code> model and not the <code>cars</code> model</p>
</blockquote>
<h2 id="creating-our-api"><a class="header" href="#creating-our-api">Creating our API</a></h2>
<h3 id="first-real-route----adding-some-products"><a class="header" href="#first-real-route----adding-some-products">First Real Route -- <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">adding</a> some products</a></h3>
<p>Up until now, we were only able to check that the server is up and running. Let's  now
include our new <code>products</code> collection into the mix. Let's create a route <code>/products</code>
which will accept the request method <span class=spoiler>POST</span> (as we want to send
data to our API through this route).</p>
<p>Let's now add the following code to our <code>server.js</code> file :</p>
<pre><code class="language-js">import Product from './models/Product.js';
</code></pre>
<p>To import our newly created <code>Product</code> model from the file it resides in</p>
<p>Let's now add the first route of our app (You can paste this code right under the
statement <code>app.use(express.json());</code>:</p>
<pre><code class="language-js">app.post("/products", async (req, res) =&gt; {
    const product = req.body // user will send this data

    if (!product) {
        return res.status(400).json({
            success: false,
            message: "Please provide a request body"
        });
    }

    if (!product.name || !product.price || !product.image) {
        return res.status(400).json({
            success: false,
            message: "Please provide all fields" 
        });
    }
    const newProduct = new Product(product);

    try {
        await newProduct.save();
        res.status(201).json({
            success: true,
            data: newProduct
        });
    } catch (error) {
        console.log("Error in Create Product:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});
</code></pre>
<h3 id="testing-our-first-route"><a class="header" href="#testing-our-first-route">Testing our First Route</a></h3>
<blockquote>
<p>:bulb: If you are used to testing your API routes, feel free to use the method you're
the most used too. Don't switch methods because I showed you that one. The main goal
is to make you a real full stack programmer, not to destroy the knowledge you've spent
months (if not years) acquiring.</p>
</blockquote>
<p>As I'm more a CLI guy than a GUI guy, we'll use a utility called <code>cURL</code> to do so. Let's
first prepare our data. At the root of the project, we'll create a directory called
<code>test_data</code>. This is were our test JSON files will live. Let's now create a <code>product</code> file
in this <code>test_data</code> directory (we'll reorganize the directory later on but for now it is
enough).</p>
<blockquote>
<p>:bulb: If you are on Windows and can't create a file without an extension, you can
give the extension <code>.json</code> to all the files we'll create in the <code>test_data</code> directory</p>
</blockquote>
<p>Here is an example of what our directory structure looks like so far :</p>
<pre><code class="language-bash">.
├── backend
│   ├── config
│   │   └── db.js
│   ├── models
│   │   └── Product.js
│   └── server.js
├── frontend
├── package-lock.json
├── package.json
└── test_data
    └── product

7 directories, 8 files
</code></pre>
<p>Let's put the following data in our <code>product</code> (or <code>product.js</code>) file:</p>
<pre><code class="language-json">{
    "name": "test_product",
    "price": 100,
    "image": "1234"
}
</code></pre>
<p>This is a valid product definition which should be properly handled by our server. Let's
now test this definition using the following command (from the root of our project) :</p>
<pre><code class="language-bash">curl --json @test_data/product localhost:5000/products
</code></pre>
<p>You should see the following message:</p>
<pre><code class="language-bash">{"success":false,"message":"Please provide a request body"}
</code></pre>
<p>Don't try to debug the command, it is working. The solution resides in the fact that
we have to install the proper
<a href="https://www.geeksforgeeks.org/what-is-middleware/">middleware</a> to handle the JSON
interpretation for us.</p>
<h3 id="installing-the-json-middleware"><a class="header" href="#installing-the-json-middleware">Installing the json middleware</a></h3>
<p>We'll use the <a href="https://expressjs.com/en/api.html#express.json"><code>express.json</code></a> method in
order to parse the request content as JSON. It is actually a built-in middleware that we
can use without importing any further module. To do so, let's add the following statement
right after instantiating our <code>app</code> variable :</p>
<pre><code class="language-js">app.use(express.json()); //allows us to accept JSON data in req body
</code></pre>
<p>we can now relaunch the <code>cURL</code> command and observe that we get a successful response</p>
<h3 id="renaming-the-routes-as-a-good-practice"><a class="header" href="#renaming-the-routes-as-a-good-practice">Renaming the routes as a good practice</a></h3>
<p>Before continuing, let's rename our <code>products</code> route. It is a good practice to prefix all
the API routes by <code>/api</code> so let's do this in our product route. Change the statement :
<code>app.post("/products", ...)</code> into <code>app.post("/api/products", ...)</code></p>
<blockquote>
<p>:bulb: It seems to be widely accepted that it is a better practice to do so, however
I didn't find any official documentation to back that fact up. For those interested,
you can consult the following documents :</p>
<ol>
<li><a href="https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/">Stackoverflow blogpost</a> about REST APIs design.</li>
<li><a href="https://restfulapi.net/rest-api-best-practices/">Restful api</a> (non official website)
about API best practices.</li>
<li><a href="https://cloud.google.com/blog/products/api-management/restful-web-api-design-best-practices">Google Cloud</a>
guide about API design practices.</li>
<li>This <a href="backend/./api_prefixing.html">ChatGPT</a> summary about the ins and outs of following such
design practices.</li>
</ol>
</blockquote>
<h3 id="our-first-parameters"><a class="header" href="#our-first-parameters">Our first parameters</a></h3>
<p>Let's now try to create a route that allows us to delete one product. We'll give this
route the product id as a <a href="https://expressjs.com/en/guide/routing.html">parameter</a>.</p>
<blockquote>
<p>:bulb: If you open this documentation link, you'll have to <code>^f</code> for (or <code>cmd+f</code> on mac)
and search for <code>Route parameters</code> (case sensitive search)</p>
</blockquote>
<p>Let's add the following code to our <code>server.js</code> file (right after the <code>app.post</code> route):</p>
<pre><code class="language-js">app.delete("/api/products/:id", async (req, res) =&gt; {
    const { id } = req.params;
    console.log(`id: \`${id}'`);
});
</code></pre>
<p>What it will do is allow us to give params to our requests to this route (in the
<code>req.params</code> variable).
We <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructure</a>
the <code>req.params.id</code> into a variable named <code>id</code> and print it to the console.</p>
<h3 id="testing-our-parametrized-request"><a class="header" href="#testing-our-parametrized-request">Testing our parametrized request</a></h3>
<p>Let's now write a <code>cURL</code> request that will allow us to test our newly created route. We
can use the <code>-X</code> option to specify the HTTP Method we'd like to use. Thus leading us to
the full request :</p>
<pre><code class="language-bash">curl -X DELETE localhost:5001/api/products/bonjour
</code></pre>
<p>As you can see, even though the request was received by the server and the <code>id: bonjour</code>
was printed, we can observe that the request hangs. This is because, by default, <code>cURL</code>
doesn't have any timeout once connected (if the file is very large or the network very
slow for example). To prevent our requests from hanging, we'll set a reasonnable timeout
of 3 ms using the <code>-m</code> (or <code>--max-time</code>) option.</p>
<p>Our full command is then:</p>
<pre><code class="language-bash">curl -X DELETE -m 3 localhost:5001/api/products/bonjour
</code></pre>
<h3 id="implementing-the-product-deletion"><a class="header" href="#implementing-the-product-deletion">Implementing the product <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE">deletion</a></a></h3>
<p>To delete our product we'll use the method
[<code>findByIdAndDelete</code>](https://mongoosejs.com/docs/api/model.html#Model.findByIdAndDelete(%29)
of the <code>mongoose</code> models.</p>
<p>Let's add a <code>try..catch</code> block with the following inside our newly created <code>app.delete</code>
route:</p>
<pre><code class="language-js">try {
    await Product.findByIdAndDelete(id);
    res.status(200).json({
        success: true,
        message: "Product successfully deleted"
    });
} catch (error) {
    console.log("Error in Create Product:", error.message);
    res.status(404).json({
        success: false,
        message: "Product not found"
    });
}
</code></pre>
<p>We can now:</p>
<ol>
<li>Add a product using the <code>/api/products</code> endpoint</li>
<li>Retrieve the id from the response</li>
<li>Use our <code>/api/products:id</code> endpoint to delete the product</li>
</ol>
<p>If you followed all the steps up until now you should receive the response:</p>
<pre><code class="language-bash">{"success":true,"message":"Product successfully deleted"}
</code></pre>
<p>in your terminal.</p>
<h2 id="implementing-more-routes"><a class="header" href="#implementing-more-routes">Implementing more routes</a></h2>
<h3 id="get-all-products"><a class="header" href="#get-all-products"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET">Get</a> all products</a></h3>
<p>Let's implement a route that will allow us to get all products. Let's add the following
code fragment, right above the <code>app.post</code> route in our <code>server.js</code> file:</p>
<pre><code class="language-js">app.get("/api/products", async (req, res) =&gt; {
    try {
        const products = await Product.find({});
        res.status(200).json({
            success: true,
            data: products
        });
    } catch (error) {
        console.log("Error in fetching products:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});
</code></pre>
<blockquote>
<p>We give use the <code>{}</code> in the
[.find()](https://mongoosejs.com/docs/api/model.html#Model.find(%29) function
in order to retrieve all the products in the <code>products</code> collection.</p>
</blockquote>
<h3 id="testing-our-new-route"><a class="header" href="#testing-our-new-route">Testing our new route</a></h3>
<p>Let's now add a few products to our database. You can either use a <code>cURL</code> request
with different products or you can run it in a for loop (like the following if you're
using <code>bash</code>):</p>
<blockquote>
<p>Once again, I'm a CLI guy so I suggest and use CLI tools, however if you're used
to another method of working, feel free to do so with the method you've been acustomed
to</p>
</blockquote>
<pre><code class="language-bash">for i in {0..9}; do curl --json @test_data/product localhost:5000/api/products ; done
</code></pre>
<p>You can see that this command added 10 products (the same though) to our database</p>
<p>Let's now test our route. To do so, once again we can use our friend <code>cURL</code> to do the
job for us.</p>
<pre><code class="language-bash">curl localhost:5000/api/products
</code></pre>
<blockquote>
<p>If you've been following the instructions in the terminal like I showed, you may have
found that the output is not quite readable on its own. No worries, we can use another
utility for that. It is called <a href="https://jqlang.org/manual/"><code>jq</code></a> and is a great tool
to work with json on itself, but for now we'll only use it to produce a more readble
output from the <code>cURL</code> command.</p>
<p>You can run :</p>
<pre><code class="language-bash">curl localhost:5000/api/products | jq
</code></pre>
<p>to get a more readable output from the <code>cURL</code> command</p>
</blockquote>
<h3 id="our-last-crud-operation---updating-a-product-state"><a class="header" href="#our-last-crud-operation---updating-a-product-state">Our last CRUD operation - <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT">updating</a> a product state</a></h3>
<p>Let's implement the update of a product. Let's paste the following code in our <code>server.js</code>
file. Somewhere near the other endpoints.</p>
<pre><code class="language-js">app.put("/api/products/:id", async (req, res) =&gt; {
    const { id } = req.params;

    const product = req.body;

    try {
        const updatedProduct = await Product.findByIdAndUpdate(id, product, {new: true});
        res.status(200).json({
            success: true,
            message: updatedProduct
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});
</code></pre>
<p>We have just created a
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a>
route where a user can updated a product using the
[<code>findByIdAndUpdate</code>](https://mongoosejs.com/docs/api/model.html#Model.findByIdAndUpdate(%29) mongoose method.</p>
<h3 id="testing-our-route"><a class="header" href="#testing-our-route">Testing our route</a></h3>
<p>First let's get the id of one of our products. To do so, let's get all the products and
pick the id of one product</p>
<p>We can now test the route by running :</p>
<pre><code class="language-bash">curl -X PUT --json { "name": "Bonjour" } localhost:5001/api/products/&lt;our_product_id&gt;
</code></pre>
<blockquote>
<p>:bulb: Don't forget to replace <code>&lt;our_product_id&gt;</code> with a real product id</p>
</blockquote>
<p>We can now see that the request was successful.</p>
<p>However, if the user enters a wrong id, we get a "Server Error", which isn't a very
explicit message. Let's try and make it a bit more verbose.</p>
<p>First, let's add the following import statement to our <code>server.js</code> near the other
statements:</p>
<pre><code class="language-js">import mongoose from 'mongoose';
</code></pre>
<p>And then let's add the following code fragment, right before the <code>try..catch</code> block
in our <code>app.put</code> function:</p>
<pre><code class="language-js">if (! mongoose.isValidObjectId(id)) {
    return res.status(404).json({
        success: false,
        message: "Product not found"
    });
}
</code></pre>
<p>What it does is that it uses the [<code>isValidObjectId()</code>](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.isValidObjectId(%29)
method of the mongoose module to check if the id can be used to construct an
<a href="https://mongoosejs.com/docs/schematypes.html#objectids">ObjectId</a> variable</p>
<p>Now, when we run our request with an invalid id, for example:</p>
<pre><code class="language-bash">curl -X PUT --json { "name": "Bonjour" } localhost:5001/api/products/1234
</code></pre>
<p>We now get the "Product not found" message.</p>
<h2 id="organizing-application-files"><a class="header" href="#organizing-application-files">Organizing Application Files</a></h2>
<h3 id="creating-a-router"><a class="header" href="#creating-a-router">Creating a <a href="https://expressjs.com/en/api.html#router">router</a></a></h3>
<p>The goal of a router is to allow us "route" our request to the corresponding application
it basically allows us to split our app into multiple files/folders and to send specific
requests to specific endpoints.</p>
<p>To create a router, let's create a <code>routes</code> directory within the backend directory
and put the following code into <code>routes/Product.js</code>:</p>
<pre><code class="language-js">import express from "express"

const router = express.Router();

export default router;
</code></pre>
<p>It basically creates a <code>Router</code> object and exports it for use by other apps</p>
<h3 id="giving-our-routes-to-the-newly-created-router"><a class="header" href="#giving-our-routes-to-the-newly-created-router">Giving our routes to the newly created router</a></h3>
<p>Let's now take our routes and give them to the router. To so, let's remove them from
<code>server.js</code> and put them into <code>routes/Product.js</code>:</p>
<details>
<summary>`routes/Product.js`</summary>
<pre><code class="language-js">import express from "express"

const router = express.Router();

router.get("/api/products", async (req, res) =&gt; {
    try {
        const products = await Product.find({});
        res.status(200).json({
            success: true,
            data: products
        });
    } catch (error) {
        console.log("Error in fetching products:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});

router.post("/api/products", async (req, res) =&gt; {
    const product = req.body // user will send this data

    if (!product) {
        return res.status(400).json({
            success: false,
            message: "Please provide a request body"
        });
    }

    if (!product.name || !product.price || !product.image) {
        return res.status(400).json({
            success: false,
            message: "Please provide all fields" 
        });
    }
    const newProduct = new Product(product);

    try {
        await newProduct.save();
        res.status(201).json({
            success: true,
            data: newProduct
        });
    } catch (error) {
        console.log("Error in Create Product:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});

router.delete("/api/products/:id", async (req, res) =&gt; {
    const { id } = req.params;

    try {
        await Product.findByIdAndDelete(id);
        res.status(200).json({
            success: true,
            message: "Product successfully deleted"
        });
    } catch (error) {
        console.log("Error in Create Product:", error.message);
        res.status(404).json({
            success: false,
            message: "Product not found"
        });
    }
});

router.put("/api/products/:id", async (req, res) =&gt; {
    const { id } = req.params;

    const product = req.body;

    if (! mongoose.isValidObjectId(id)) {
        return res.status(404).json({
            success: false,
            message: "Product not found"
        });
    }
    try {
        const updatedProduct = await Product.findByIdAndUpdate(id, product, {new: true});
        res.status(200).json({
            success: true,
            message: updatedProduct
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
});

export default router;
</code></pre>
</details>
<details>
<summary>`backend` directory structure</summary>
<pre><code class="language-bash">backend/
├── config
│   └── db.js
├── models
│   └── Product.js
├── routes
│   └── Product.js
└── server.js

4 directories, 4 files
</code></pre>
</details>
<p>Now we can now
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import</a>
the <code>router</code> that is
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export</a>ed
in <code>routes/Products.js</code> with any name (because it is the default export).</p>
<blockquote>
<p>:warning: Don't forget to fix the import statements in the <code>routes/Product.js</code> file</p>
</blockquote>
<h3 id="importing-our-router"><a class="header" href="#importing-our-router">Importing our router</a></h3>
<p>Let's now import <code>productRouter</code> from <code>./routes/Product.js</code></p>
<p>Write the following code to <code>backend/server.js</code>:</p>
<pre><code class="language-js">app.use("/api/products", productRouter);
</code></pre>
<p>You could put it right after the <code>app.use(express.json());</code></p>
<p>Let's now replace the <code>/api/products</code> part of the url in every route with <code>/</code> (because now
the router is the hub that receive all the requests that target <code>/api/products</code>)</p>
<p>From now on you can test the routes and see that everything is working as before</p>
<h3 id="creating-controllers"><a class="header" href="#creating-controllers">Creating controllers</a></h3>
<p>Let's make our code even cleaner by putting our functions into a controllers file</p>
<blockquote>
<p>:bulb: The controllers come from the
<a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC</a> architecture.</p>
<p>It is also detailed
<a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/routes">here</a></p>
</blockquote>
<p>Let's extract each of our reply functions and put them into a separate <code>Product</code> file
under a <code>controllers</code> directory</p>
<details>
<summary>Directory Structure of the `backend` directory</summary>
<pre><code class="language-bash">backend/
├── config
│   └── db.js
├── controllers
│   └── Product.js
├── models
│   └── Product.js
├── routes
│   └── Product.js
└── server.js

5 directories, 5 files
</code></pre>
</details>
<details>
<summary>`controllers/Product.js` file</summary>
<pre><code class="language-js">import mongoose from 'mongoose';
import Product from '../models/Product.js';

export const getProducts = async (req, res) =&gt; {
    try {
        const products = await Product.find({});
        res.status(200).json({
            success: true,
            data: products
        });
    } catch (error) {
        console.log("Error in fetching products:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
};

export const createProduct = async (req, res) =&gt; {
    const product = req.body // user will send this data

    if (!product) {
        return res.status(400).json({
            success: false,
            message: "Please provide a request body"
        });
    }

    if (!product.name || !product.price || !product.image) {
        return res.status(400).json({
            success: false,
            message: "Please provide all fields" 
        });
    }
    const newProduct = new Product(product);

    try {
        await newProduct.save();
        res.status(201).json({
            success: true,
            data: newProduct
        });
    } catch (error) {
        console.log("Error in Create Product:", error.message);
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
};

export const deleteProduct = async (req, res) =&gt; {
    const { id } = req.params;

    try {
        await Product.findByIdAndDelete(id);
        res.status(200).json({
            success: true,
            message: "Product successfully deleted"
        });
    } catch (error) {
        console.log("Error in Create Product:", error.message);
        res.status(404).json({
            success: false,
            message: "Product not found"
        });
    }
};


export const updateProduct = async (req, res) =&gt; {
    const { id } = req.params;

    const product = req.body;

    if (! mongoose.isValidObjectId(id)) {
        return res.status(404).json({
            success: false,
            message: "Product not found"
        });
    }
    try {
        const updatedProduct = await Product.findByIdAndUpdate(id, product, {new: true});
        res.status(200).json({
            success: true,
            message: updatedProduct
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Server Error"
        });
    }
};
</code></pre>
</details>
<p>Let's now use these controllers in our <code>routes/Product.js</code> file.</p>
<p>First, add the following import statements (we have to import all the routes):</p>
<pre><code class="language-js">import {
    createProduct,
    deleteProduct,
    getProducts,
    updateProduct
} from "../controllers/Product.js";
</code></pre>
<p>Now, replace the original routes with the following code fragment:</p>
<pre><code class="language-js">router.get("/", getProducts);
router.post("/", createProduct);
router.delete("/:id", deleteProduct);
router.put("/:id", updateProduct);
</code></pre>
<p>You should now be able to run all the requests we've previously ran before.</p>
<blockquote>
<p>:bulb: Writting these lines, I realise that it may be useful to write a small script
(if using <code>cURL</code>) that tests the routes all at once. Just to get sure that we get the
right response when everything is in order.</p>
<p>Let's do so.</p>
<p>We'll start by adding a product, then getting the product, then updating the product
and finally deleting the product (you got it right, CRUD!)</p>
<pre><code class="language-bash">a=$(mktemp);
if ! curl -s --json @test_data/product localhost:5000/api/products &gt; "$a";
then echo "POST request failed"; kill -INT $$; fi
id="$(jq &lt; "$a" | grep _id | cut -f 2 -d ':' | grep -E '[^" ]+' -o | head -n 1)"
if ! curl -s localhost:5000/api/products &gt;/dev/null;
then echo "GET request failed"; kill -INT $$; fi
if ! curl -s -X PUT --json '{ "name": "Salut" }' localhost:5000/api/products/"$id" &gt;/dev/null;
then echo "PUT request failed"; kill -INT $$; fi
if ! curl -s -X DELETE localhost:5000/api/products/"$id" &gt;/dev/null;
then echo "DELETE request failed"; kill -INT $$; fi
echo -e "\nCRUD properly implemented!";
</code></pre>
<p>With the previously written script, we can thus ensure that our application is
working right. We can now run it every time we want to modify something just to get sure
that we are keeping the state as is (not introducing unwanted modifications)</p>
</blockquote>
<p>With the backend now done, we can safely move on to the frontend. But first, lets get
the port from the environment (instead of hardcoding it) and let the hardcoded port as
a fallback value if the port is undefined.</p>
<p>Let's add the following to our <code>server.js</code>:</p>
<pre><code class="language-js">const PORT = process.env.PORT || 5000;
</code></pre>
<p>And let's change the <code>5000</code> with our newly created <code>PORT</code> variable in the <code>app.listen</code>
function.</p>
<p>It should now look like this code fragment:</p>
<pre><code class="language-js">app.listen(PORT, () =&gt; {
    connectDB();
	console.log('Server started at http://localhost:' + PORT);
});
</code></pre>
<p>We are now all set to implement our frontend.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-1-basic-express-setup-hello-world"><a class="header" href="#exercise-1-basic-express-setup-hello-world"><strong>Exercise 1: Basic Express Setup ("Hello World+")</strong></a></h1>
<p>Your goal is to <strong>set up an Express server</strong> that can handle different types of requests.</p>
<hr />
<h2 id="requirements"><a class="header" href="#requirements"><strong>Requirements</strong></a></h2>
<ol>
<li><strong>Set up an Express server</strong> that listens on port <code>5000</code>.</li>
<li><strong>Add the following routes:</strong>
<ul>
<li><code>GET /time</code> → Returns <code>{ "serverTime": &lt;current server time&gt; }</code>.</li>
<li><code>GET /echo/:message</code> → Returns <code>{ "message": "&lt;your-text&gt;" }</code>.</li>
<li><code>POST /api/mock/create</code> → Returns <code>{ "message": "Mock user created" }</code>.</li>
<li><code>PUT /api/mock/update</code> → Returns <code>{ "message": "Mock user updated" }</code>.</li>
<li><code>DELETE /api/mock/delete</code> → Returns <code>{ "message": "Mock user deleted" }</code>.</li>
</ul>
</li>
<li><strong>Ensure all responses are in JSON format</strong> (not plain text).</li>
<li><strong>Use HTTP status codes correctly</strong> (e.g., <code>201 Created</code> for <code>POST</code>, <code>200 OK</code> for <code>GET</code>, etc.).</li>
<li><strong>Test all routes using cURL</strong> to make sure they return the correct data.</li>
</ol>
<hr />
<h2 id="documentation"><a class="header" href="#documentation"><strong>Documentation</strong></a></h2>
<p>Use the following <strong>official Express documentation</strong> to complete the exercise:</p>
<ul>
<li><a href="https://expressjs.com/en/guide/routing.html">Express Routing</a></li>
<li><a href="https://expressjs.com/en/guide/routing.html#route-parameters">Express Route Parameters (<code>req.params</code>)</a></li>
<li><a href="https://expressjs.com/en/api.html#res.json">Express JSON Response (<code>res.json</code>)</a></li>
<li><a href="https://expressjs.com/en/5x/api.html#res.status">Express Status Codes (<code>res.status</code>)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP Methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>)</a></li>
<li><a href="https://expressjs.com/en/guide/writing-middleware.html">Writing Middleware</a></li>
<li><a href="https://expressjs.com/en/guide/using-middleware.html">Using Middleware</a></li>
</ul>
<hr />
<h2 id="how-to-test-your-api"><a class="header" href="#how-to-test-your-api"><strong>How to Test Your API</strong></a></h2>
<p>After setting up the server, test the endpoints using <strong>cURL</strong>:</p>
<pre><code class="language-bash">curl http://localhost:5000/time
curl http://localhost:5000/echo/hello
curl -X POST http://localhost:5000/api/mock/create
curl -X PUT http://localhost:5000/api/mock/update
curl -X DELETE http://localhost:5000/api/mock/delete
</code></pre>
<h3 id="expected-output"><a class="header" href="#expected-output"><strong>Expected Output</strong></a></h3>
<p>If your implementation is correct, you should get responses like:</p>
<pre><code class="language-json">// GET /time
{ "serverTime": "2024-02-17T12:00:00Z" }

// GET /echo/hello
{ "message": "hello" }

// POST /api/mock/create
{ "message": "Mock user created" }

// PUT /api/mock/update
{ "message": "Mock user updated" }

// DELETE /api/mock/delete
{ "message": "Mock user deleted" }
</code></pre>
<blockquote>
<p>:warning: The timestamp might be slightly different depending
on your machine language and locale</p>
</blockquote>
<hr />
<h2 id="bonus-optional-if-you-finish-early"><a class="header" href="#bonus-optional-if-you-finish-early"><strong>Bonus (Optional, if you finish early)</strong></a></h2>
<p>If you complete the exercise quickly, try these extra challenges:</p>
<ol>
<li>Modify <code>/time</code> to return <strong>more details</strong>, such as:
<pre><code class="language-json">{ "serverTime": "2024-02-17T12:00:00Z", "timezone": "UTC" }
</code></pre>
</li>
<li>Add a new route:
<ul>
<li><code>GET /hello/:name</code> → Returns <code>{ "greeting": "Hello, &lt;name&gt;!" }</code>.</li>
</ul>
</li>
<li><strong>Modify the status codes</strong> for each request to match HTTP conventions:
<ul>
<li><code>POST /api/mock/create</code> → Should return <strong><code>201 Created</code></strong>.</li>
<li><code>DELETE /api/mock/delete</code> → Should return <strong><code>204 No Content</code></strong>.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-2-mongodb-integration-user-management-system"><a class="header" href="#exercise-2-mongodb-integration-user-management-system"><strong>Exercise 2: MongoDB Integration (User Management System)</strong></a></h1>
<p>Your goal is to <strong>set up a user management system in Express using MongoDB</strong>, handling <strong>duplicate key errors</strong> properly.</p>
<hr />
<h2 id="requirements-1"><a class="header" href="#requirements-1"><strong>Requirements</strong></a></h2>
<ol>
<li><strong>Set up MongoDB connection</strong> using <code>mongoose</code>.</li>
<li><strong>Create a <code>User</code> model</strong> with the following fields:
<ul>
<li><code>username</code> (String, required, <strong>unique</strong>).</li>
<li><code>email</code> (String, required, <strong>unique</strong>).</li>
<li><code>created_at</code> (Timestamp, defaults to current time).</li>
</ul>
</li>
<li><strong>Implement the following API routes:</strong>
<ul>
<li><code>POST /api/users</code> → Creates a new user.</li>
<li><code>GET /api/users</code> → Returns a list of all users.</li>
</ul>
</li>
<li><strong>Use proper HTTP error responses</strong>:
<ul>
<li><code>400 Bad Request</code> → If required fields are missing.</li>
<li><code>409 Conflict</code> → If <code>username</code> or <code>email</code> already exists (<strong>handle duplicate key errors</strong>).</li>
<li><code>500 Internal Server Error</code> → For unexpected errors.</li>
</ul>
</li>
<li><strong>Ensure all responses are in JSON format</strong>.</li>
<li><strong>Test all routes using cURL</strong>.</li>
</ol>
<h3 id="bonus-optional"><a class="header" href="#bonus-optional"><strong>Bonus (Optional)</strong></a></h3>
<ul>
<li><strong>Add input validation</strong>: Ensure <code>username</code> and <code>email</code> follow basic rules (e.g., valid email format, username length).</li>
</ul>
<hr />
<h2 id="handling-duplicate-key-errors-e11000"><a class="header" href="#handling-duplicate-key-errors-e11000"><strong>Handling Duplicate Key Errors (<code>E11000</code>)</strong></a></h2>
<p>Your implementation <strong>must</strong> detect and handle duplicate users correctly.</p>
<ul>
<li>If a user <strong>with the same <code>username</code> or <code>email</code></strong> already exists, MongoDB will throw an <strong>E11000 duplicate key error</strong>.</li>
<li>Your API must <strong>catch this error</strong> and return:
<ul>
<li>HTTP <strong>409 Conflict</strong></li>
<li>A JSON message specifying the conflict.</li>
</ul>
</li>
</ul>
<p><strong>Useful Documentation:</strong></p>
<ul>
<li><a href="https://www.mongodb.com/docs/manual/reference/method/db.collection.insertOne/#duplicate-key-error">MongoDB Duplicate Key Error (<code>E11000</code>)</a></li>
</ul>
<hr />
<h2 id="documentation-1"><a class="header" href="#documentation-1"><strong>Documentation</strong></a></h2>
<p>Use the following <strong>official MongoDB &amp; Express documentation</strong> to complete the exercise:</p>
<ul>
<li><a href="https://mongoosejs.com/docs/models.html">Mongoose Models</a></li>
<li><a href="https://mongoosejs.com/docs/schematypes.html">Mongoose Schema Types</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP Status Codes</a></li>
<li><a href="https://www.mongodb.com/docs/manual/reference/method/db.collection.insertOne/#duplicate-key-error">MongoDB Errors (<code>E11000</code> for duplicate keys)</a></li>
</ul>
<hr />
<h2 id="how-to-test-your-api-1"><a class="header" href="#how-to-test-your-api-1"><strong>How to Test Your API</strong></a></h2>
<p>After implementing the server and database connection, test the endpoints using <strong>cURL</strong>:</p>
<pre><code class="language-bash"># Create a new user
curl --json '{"username":"testUser","email":"test@example.com"}' http://localhost:5000/api/users

# Get all users
curl http://localhost:5000/api/users

# Try creating a duplicate user (should return 409 Conflict)
curl --json '{"username":"testUser","email":"test@example.com"}' http://localhost:5000/api/users
</code></pre>
<hr />
<h3 id="expected-output-1"><a class="header" href="#expected-output-1"><strong>Expected Output</strong></a></h3>
<h4 id="user-creation-post-apiusers"><a class="header" href="#user-creation-post-apiusers"><strong>User Creation (<code>POST /api/users</code>)</strong></a></h4>
<pre><code class="language-json">{
    "message": "User created successfully",
    "user": {
        "_id": "65a42b1fcf6a1c3d9b999999",
        "username": "testUser",
        "email": "test@example.com",
        "created_at": "2024-02-17T12:00:00Z"
    }
}
</code></pre>
<h4 id="user-retrieval-get-apiusers"><a class="header" href="#user-retrieval-get-apiusers"><strong>User Retrieval (<code>GET /api/users</code>)</strong></a></h4>
<pre><code class="language-json">{
    "users": [
        {
            "_id": "65a42b1fcf6a1c3d9b999999",
            "username": "testUser",
            "email": "test@example.com",
            "created_at": "2024-02-17T12:00:00Z"
        }
    ]
}
</code></pre>
<h4 id="handling-duplicate-users-post-apiusers-duplicate-entry"><a class="header" href="#handling-duplicate-users-post-apiusers-duplicate-entry"><strong>Handling Duplicate Users (<code>POST /api/users</code>, duplicate entry)</strong></a></h4>
<pre><code class="language-json">{
    "error": "Username or email already exists"
}
</code></pre>
<p><em>(Response status: <strong>409 Conflict</strong>)</em></p>
<h4 id="other-error-handling-examples"><a class="header" href="#other-error-handling-examples"><strong>Other Error Handling Examples</strong></a></h4>
<ul>
<li><strong>Missing fields (<code>400 Bad Request</code>)</strong>
<pre><code class="language-json">{ "error": "Username and email are required" }
</code></pre>
</li>
<li><strong>Server error (<code>500 Internal Server Error</code>)</strong>
<pre><code class="language-json">{ "error": "Something went wrong" }
</code></pre>
</li>
</ul>
<hr />
<h2 id="bonus-optional-if-you-finish-early-1"><a class="header" href="#bonus-optional-if-you-finish-early-1"><strong>Bonus (Optional, if you finish early)</strong></a></h2>
<p>If you complete the exercise quickly, try these extra challenges:</p>
<ol>
<li><strong>Validate email format</strong> before saving the user.</li>
<li><strong>Ensure <code>username</code> has at least 3 characters</strong>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-3-more-crud"><a class="header" href="#exercise-3-more-crud"><strong>Exercise 3: More CRUD</strong></a></h1>
<h2 id="exercise-3a-crud-with-route-parameters-book-api"><a class="header" href="#exercise-3a-crud-with-route-parameters-book-api"><strong>Exercise 3A: CRUD with Route Parameters (Book API)</strong></a></h2>
<p>Your goal is to implement a <strong>CRUD API</strong> for books, using <strong>route parameters (<code>req.params</code>) only where it makes sense</strong>, while keeping <code>POST</code> and <code>PUT</code> realistic with <code>req.body</code>.</p>
<hr />
<h3 id="requirements-2"><a class="header" href="#requirements-2"><strong>Requirements</strong></a></h3>
<ol>
<li><strong>Create a <code>Book</code> model</strong> with the following fields:
<ul>
<li><code>title</code> (String, required).</li>
<li><code>author</code> (String, required).</li>
<li><code>year</code> (Number, required).</li>
<li><code>genre</code> (String, required).</li>
</ul>
</li>
<li><strong>Implement the following API routes:</strong>
<ul>
<li><code>GET /api/books</code> → Fetch all books.</li>
<li><code>GET /api/books/:id</code> → Fetch a specific book by ID.</li>
<li><code>POST /api/books</code> → Create a book (<strong>use <code>req.body</code></strong>).</li>
<li><code>PUT /api/books/:id</code> → Update a book (<strong>use <code>req.body</code></strong>).</li>
<li><code>DELETE /api/books/:id</code> → Delete a book.</li>
</ul>
</li>
<li><strong>Ensure that <code>:id</code> routes check if the provided ID is valid</strong> before querying the database.</li>
<li><strong>Use proper HTTP status codes</strong> (<code>400</code>, <code>404</code>, <code>500</code>).</li>
<li><strong>Ensure all responses are in JSON format</strong>.</li>
<li><strong>Test all routes using cURL</strong>.</li>
</ol>
<hr />
<h3 id="documentation-2"><a class="header" href="#documentation-2"><strong>Documentation</strong></a></h3>
<ul>
<li><a href="https://expressjs.com/en/guide/routing.html#route-parameters">Express Route Parameters (<code>req.params</code>)</a></li>
<li><a href="https://mongoosejs.com/docs/models.html">Mongoose Models</a></li>
<li><a href="https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.isValidObjectId">MongoDB ObjectId Validation (<code>mongoose.isValidObjectId</code>)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP Status Codes</a></li>
</ul>
<hr />
<h3 id="how-to-test-your-api-2"><a class="header" href="#how-to-test-your-api-2"><strong>How to Test Your API</strong></a></h3>
<pre><code class="language-bash"># Fetch all books
curl http://localhost:5000/api/books

# Fetch a specific book by ID
curl http://localhost:5000/api/books/65a42b1fcf6a1c3d9b123456

# Create a new book (JSON body)
curl -X POST --json '{"title":"The Hobbit","author":"Tolkien","year":1937,"genre":"Fantasy"}' http://localhost:5000/api/books

# Update a book by ID (JSON body)
curl -X PUT --json '{"title":"The Hobbit Updated","author":"Tolkien","year":1937,"genre":"Fantasy"}' http://localhost:5000/api/books/65a42b1fcf6a1c3d9b123456

# Delete a book by ID
curl -X DELETE http://localhost:5000/api/books/65a42b1fcf6a1c3d9b123456
</code></pre>
<hr />
<h3 id="expected-output-2"><a class="header" href="#expected-output-2"><strong>Expected Output</strong></a></h3>
<h4 id="-creating-a-book-post-apibooks"><a class="header" href="#-creating-a-book-post-apibooks">✅ <strong>Creating a Book (<code>POST /api/books</code>)</strong></a></h4>
<pre><code class="language-json">{
    "message": "Book created successfully",
    "book": {
        "_id": "65a42b1fcf6a1c3d9b999999",
        "title": "The Hobbit",
        "author": "Tolkien",
        "year": 1937,
        "genre": "Fantasy"
    }
}
</code></pre>
<h4 id="-fetching-all-books-get-apibooks"><a class="header" href="#-fetching-all-books-get-apibooks">✅ <strong>Fetching All Books (<code>GET /api/books</code>)</strong></a></h4>
<pre><code class="language-json">{
    "books": [
        {
            "_id": "65a42b1fcf6a1c3d9b123456",
            "title": "The Hobbit",
            "author": "Tolkien",
            "year": 1937,
            "genre": "Fantasy"
        }
    ]
}
</code></pre>
<h4 id="-updating-a-book-put-apibooksid"><a class="header" href="#-updating-a-book-put-apibooksid">✅ <strong>Updating a Book (<code>PUT /api/books/:id</code>)</strong></a></h4>
<pre><code class="language-json">{
    "message": "Book updated successfully",
    "book": {
        "_id": "65a42b1fcf6a1c3d9b123456",
        "title": "The Hobbit Updated",
        "author": "Tolkien",
        "year": 1937,
        "genre": "Fantasy"
    }
}
</code></pre>
<h4 id="-deleting-a-book-delete-apibooksid"><a class="header" href="#-deleting-a-book-delete-apibooksid">✅ <strong>Deleting a Book (<code>DELETE /api/books/:id</code>)</strong></a></h4>
<pre><code class="language-json">{
    "message": "Book deleted successfully"
}
</code></pre>
<hr />
<h2 id="exercise-3b-book-filtering-with-route-parameters"><a class="header" href="#exercise-3b-book-filtering-with-route-parameters"><strong>Exercise 3B: Book Filtering with Route Parameters</strong></a></h2>
<p>Your goal is to implement <strong>route-based filtering and searching</strong> for books, using <strong><code>req.params</code></strong> to dynamically extract search criteria.</p>
<hr />
<h3 id="requirements-3"><a class="header" href="#requirements-3"><strong>Requirements</strong></a></h3>
<ol>
<li><strong>Modify the Book API to support filtering and searching via route parameters:</strong>
<ul>
<li><code>GET /api/books/author/:author</code> → Fetch books by author.</li>
<li><code>GET /api/books/year/:year</code> → Fetch books published in a specific year.</li>
<li><code>GET /api/books/genre/:genre</code> → Fetch books by genre.</li>
</ul>
</li>
<li><strong>Return proper JSON responses.</strong></li>
<li><strong>Use <code>mongoose</code> queries to filter books in the database.</strong></li>
<li><strong>Test all routes using cURL.</strong></li>
</ol>
<hr />
<h3 id="documentation-3"><a class="header" href="#documentation-3"><strong>Documentation</strong></a></h3>
<ul>
<li><a href="https://expressjs.com/en/guide/routing.html#route-parameters">Express Route Parameters (<code>req.params</code>)</a></li>
<li><a href="https://mongoosejs.com/docs/queries.html">Mongoose Queries (<code>.find()</code>)</a></li>
</ul>
<hr />
<h3 id="how-to-test-your-api-3"><a class="header" href="#how-to-test-your-api-3"><strong>How to Test Your API</strong></a></h3>
<pre><code class="language-bash"># Fetch books by author
curl http://localhost:5000/api/books/author/Tolkien

# Fetch books by year
curl http://localhost:5000/api/books/year/1937

# Fetch books by genre
curl http://localhost:5000/api/books/genre/Fantasy
</code></pre>
<hr />
<h3 id="expected-output-3"><a class="header" href="#expected-output-3"><strong>Expected Output</strong></a></h3>
<h4 id="-fetching-books-by-author-get-apibooksauthorauthor"><a class="header" href="#-fetching-books-by-author-get-apibooksauthorauthor">✅ <strong>Fetching Books by Author (<code>GET /api/books/author/:author</code>)</strong></a></h4>
<pre><code class="language-json">{
    "books": [
        {
            "_id": "65a42b1fcf6a1c3d9b123456",
            "title": "The Hobbit",
            "author": "Tolkien",
            "year": 1937,
            "genre": "Fantasy"
        }
    ]
}
</code></pre>
<h4 id="-fetching-books-by-year-get-apibooksyearyear"><a class="header" href="#-fetching-books-by-year-get-apibooksyearyear">✅ <strong>Fetching Books by Year (<code>GET /api/books/year/:year</code>)</strong></a></h4>
<pre><code class="language-json">{
    "books": [
        {
            "_id": "65a42b1fcf6a1c3d9b654321",
            "title": "Another Book",
            "author": "Another Author",
            "year": 1937,
            "genre": "Adventure"
        }
    ]
}
</code></pre>
<h4 id="-fetching-books-by-genre-get-apibooksgenregenre"><a class="header" href="#-fetching-books-by-genre-get-apibooksgenregenre">✅ <strong>Fetching Books by Genre (<code>GET /api/books/genre/:genre</code>)</strong></a></h4>
<pre><code class="language-json">{
    "books": [
        {
            "_id": "65a42b1fcf6a1c3d9b123456",
            "title": "The Hobbit",
            "author": "Tolkien",
            "year": 1937,
            "genre": "Fantasy"
        },
        {
            "_id": "65a42b1fcf6a1c3d9b789012",
            "title": "Another Fantasy Book",
            "author": "Some Author",
            "year": 2000,
            "genre": "Fantasy"
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="final-project-e-commerce-api"><a class="header" href="#final-project-e-commerce-api"><strong>Final Project: E-commerce API</strong></a></h3>
<h4 id="team-size-2-3-people"><a class="header" href="#team-size-2-3-people"><strong>Team Size: 2-3 People</strong></a></h4>
<p>Objective: Build a <strong>RESTful E-commerce API</strong> that allows users to manage <strong>products, customers, and orders</strong>.</p>
<hr />
<h2 id="1-requirements--deliverables"><a class="header" href="#1-requirements--deliverables"><strong>1. Requirements &amp; Deliverables</strong></a></h2>
<h3 id="deliverables"><a class="header" href="#deliverables"><strong>Deliverables</strong></a></h3>
<ul>
<li>A <strong>GitHub or GitLab repository</strong> containing the full project at the root (not inside subfolders).</li>
<li>A <strong>README.md file</strong> describing:
<ul>
<li>API Routes with descriptions.</li>
<li>A list of commands to run the project in Docker.</li>
</ul>
</li>
<li>A <strong><code>run.sh</code> script</strong> to automate the setup process.</li>
<li>A <strong><code>test.sh</code> script</strong> to test all the api routes (the user management workflow)</li>
<li>A <strong>structured project</strong> using <code>models/</code>, <code>routes/</code>, and <code>controllers/</code>.</li>
</ul>
<hr />
<h2 id="2-api-endpoints-proper-restful-methods"><a class="header" href="#2-api-endpoints-proper-restful-methods"><strong>2. API Endpoints (Proper RESTful Methods)</strong></a></h2>
<h3 id="product-management"><a class="header" href="#product-management"><strong>Product Management</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Method</th><th>Endpoint</th><th>Description</th></tr></thead><tbody>
<tr><td>Create Product</td><td><code>POST</code></td><td><code>/api/products</code></td><td>Add a new product</td></tr>
<tr><td>Get All Products</td><td><code>GET</code></td><td><code>/api/products</code></td><td>Retrieve all products</td></tr>
<tr><td>Get Product by ID</td><td><code>GET</code></td><td><code>/api/products/:id</code></td><td>Retrieve a single product</td></tr>
<tr><td>Update Product</td><td><code>PUT</code></td><td><code>/api/products/:id</code></td><td>Modify an existing product</td></tr>
<tr><td>Delete Product</td><td><code>DELETE</code></td><td><code>/api/products/:id</code></td><td>Remove a product</td></tr>
</tbody></table>
</div>
<h3 id="customer-management"><a class="header" href="#customer-management"><strong>Customer Management</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Method</th><th>Endpoint</th><th>Description</th></tr></thead><tbody>
<tr><td>Create Customer</td><td><code>POST</code></td><td><code>/api/customers</code></td><td>Add a new customer</td></tr>
<tr><td>Get Customers</td><td><code>GET</code></td><td><code>/api/customers</code></td><td>Retrieve customers</td></tr>
</tbody></table>
</div>
<h3 id="order-management"><a class="header" href="#order-management"><strong>Order Management</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Method</th><th>Endpoint</th><th>Description</th></tr></thead><tbody>
<tr><td>Create Order</td><td><code>POST</code></td><td><code>/api/orders</code></td><td>Place a new order</td></tr>
<tr><td>Get Order by ID</td><td><code>GET</code></td><td><code>/api/orders/:id</code></td><td>Retrieve order details</td></tr>
<tr><td>Update Order</td><td><code>PUT</code></td><td><code>/api/orders/:id</code></td><td>Modify an existing order</td></tr>
<tr><td>Delete Order</td><td><code>DELETE</code></td><td><code>/api/orders/:id</code></td><td>Remove an order</td></tr>
</tbody></table>
</div>
<h3 id="direct-order"><a class="header" href="#direct-order"><strong>Direct Order</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Method</th><th>Endpoint</th><th>Description</th></tr></thead><tbody>
<tr><td>Place Order for Customer</td><td><code>POST</code></td><td><code>/api/orders/direct/:customerId</code></td><td>Create an order for an existing customer</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="3-direct-order-implementation"><a class="header" href="#3-direct-order-implementation"><strong>3. Direct Order Implementation</strong></a></h2>
<p>The <strong>Direct Order</strong> route allows an existing customer to place an order with selected products.</p>
<h3 id="example-request"><a class="header" href="#example-request"><strong>Example Request</strong></a></h3>
<pre><code class="language-bash">curl -X POST --json '{
    "products": ["65a42b1fcf6a1c3d9b654321"]
}' http://localhost:5000/api/orders/direct/65a42b1fcf6a1c3d9b123456
</code></pre>
<h3 id="expected-response"><a class="header" href="#expected-response"><strong>Expected Response</strong></a></h3>
<pre><code class="language-json">{
    "message": "Order created successfully",
    "order": {
        "_id": "65a42b1fcf6a1c3d9b999999",
        "customer": "65a42b1fcf6a1c3d9b123456",
        "products": ["65a42b1fcf6a1c3d9b654321"]
    }
}
</code></pre>
<p>This route <strong>requires the customer to exist</strong>. If the customer ID is invalid or not found, return a <code>404 Not Found</code> error.</p>
<hr />
<h2 id="4-project-setup--docker-requirements"><a class="header" href="#4-project-setup--docker-requirements"><strong>4. Project Setup &amp; Docker Requirements</strong></a></h2>
<p>Students will use a <strong><code>run.sh</code> script</strong> instead of <code>docker-compose</code>.</p>
<h3 id="runsh-requirements"><a class="header" href="#runsh-requirements"><strong><code>run.sh</code> Requirements</strong></a></h3>
<ol>
<li><strong>Creates a Docker network</strong> called <code>backend-test-network</code>.</li>
<li><strong>Creates a MongoDB container</strong>:
<pre><code class="language-bash">docker network create backend-test-network
docker run -d --name db-container --network backend-test-network --network-alias db-container mongo
</code></pre>
</li>
<li><strong>Builds and runs the Express API</strong>:
<pre><code class="language-bash">docker build -t express-project .
docker run -d --name express-app --network backend-test-network express-project
</code></pre>
</li>
</ol>
<p>The Express project <strong>must be structured correctly</strong>:</p>
<pre><code>/models
/routes
/controllers
server.js
package.json
package-lock.json
Dockerfile
run.sh
README.md
</code></pre>
<p>The server should run on the port <code>5000</code> and the should be forwarded from
host's port <code>5201</code> to the docker container's port <code>5000</code></p>
<hr />
<h2 id="5-prerequisites-checklist"><a class="header" href="#5-prerequisites-checklist"><strong>5. Prerequisites Checklist</strong></a></h2>
<ul>
<li><strong>GitHub/GitLab repository</strong> (not inside a subfolder).</li>
<li><strong>README.md that includes</strong>:
<ul>
<li>API routes.</li>
<li>Commands to run containers.</li>
</ul>
</li>
<li><strong>A <code>run.sh</code> script</strong> to launch MongoDB + Express API.</li>
<li><strong>A <code>test.sh</code> script</strong> that tests all the API routes</li>
<li><strong>Project follows MVC structure</strong> (<code>models/</code>, <code>routes/</code>, <code>controllers/</code>).</li>
<li><strong>All responses should be JSON-formatted</strong>.</li>
<li><strong>Correct HTTP status codes (<code>201</code>, <code>400</code>, <code>404</code>, <code>500</code>)</strong>.</li>
</ul>
<hr />
<h2 id="6-bonus-challenges-optional"><a class="header" href="#6-bonus-challenges-optional"><strong>6. Bonus Challenges (Optional)</strong></a></h2>
<p>For students who finish early:</p>
<ol>
<li><strong>Implement search functionality for products</strong>.</li>
<li><strong>Implement pagination for <code>GET /api/products</code></strong>.</li>
<li><strong>Improve error handling</strong> (invalid IDs, missing fields, stock validation).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-frontend-application"><a class="header" href="#react-frontend-application">React Frontend Application</a></h1>
<p>How to create a basic react application</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>Let's use <a href="https://vite.dev/"><code>vite</code></a> tooling framework to setup our react application.</p>
<p>We are going to run the following command:</p>
<pre><code class="language-bash">npm create vite@latest
</code></pre>
<blockquote>
<p>:bulb: Make sure that npm is installed on your machine.</p>
<p>If you want, you can also use the <a href="react/./Dockerfile"><code>Dockerfile</code></a> provided with the project
to build a custom development image.</p>
<p>Build with :</p>
<pre><code class="language-bash">docker build -t node-dev .
</code></pre>
<p>and run with :</p>
<pre><code class="language-bash">docker run -it --name dev-container -p 5173:5173 --mount type=bind,src="${PWD}",target=/app node-dev
</code></pre>
</blockquote>
<p>You can now name the project <code>react-app</code>, select <code>React</code> and then <code>Typescript</code>.</p>
<p>Once the project is initialized, follow along and run :</p>
<pre><code class="language-bash">cd react-app
npm install
npm run dev
</code></pre>
<p><code>npm install</code> will basically install all the dependencies and <code>npm run dev</code> will run the
<code>dev</code> script in <code>package.json</code> (which will start the vite server)</p>
<p>You can now run <code>curl localhost:5173</code> or visit <code>localhost:5173</code> in your browser to ensure
that everything is working.</p>
<blockquote>
<p>:bulb: If you started vite into a container, you might notice that the <code>cURL</code> request
doesn't work. This is because you need to provide <a href="https://vite.dev/config/server-options"><code>--host</code></a>
to vite in order to expose your server to your network (and not only to localhost).
to fix this, add the <code>--host</code> option to your <code>dev</code> script in <code>package.json</code>.</p>
</blockquote>
<h2 id="our-first-component"><a class="header" href="#our-first-component">Our first component</a></h2>
<p>For now, there is only one component, the <code>App</code> component. Now let's create another
component called <code>Message</code>. Let's create a file <code>Message.tsx</code> under the <code>src</code> directory</p>
<blockquote>
<p>:bulb: a typescript file can have the extension <code>.ts</code> or <code>.tsx</code>. We often use the
<code>.ts</code> extension for plain typescript and the <code>.tsx</code> extension for typescript with
React</p>
</blockquote>
<p>For this course, we are going to use
<a href="https://react.dev/learn/your-first-component#defining-a-component">function based components</a>.
However, for old codebases you could encounter
<a href="https://react.dev/reference/react/Component">class based components</a>.</p>
<p>Let's declare a <code>Message</code> function.</p>
<blockquote>
<p>:bulb: pay attention to name your components following the
<a href="https://pascal-case.com/#definition">PascalCasing</a> convention
as this is the convention that everyone expects in a React
project.</p>
</blockquote>
<p>The goal of this function is to describe what our UI should look
like. So for example if we want to use this function to render
a <code>h1</code> element with the value <code>hello-world</code>, we can simply
enter:</p>
<pre><code class="language-jsx">function Message() {
    return &lt;h1&gt; Hello World &lt;/h1&gt;;
}

export default Message;
</code></pre>
<blockquote>
<p>:bulb: Even though it looks like we're writting <code>HTML</code> in the
middle of <code>JS</code>, the syntax is actually a syntax called
<a href="https://legacy.reactjs.org/docs/introducing-jsx.html"><code>JSX</code></a></p>
<p>You can also view the official <a href="https://facebook.github.io/jsx/">facebook paper</a>
about the ins and outs of <code>JSX</code></p>
<p>What you have to remember though, is that under the hood, your
<code>JSX</code> code will be converted to plain <code>JS</code></p>
</blockquote>
<p>Let's now export the <code>Message</code> component as the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export#description">default</a></p>
<blockquote>
<p>:bulb: to view the information about the default export"
you have to scroll a bit and look after the "named exports".</p>
</blockquote>
<p>Let's delete all the contents of <code>App.tsx</code> and write the following
code instead:</p>
<pre><code class="language-js">import Message from "./Message";

function App() {
    return (&lt;div&gt;
            &lt;Message&gt;
            &lt;/Message&gt;
        &lt;/div&gt;);
}

export default App;
</code></pre>
<p>We can now restart our server and visit <code>http://localhost:5173</code>
to see that our "Hello World" is rendered in the browser.</p>
<blockquote>
<p>:bulb: One of the main advantages of <code>JSX</code> is that it allows the
use of javascript within our components. So we can add
contionals and looping constructs to precisely manage the state
of our components</p>
</blockquote>
<h2 id="creating-a-listgroup-component"><a class="header" href="#creating-a-listgroup-component">Creating a ListGroup Component</a></h2>
<h3 id="installing-bootstrap"><a class="header" href="#installing-bootstrap">Installing Bootstrap</a></h3>
<p>Let's go ahead and install <code>boostrap</code> within our application so
either in your terminal (or in the <code>Docker</code> container running
your application) you can run the command :</p>
<pre><code class="language-bash">npm install bootstrap
</code></pre>
<p>Let's now actually use bootstrap in one of our <code>css</code> files. To do
so, we'll start by deleting all the contents of <code>App.css</code> (as
this was the content for the default app that doesn't exist
anymore)</p>
<p>We can also delete the <code>index.css</code> file entirely for the same
reason and go to <code>main.tsx</code> and replace :</p>
<pre><code class="language-js">import './index.css'
</code></pre>
<p>with</p>
<pre><code class="language-js">import 'bootstrap/dist/css/bootstrap.css'
</code></pre>
<blockquote>
<p>:information_desk_person: You can find the <code>bootstrap</code>
modules and directory structure
<a href="https://getbootstrap.com/docs/5.3/getting-started/contents/">here</a></p>
</blockquote>
<p>To check that everything worked properly, let's restart our
server, go to the browser and check that the font has indeed
changed and that the "Hello World" moved to the top of the page</p>
<h3 id="creating-the-component"><a class="header" href="#creating-the-component">Creating the component</a></h3>
<p>First let's create a directory called <code>components</code> within our
<code>src</code> directory</p>
<blockquote>
<p>:information_desk_person: It is a convention that all the
components are placed into a directory called <code>components</code>.
You might not want to follow it, however as for the
PascalCase convention, it will make reading your code easier
for other maintainers of your projects</p>
</blockquote>
<p>We can now create <code>components/ListGroup.tsx</code> and just make it
return a <code>h1</code> element that prints <code>ListGroup</code></p>
<details>
<summary>The <code>ListGroup.tsx</code> file</summary>
<pre><code class="language-js">function ListGroup() {
    return(&lt;h1&gt;ListGroup&lt;/h1&gt;);
}

export default ListGroup;
</code></pre>
</details>
<p>Let's now import it in our <code>App.tsx</code> file (we don't need the
<code>Message</code> component anymore so we can just delete any mention of
it in the <code>App.tsx</code> file)</p>
<details>
<summary> The updated <code>App.tsx</code> file</summary>
<pre><code class="language-js">import ListGroup from "./components/ListGroup.tsx";

function App() {
    return (&lt;div&gt;
            &lt;ListGroup&gt;
            &lt;/ListGroup&gt;
        &lt;/div&gt;);
}

export default App;
</code></pre>
</details>
<blockquote>
<p>:bulb: As usual you can restart the server and go to the browser
to check that everything is working</p>
</blockquote>
<h3 id="using-the-code-from-bootstrap"><a class="header" href="#using-the-code-from-bootstrap">Using the code from <code>bootstrap</code></a></h3>
<p>To do so, we have to head over to the
<a href="https://getbootstrap.com/docs/5.3/components/list-group/#basic-example">ListGroup</a>
page in the bootstrap documentation.</p>
<p>Now we have all the information we need to create our component.
Let's copy the code and head back to our component.</p>
<p>We can now replace the <code>h1</code> element with:</p>
<pre><code class="language-html">&lt;ul class="list-group"&gt;
  &lt;li class="list-group-item"&gt;An item&lt;/li&gt;
  &lt;li class="list-group-item"&gt;A second item&lt;/li&gt;
  &lt;li class="list-group-item"&gt;A third item&lt;/li&gt;
  &lt;li class="list-group-item"&gt;A fourth item&lt;/li&gt;
  &lt;li class="list-group-item"&gt;And a fifth one&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>As you can see if you're using any syntactical highlighting tool,
you get a bunch of errors because <code>class</code> is a reserved keyword in
react. To remove them, you should use the <code>className</code> property.</p>
<blockquote>
<p>:warning: Make sure to enclose your <code>JSX</code> into parenthesis so
you can spread it over multiple lines</p>
</blockquote>
<p>After eventually reloading the server, you should now see our
<code>ListGroup</code> component.</p>
<h3 id="returning-a-fragment"><a class="header" href="#returning-a-fragment">Returning a <a href="https://react.dev/reference/react/Fragment"><code>Fragment</code></a></a></h3>
<p>In React, a component can't return more than one element, so if
we'd like to add a heading to our <code>ListGroup</code>, we can use a
<code>Fragment</code> either with <code>&lt;Fragment&gt;..&lt;/Fragment&gt;</code> (thus importing
the <code>Fragment</code> Component from the <code>react</code> module) or just by
enclosing our elements in <code>&lt;&gt;..&lt;/&gt;</code>.</p>
<p>Let's do this and add a title to our <code>ListGroup</code> component.</p>
<h3 id="making-our-list-more-dynamic"><a class="header" href="#making-our-list-more-dynamic">Making our list more dynamic</a></h3>
<p>In React, we don't have any looping construct, so we can't write
a <code>for</code> loop to iterate over an array of items.</p>
<p>Instead, we're going to use a <code>js</code> function called <code>map</code> to
transform our items into other items.</p>
<p>Let's then map each item to a
<code>&lt;li className="list-group-item"&gt;{item}&lt;/li&gt;</code> and add a <code>key</code>
property to the <code>item</code>.</p>
<blockquote>
<p>:information_desk_person: In react, each item needs to have
unique a <code>key</code> property so that react can keep track of each
item and properly update the DOM</p>
</blockquote>
<p>In this example, we'll use the item value as our <code>key</code> property.</p>
<p>Your final listgroup should look something like this one:</p>
<pre><code class="language-js">function ListGroup() {
    const items = [
        "Luanda",
        "Yamoussoukro",
        "Abidjan",
        "Dakar",
        "Brazzaville"
    ];

    return (
        &lt;&gt;
            &lt;h1&gt;ListGroup&lt;/h1&gt;
            &lt;ul className="list-group"&gt;
                {items.map((item) =&gt; (
                    &lt;li className="list-group-item"
                        key={item}
                    &gt;{item}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/&gt;
        );
}

export default ListGroup;
</code></pre>
<h3 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h3>
<p>Sometimes, we'd like to change the content based on the value of
some of our variables. To do so, we can use <code>if</code> conditions in
React.</p>
<p>For example, let's say that we want to warn the user that there
is not item in the list if the <code>items</code> array is empty. to do so,
we could replace the beginning of our function with the
following code:</p>
<pre><code class="language-js">let items = [
    "Luanda",
    "Yamoussoukro",
    "Abidjan",
    "Dakar",
    "Brazzaville"
];
items = [];
</code></pre>
<p>As you can see, the items variable is not const anymore. We can
then use a ternary operator to render a message conditionnally:</p>
<p>The addition would look like the following (with the lines above
and under added for context):</p>
<pre><code class="language-jsx">&lt;h1&gt;ListGroup&lt;/h1&gt;
{ items.length === 0 ? &lt;p&gt;No Items Found&lt;/p&gt; : null }
&lt;ul className="list-group"&gt;
</code></pre>
<p>However, it is not very clean to have the code in the middle of
the rendering. So two possibilities:</p>
<ol>
<li>Turning it into a constant :</li>
</ol>
<pre><code class="language-js">const message = items.length === 0 ? &lt;p&gt;No Items Found&lt;/p&gt; : null
</code></pre>
<p>And then rendering <code>message</code> with <code>{message}</code></p>
<ol start="2">
<li>Turning it into a function :</li>
</ol>
<pre><code class="language-js">const getMessage = () =&gt; {
    return items.length === 0 ? &lt;p&gt;No Items Found&lt;/p&gt; : null;
}
</code></pre>
<p>And then rendering it with <code>{getMessage()}</code></p>
<blockquote>
<p>:information_desk_person: A good rule of thumb is: if you need
parameters, use a function. Otherwise use a variable.</p>
</blockquote>
<blockquote>
<p>:bulb: Instead of using a ternary opeator, we could also
perform a logical <code>&amp;&amp;</code> between our variable and the value we
want to return</p>
</blockquote>
<h2 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h2>
<p>In React, each item has an
<a href="https://react.dev/learn/responding-to-events"><code>onClick</code></a>
property that let's you listen to the <code>click</code> <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/Events">event</a></p>
<p>Let's now handle the click event in our ListGroup Component.</p>
<p>For now, let's just add an <code>onClick</code> property with the following :</p>
<pre><code class="language-js">onClick={() =&gt; console.log("Clicked")}
</code></pre>
<p>You should see in the browser that it works as expected.</p>
<p>In our <code>map</code> function, we can also add an <code>index</code> parameter when
we map the items so we can see the index of the item that was
<code>map</code>ed.</p>
<p>If we change our code, it should look like this :</p>
<pre><code class="language-js">{items.map((item, index) =&gt; (
&lt;li className="list-group-item"
    key={item}
    onClick={() =&gt; console.log(item, index)}
&gt;
</code></pre>
<p>With the other lines unmodified.</p>
<p>We can now see in the browser that we can view the index of the
item that was clicked</p>
<blockquote>
<p>:bulb: We can also give the event as a parameter to see some
useful information about the event that was passed as an
argument.</p>
</blockquote>
<h2 id="managing-state"><a class="header" href="#managing-state">Managing State</a></h2>
<p>If we want to manage state with a variable that is local to our
function, react won't be aware of what we're doing.
To effectively manage state, we have to tell react that we are
using a variable that it should manage.</p>
<p>So let's do this and use the
<a href="https://react.dev/reference/react/useState">useState</a> react hook</p>
<p>let's add the following code to our component.</p>
<pre><code class="language-js">const [selectedIndex, setSelectedIndex] = useState(-1);
</code></pre>
<blockquote>
<p>:warning: The following code won't work if you don't import
the <code>useState</code> hook from the <code>react</code> module</p>
</blockquote>
<p>We can now modifying our code as follows:</p>
<pre><code class="language-jsx">{items.map((item, index) =&gt; (
&lt;li className={
    selectedIndex === index
    ? "list-group-item active"
    : "list-group-item"
}
    key={item}
    onClick={() =&gt; setSelectedIndex(index)}
&gt;
</code></pre>
<p>With the other lines unchanged. You should now see in the browser
that if we click on the elements, it should select the items
dynamically.</p>
<h2 id="passing-properties-via-props"><a class="header" href="#passing-properties-via-props">Passing Properties via <a href="https://react.dev/learn/passing-props-to-a-component">props</a></a></h2>
<p>Let's say we now want to change the cities displayed or change the
heading of our list. To do so, we'll need to pass them via
<a href="https://react.dev/learn/passing-props-to-a-component">props</a></p>
<h3 id="interface-declaration"><a class="header" href="#interface-declaration">Interface Declaration</a></h3>
<p>let's add the following code to our <code>components/ListGroup.tsx</code>:</p>
<pre><code class="language-js">interface Props {
    items: string[];
    heading: string;
}
</code></pre>
<p>It declares an <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html">interface</a>
which shapes what our <code>Props</code> item should look like</p>
<h3 id="passing-props-to-our-componen"><a class="header" href="#passing-props-to-our-componen">Passing props to our componen</a></h3>
<p>We can now move our list of items to the <code>App</code> component and
use it within our <code>ListGroup</code> component by providing it as a
<code>prop</code>.</p>
<details>
<summary>Overview of the <code>App</code> component</summary>
<pre><code class="language-jsx">function App() {
    let items = [
        "Luanda",
        "Yamoussoukro",
        "Abidjan",
        "Dakar",
        "Brazzaville"
    ];

    return (&lt;div&gt;
            &lt;ListGroup items={items} heading="Cities"&gt;
            &lt;/ListGroup&gt;
        &lt;/div&gt;);
}
</code></pre>
</details>
<p>We can now use our prop object in our <code>ListGroup</code> component by
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"><code>destructuring</code></a>
our <code>Props</code> object.</p>
<p>Here what the beginning of our <code>ListGroup</code> component should look
like now:</p>
<pre><code class="language-tsx">function ListGroup(props: Props) {
    let { items, heading } = props;
</code></pre>
<h2 id="passing-functions-via-props"><a class="header" href="#passing-functions-via-props">Passing functions via props</a></h2>
<p>Let's now say we'd like to do an action once an item is selected,
rather than hardcoding this action into our component (which would
prevent it from being reusable), we can also pass functions via
<code>props</code>.</p>
<p>To do so, we need to implement a mechanism to notify the
<code>consumer</code>/<code>parent</code> of our component that an item is selected</p>
<p>To do so, let's declare a new element in our <code>Props</code> interface.</p>
<pre><code class="language-ts">onSelectItem: (item: string) =&gt; void;
</code></pre>
<p>This will be a function we'll define in the <code>parent</code> and use in
our component when an item is selected</p>
<p>We can now go in the <code>App</code> component and declare our event handler.</p>
<pre><code class="language-ts">const handleSelectItem = (item: string) =&gt; {
    console.log(item);
};
</code></pre>
<blockquote>
<p>:warning: Make sure to put the function inside the <code>App()</code>
declaration</p>
</blockquote>
<p>We can now pass it as a <code>prop</code> of our <code>ListGroup</code> component:</p>
<pre><code class="language-tsx">return (&lt;div&gt;
        &lt;ListGroup items={items} 
        heading="Cities"
        onSelectItem={handleSelectItem}&gt;
        &lt;/ListGroup&gt;
    &lt;/div&gt;);
</code></pre>
<p>We also need to retrieve it from our <code>prop</code> object in the
<code>ListGroup</code> component:</p>
<pre><code class="language-tsx">let { onSelectItem } = props;
</code></pre>
<blockquote>
<p>:alert: I just realize that I forgot to write the props as
constant but never try to
<a href="https://react.dev/learn/passing-props-to-a-component#how-props-change-over-time">modify props</a></p>
</blockquote>
<p>We can now call the selected function within our <code>onClick</code> event handler:</p>
<pre><code class="language-tsx">onClick={() =&gt; {
    setSelectedIndex(index);
    onSelectItem(item);
}}
</code></pre>
<p>With all those additions it should now log the clicked item in the console
(and also log that the log comes from the <code>App</code> component)</p>
<h2 id="passing-children-to-our-components"><a class="header" href="#passing-children-to-our-components">Passing Children to our Components</a></h2>
<p>Let's now create an <code>Alert</code> component</p>
<pre><code class="language-tsx">function Alert() {
    return &lt;div&gt;Alert&lt;/div&gt;;
}

export default Alert;
</code></pre>
<p>and use it in our <code>App</code> component:</p>
<pre><code class="language-tsx">import Alert from "./components/Alert.tsx";

function App() {
        return (&lt;div&gt;
            &lt;Alert/&gt;
        &lt;/div&gt;);
}

export default App;
</code></pre>
<p>To style our component, we'll borrow some code
from the Boostrap <a href="https://getbootstrap.com/docs/5.0/components/alerts/"><code>Alert</code></a>
page</p>
<p>let's give the classes <code>alert alert-primary</code> to our <code>Alert</code> component.
We can now do the same as before and use props to pass the <code>Alert</code> text
dynamically.</p>
<details>
<summary> The <code>Alert.tsx</code> file</summary>
<pre><code class="language-tsx">interface Props{
    text: string
};

function Alert(props: Props) {
    const { text } = props;
    return &lt;div className="alert alert-primary"&gt;{text}&lt;/div&gt;;
}

export default Alert;
</code></pre>
</details>
<p>We can now use the <code>Alert</code> component, same as before, as:</p>
<pre><code class="language-tsx">&lt;Alert text="Bonjour"/&gt;
</code></pre>
<p>However, if we'd like to pass text in a more natural way,
like with:</p>
<pre><code class="language-tsx">&lt;Alert&gt;
    Bonjour
&lt;/Alert&gt;
</code></pre>
<p>We need to use the <a href="https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children">children</a>
<code>prop</code></p>
<p>Let's modify this in our <code>Alert</code> component. Now the code we've written in the
<code>App</code> component works.</p>
<blockquote>
<p>The modification consist in replacing all the references to the <code>text</code> variable
with a reference to the <code>children</code> variable instead.</p>
</blockquote>
<p>However, if we replace <code>Bonjour</code> with <code>&lt;span&gt;Bonjour&lt;/span&gt;</code> in <code>App.tsx</code>, the
code raises a typescript compilation error. To fix it, we need to import
<a href="https://react.dev/learn/typescript#typing-children"><code>ReactNode</code></a>
from the 'react' module and declare <code>children</code> of type <code>ReactNode</code> in our
<code>interface</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
