<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CI-CD</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Day 1</li><li class="chapter-item expanded "><a href="day_1/Github-actions-guided.html"><strong aria-hidden="true">1.</strong> Github Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day_1/Github-actions-non-guided.html"><strong aria-hidden="true">1.1.</strong> non guided</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Day 2</li><li class="chapter-item expanded "><a href="day_2/tests_java.html"><strong aria-hidden="true">2.</strong> Tests Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day_2/tests_java_non_guide.html"><strong aria-hidden="true">2.1.</strong> non guided</a></li></ol></li><li class="chapter-item expanded "><a href="day_2/tutoriels_docker.html"><strong aria-hidden="true">3.</strong> Tutoriels Docker</a></li><li class="chapter-item expanded affix "><li class="part-title">Day 3</li><li class="chapter-item expanded "><a href="day_3/dockerize_java_app.html"><strong aria-hidden="true">4.</strong> Dockerisation Application Java</a></li><li class="chapter-item expanded "><a href="day_3/tutoriel_github_actions.html"><strong aria-hidden="true">5.</strong> Tutoriel Github Actions</a></li><li class="chapter-item expanded "><a href="day_3/publish_java_docker_image.html"><strong aria-hidden="true">6.</strong> Publication Image Java</a></li><li class="chapter-item expanded "><a href="day_3/documentation_guided.html"><strong aria-hidden="true">7.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="day_3/auto_documentation.html"><strong aria-hidden="true">8.</strong> Documentation Automatique</a></li><li class="chapter-item expanded affix "><li class="part-title">Examen</li><li class="chapter-item expanded "><a href="examen.html"><strong aria-hidden="true">9.</strong> Examen</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CI-CD</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="exercices-github-actions"><a class="header" href="#exercices-github-actions">Exercices GitHub Actions</a></h1>
<h2 id="niveau-1--débutant"><a class="header" href="#niveau-1--débutant">Niveau 1 : Débutant</a></h2>
<h3 id="exercice-1--créer-un-dépôt-et-configurer-github-actions"><a class="header" href="#exercice-1--créer-un-dépôt-et-configurer-github-actions">Exercice 1 : Créer un dépôt et configurer GitHub Actions</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer un dépôt GitHub et configurer GitHub Actions.</p>
<ol>
<li>Créez un dépôt sur GitHub.</li>
<li>Clonez le dépôt localement.</li>
<li>Dans le dépôt, créez un répertoire <code>.github/workflows</code>.</li>
<li>Dans ce répertoire, créez un fichier <code>main.yml</code> (ou <code>ci.yml</code>).</li>
</ol>
<p><strong>Intérêt :</strong>
Configurer GitHub Actions dès le début vous permet d'automatiser les tâches dès que vous commencez à travailler sur votre projet. Cela vous aide à garantir que les tests sont exécutés, que le code est construit correctement, et éventuellement déployé automatiquement.</p>
<p><strong>Application réelle :</strong>
Vous pouvez automatiser des tâches courantes telles que l'exécution de tests, le linting du code, ou même le déploiement de votre application après chaque commit ou merge dans la branche principale.</p>
<h3 id="exercice-2--créer-une-action-simple"><a class="header" href="#exercice-2--créer-une-action-simple">Exercice 2 : Créer une action simple</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub simple qui s'exécute sur chaque push.</p>
<ol>
<li>
<p>Ajoutez le contenu suivant dans le fichier <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: CI Simple

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Run a one-line script
      run: echo "Hello, world depuis GitHub Actions !"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement dans l'onglet "Actions" de votre dépôt.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Comprendre comment déclencher une action simple vous donne les bases pour automatiser des processus plus complexes. Savoir utiliser les actions de base est essentiel pour la CI/CD.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser cette connaissance pour automatiser des tâches simples, comme envoyer un message de notification à une équipe via Slack chaque fois qu'un push est effectué.</p>
<h3 id="exercice-3--exécuter-un-script-multi-lignes"><a class="header" href="#exercice-3--exécuter-un-script-multi-lignes">Exercice 3 : Exécuter un script multi-lignes</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter un script multi-lignes dans une action GitHub.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour inclure un script multi-lignes :</p>
<pre><code class="language-yaml">name: CI Multi-lignes

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Run a multi-line script
      run: |
        echo "Ceci est la première ligne du script."
        echo "Et voici une deuxième ligne pour montrer que ça marche."
        echo "On peut ajouter autant de commandes qu'on veut ici."
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les scripts multi-lignes vous permettent d'effectuer des tâches plus complexes et plus longues dans vos workflows GitHub Actions.</p>
<p><strong>Application réelle :</strong>
Automatiser l'installation d'un environnement de développement, exécuter des tests, et générer des rapports de test peuvent être réalisés en utilisant des scripts multi-lignes.</p>
<h3 id="exercice-4--utiliser-des-actions-de-la-marketplace"><a class="header" href="#exercice-4--utiliser-des-actions-de-la-marketplace">Exercice 4 : Utiliser des actions de la marketplace</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser une action de la GitHub Marketplace.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser l'action <code>actions/setup-node</code> de la marketplace :</p>
<pre><code class="language-yaml">name: CI avec Setup Node

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20' # Utilisation d'une version LTS spécifique

    - name: Vérifier la version de Node.js
      run: node -v
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement et affiche la version de Node.js.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
La GitHub Marketplace offre de nombreuses actions créées par la communauté, ce qui vous permet de ne pas réinventer la roue et de bénéficier de fonctionnalités déjà prêtes à l'emploi.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser des actions pour configurer automatiquement Node.js (comme ici), Python, Java, déployer des applications sur AWS, ou envoyer des notifications Slack, sans avoir à écrire le code de ces actions vous-même.</p>
<h3 id="exercice-5--ajouter-des-secrets"><a class="header" href="#exercice-5--ajouter-des-secrets">Exercice 5 : Ajouter des secrets</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des secrets dans GitHub Actions.</p>
<ol>
<li>
<p>Dans les paramètres de votre dépôt GitHub (<code>Settings &gt; Secrets and variables &gt; Actions</code>), ajoutez un nouveau "repository secret" nommé <code>MY_SUPER_SECRET</code> avec une valeur bidon (ex: <code>CestTresSecret</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser le secret :</p>
<pre><code class="language-yaml">name: CI avec Secrets

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Utiliser un secret (de manière sécurisée)
      env:
        MON_SECRET_UTILISE_EN_INTERNE: ${{ secrets.MY_SUPER_SECRET }}
      run: |
        echo "Le script va utiliser le secret mais ne l'affichera PAS directement."
        # Pour la démo, on va juste prouver qu'il est là :
        if [ -n "$MON_SECRET_UTILISE_EN_INTERNE" ]; then
          echo "Le secret est bien passé en variable d'env !"
        else
          echo "Oops, le secret n'est pas là."
          exit 1
        fi
        # ATTENTION : NE JAMAIS FAIRE 'echo ${{ secrets.MY_SUPER_SECRET }}' pour un vrai secret en production.
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute et que le log indique que le secret est bien passé.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les secrets vous permettent de gérer en toute sécurité les informations sensibles comme les tokens d'API, les clés de chiffrement et autres données confidentielles.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser des secrets pour stocker les informations d'identification nécessaires pour déployer une application sur un serveur, vous connecter à un registry Docker, ou pour accéder à une API tierce de manière sécurisée.</p>
<h3 id="exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions"><a class="header" href="#exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions">Exercice 6 : Utiliser des matrices pour tester plusieurs versions</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des matrices pour tester plusieurs versions d'un langage.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser une matrice avec différentes versions de Node.js :</p>
<pre><code class="language-yaml">name: CI avec Matrice Node.js

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: ['18', '20'] # Versions LTS spécifiques

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}

    - name: Afficher la version de Node.js
      run: echo "Test avec Node.js $(node -v) sur ${{ runner.os }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute en parallèle pour chaque version de Node.js spécifiée.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les matrices permettent de tester votre code sur différentes versions d'un langage ou dans différents environnements (OS, etc.), assurant ainsi une compatibilité et une robustesse maximales.</p>
<p><strong>Application réelle :</strong>
Tester une application Node.js sur plusieurs versions de Node.js pour garantir qu'elle fonctionne correctement sur les versions que vos utilisateurs sont susceptibles d'utiliser. Idem pour Python, Java, etc.</p>
<hr />
<h2 id="niveau-2--intermédiaire"><a class="header" href="#niveau-2--intermédiaire">Niveau 2 : Intermédiaire</a></h2>
<h3 id="exercice-7--exécuter-des-tests-unitaires"><a class="header" href="#exercice-7--exécuter-des-tests-unitaires">Exercice 7 : Exécuter des tests unitaires</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter des tests unitaires dans GitHub Actions.</p>
<ol>
<li>
<p>Créez un projet Node.js simple avec un <code>package.json</code> et des tests unitaires (par exemple avec Jest ou Mocha). Assurez-vous d'avoir un script de test dans <code>package.json</code> (ex: <code>"test": "jest"</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour exécuter les tests :</p>
<pre><code class="language-yaml">name: CI avec Tests Unitaires

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Installer les dépendances
      run: npm ci

    - name: Exécuter les tests
      run: npm test
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que les tests s'exécutent correctement.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Automatiser les tests unitaires garantit que chaque modification de code est testée immédiatement, ce qui améliore la qualité du code et réduit les risques d'introduire des bugs.</p>
<p><strong>Application réelle :</strong>
À chaque push, les tests sont automatiquement exécutés, ce qui permet de détecter et de corriger rapidement les régressions.</p>
<h3 id="exercice-8--déployer-sur-github-pages"><a class="header" href="#exercice-8--déployer-sur-github-pages">Exercice 8 : Déployer sur GitHub Pages</a></h3>
<p><strong>Objectif :</strong> Apprendre à déployer un site statique sur GitHub Pages via GitHub Actions.</p>
<ol>
<li>
<p>Créez un site statique simple dans votre dépôt. Si vous utilisez un framework (comme Angular, React, Vue), assurez-vous que la commande <code>npm run build</code> génère les fichiers statiques dans un dossier (souvent <code>dist</code> ou <code>build</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour déployer le site.</p>
<pre><code class="language-yaml">name: Déploiement sur GitHub Pages

on:
  push:
    branches:
      - main # Ou la branche que vous voulez déployer

permissions:
  contents: write # Nécessaire pour que l'action puisse pusher sur la branche gh-pages

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      # Si c'est un projet Node.js qui nécessite un build (ex: Angular, React, Vue)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Installer les dépendances et Builder
        run: |
          npm ci
          npm run build # Assurez-vous que ce script génère dans './build' ou './dist'

      - name: Déployer sur GitHub Pages
        uses: peaceiris/actions-gh-pages@v3 # Action populaire et stable pour ça
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist # Adaptez au dossier de sortie de votre build (ex: ./build, ./public)
</code></pre>
<p><strong>Note importante pour GitHub Pages :</strong> Allez dans les paramètres de votre dépôt (<code>Settings &gt; Pages</code>), et sous "Build and deployment", pour "Source", sélectionnez "GitHub Actions".</p>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que le site est déployé sur GitHub Pages.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Automatiser le déploiement d'un site sur GitHub Pages vous permet de mettre à jour votre site web automatiquement à chaque changement de code.</p>
<p><strong>Application réelle :</strong>
Déployer automatiquement un site de documentation, un portfolio, ou un site web statique chaque fois que du nouveau contenu est ajouté ou modifié dans le dépôt.</p>
<h3 id="exercice-9--utiliser-des-workflows-multi-jobs"><a class="header" href="#exercice-9--utiliser-des-workflows-multi-jobs">Exercice 9 : Utiliser des workflows multi-jobs</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer des workflows multi-jobs qui peuvent dépendre les uns des autres.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour inclure plusieurs jobs :</p>
<pre><code class="language-yaml">name: CI Multi-Jobs

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un build
      run: |
        echo "Compilation du projet..."
        mkdir -p output # Créer le dossier output
        echo "Résultat du build" &gt; output/build_result.txt
    - name: Uploader l'artefact du build
      uses: actions/upload-artifact@v4
      with:
        name: build-output
        path: output/

  test:
    runs-on: ubuntu-latest
    needs: build # Dépend du job 'build'
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Télécharger l'artefact du build
      uses: actions/download-artifact@v4
      with:
        name: build-output
        path: downloaded_build_output
    - name: Simuler des tests
      run: |
        echo "Exécution des tests sur le résultat du build..."
        cat downloaded_build_output/build_result.txt
        echo "Tests terminés !"

  deploy:
    runs-on: ubuntu-latest
    needs: test # Dépend du job 'test'
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un déploiement
      run: echo "Déploiement du projet..."
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez l'exécution séquentielle et conditionnelle des jobs.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les workflows multi-jobs permettent de structurer les tâches en étapes distinctes, exécutées en parallèle ou séquentiellement (avec <code>needs</code>), améliorant ainsi l'efficacité et la clarté des processus CI/CD.</p>
<p><strong>Application réelle :</strong>
Exécuter des tests unitaires, puis des tests d'intégration, et enfin déployer l'application, chaque tâche étant gérée comme un job distinct et dépendant du succès du précédent.</p>
<h3 id="exercice-10--utiliser-des-artefacts"><a class="header" href="#exercice-10--utiliser-des-artefacts">Exercice 10 : Utiliser des artefacts</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des artefacts pour stocker et partager des fichiers entre les jobs. (Cet exercice est très similaire au précédent qui utilise déjà des artefacts).</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> (ou créez-en un nouveau) :</p>
<pre><code class="language-yaml">name: CI avec Artefacts

on: [push]

jobs:
  job1_produire_artefact:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Créer un fichier artefact
      run: echo "Contenu de mon artefact !" &gt; mon_artefact.txt

    - name: Uploader l'artefact
      uses: actions/upload-artifact@v4
      with:
        name: resultat-job1
        path: mon_artefact.txt

  job2_consommer_artefact:
    runs-on: ubuntu-latest
    needs: job1_produire_artefact
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Télécharger l'artefact
      uses: actions/download-artifact@v4
      with:
        name: resultat-job1
        # path: ./destination_optionnelle # par défaut à la racine du workspace

    - name: Utiliser l'artefact
      run: cat mon_artefact.txt
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les artefacts permettent de sauvegarder des fichiers générés pendant l'exécution d'un job pour les utiliser dans des jobs suivants ou pour les télécharger ultérieurement.</p>
<p><strong>Application réelle :</strong>
Générer des rapports de test, des binaires compilés, ou des archives de votre application dans un job et les utiliser pour déploiement ou analyse dans un autre job.</p>
<hr />
<h2 id="niveau-3--avancé"><a class="header" href="#niveau-3--avancé">Niveau 3 : Avancé</a></h2>
<h3 id="exercice-11--créer-une-action-personnalisée"><a class="header" href="#exercice-11--créer-une-action-personnalisée">Exercice 11 : Créer une action personnalisée</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub personnalisée (en JavaScript/Node.js).</p>
<ol>
<li>
<p>Créez un répertoire <code>my-custom-action</code> à la racine de votre dépôt.</p>
</li>
<li>
<p>Dans <code>my-custom-action</code>, créez <code>action.yml</code> :</p>
<pre><code class="language-yaml">name: 'Mon Action Perso'
description: 'Salue une personne et donne l heure.'
inputs:
  qui_saluer:
    description: 'Qui saluer ?'
    required: true
    default: 'Monde'
outputs:
  temps:
    description: 'L heure de la salutation.'
runs:
  using: 'node20' # Utiliser une version Node.js LTS
  main: 'index.js'
</code></pre>
</li>
<li>
<p>Dans <code>my-custom-action</code>, initialisez un projet Node (<code>npm init -y</code>) et installez les dépendances (<code>npm install @actions/core @actions/github</code>). Puis créez <code>index.js</code> :</p>
<pre><code class="language-javascript">// my-custom-action/index.js
const core = require('@actions/core');
// const github = require('@actions/github'); // Pas utilisé dans cet exemple simple

async function run() {
  try {
    const quiASaluer = core.getInput('qui_saluer');
    console.log(`Bonjour, ${quiASaluer} !`);

    const time = (new Date()).toTimeString();
    core.setOutput("temps", time);
  } catch (error) {
    core.setFailed(error.message);
  }
}

run();
</code></pre>
<p><strong>Note :</strong> Pour que cette action soit utilisable dans le workflow, vous devrez commiter <code>my-custom-action/index.js</code>, <code>my-custom-action/action.yml</code>, <code>my-custom-action/package.json</code>, <code>my-custom-action/package-lock.json</code> et le dossier <code>node_modules</code> de l'action, OU mieux, utiliser un bundler comme <code>@vercel/ncc</code> pour packager votre action en un seul fichier JS (plus avancé, mais meilleure pratique). Pour cet exo, le plus simple est de tout commiter ou de faire un <code>npm install</code> dans l'action elle-même (voir ci-dessous).</p>
</li>
<li>
<p>Modifiez votre fichier de workflow principal pour utiliser cette action :</p>
<pre><code class="language-yaml">name: CI avec Action Personnalisée

on: [push]

jobs:
  build_avec_action_perso:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    # Option 1: Si node_modules n'est pas commité avec l'action
    - name: Installer les dépendances de l'action perso
      run: npm install --prefix my-custom-action # Exécute npm install dans le dossier de l'action

    - name: Exécuter mon action personnalisée
      id: salutation
      uses: ./my-custom-action # Chemin vers le dossier de l'action locale
      with:
        qui_saluer: 'les Participants à la Formation'

    - name: Afficher l'output de l'action
      run: echo "L'action a été exécutée à ${{ steps.salutation.outputs.temps }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Créer vos propres actions vous permet de réutiliser du code logique complexe dans plusieurs workflows.</p>
<p><strong>Application réelle :</strong>
Automatiser une tâche spécifique à votre entreprise.</p>
<h3 id="exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes"><a class="header" href="#exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes">Exercice 12 : Utiliser des conditions pour contrôler les étapes</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des expressions conditionnelles (<code>if:</code>) pour contrôler l'exécution.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: CI avec Conditions

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Étape toujours exécutée
      run: echo "Cette étape s'exécute toujours."

    - name: Étape conditionnelle (branche main uniquement)
      if: github.ref == 'refs/heads/main'
      run: echo "Cette étape s'exécute SEULEMENT sur la branche main."

    # Pour les événements de push, on accède au message du dernier commit (head_commit)
    - name: Autre condition (pas si le commit contient '[skip ci]')
      if: "!contains(github.event.head_commit.message, '[skip ci]')"
      run: echo "Cette étape ne s'exécute PAS si le message de commit contient '[skip ci]'."
</code></pre>
</li>
<li>
<p>Poussez les modifications et testez différents scénarios.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les conditions rendent vos workflows plus flexibles.</p>
<p><strong>Application réelle :</strong>
Déployer seulement depuis <code>main</code>, sauter des tests sur des branches de dev.</p>
<h3 id="exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé"><a class="header" href="#exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé">Exercice 13 : Utiliser des secrets pour déploiement sécurisé</a></h3>
<p><strong>Objectif :</strong> Utiliser des secrets GitHub pour des informations sensibles.</p>
<ol>
<li>
<p>Ajoutez des secrets <code>AWS_ACCESS_KEY_ID</code> et <code>AWS_SECRET_ACCESS_KEY</code> dans les paramètres du dépôt.</p>
</li>
<li>
<p>Modifiez <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: Déploiement sur AWS avec Secrets

on:
  push:
    branches: [main]

jobs:
  deploy_to_aws:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Configurer les identifiants AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1 # Changez si besoin

    - name: Simuler un déploiement sur AWS
      run: |
        echo "Tentative de déploiement sur AWS..."
        # Exemple: aws s3 ls # Liste les buckets S3 pour prouver que la config AWS marche
        echo "Déploiement (simulé) terminé."
</code></pre>
</li>
<li>
<p>Poussez les modifications.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Sécuriser les informations sensibles.</p>
<p><strong>Application réelle :</strong>
Stocker clés API, tokens, mots de passe pour des déploiements sur des services cloud.</p>
<h3 id="exercice-14--déclencher-des-workflows-manuellement"><a class="header" href="#exercice-14--déclencher-des-workflows-manuellement">Exercice 14 : Déclencher des workflows manuellement</a></h3>
<p><strong>Objectif :</strong> Apprendre à déclencher des workflows manuellement (<code>workflow_dispatch</code>).</p>
<ol>
<li>
<p>Modifiez <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: Déclenchement Manuel

on:
  workflow_dispatch: # Permet le déclenchement manuel
    inputs: # Optionnel : définir des inputs pour le déclenchement manuel
      logLevel:
        description: 'Niveau de log'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tag:
        description: 'Tag à utiliser'
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Run a one-line script
      run: |
        echo "Workflow déclenché manuellement !"
        echo "Niveau de log : ${{ github.event.inputs.logLevel }}"
        echo "Tag : ${{ github.event.inputs.tag }}"
</code></pre>
</li>
<li>
<p>Poussez. Allez dans l'onglet "Actions" de votre dépôt, sélectionnez ce workflow, et cliquez sur "Run workflow".</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Contrôle manuel pour des tâches comme des déploiements en production ou des scripts de maintenance.</p>
<p><strong>Application réelle :</strong>
Déclencher un déploiement vers la production après validation manuelle.</p>
<h3 id="exercice-15--gérer-les-dépendances-entre-workflows"><a class="header" href="#exercice-15--gérer-les-dépendances-entre-workflows">Exercice 15 : Gérer les dépendances entre workflows</a></h3>
<p><strong>Objectif :</strong> Déclencher un workflow après la complétion d'un autre (<code>workflow_run</code>).</p>
<ol>
<li>
<p>Créez deux fichiers de workflow : <code>build.yml</code> et <code>deploy.yml</code>.
<code>build.yml</code> :</p>
<pre><code class="language-yaml">name: Build Principal

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un build et créer un artefact
      run: |
        echo "Building project..."
        mkdir -p mon_build
        echo "Contenu du build" &gt; mon_build/fichier_construit.txt
    - name: Uploader l'artefact du build
      uses: actions/upload-artifact@v4
      with:
        name: build-artifact
        path: mon_build/ # Uploader le dossier
</code></pre>
<p><code>deploy.yml</code> :</p>
<pre><code class="language-yaml">name: Deploy Après Build

on:
  workflow_run:
    workflows: ["Build Principal"] # Nom du workflow déclencheur
    types:
      - completed # Se déclenche quand "Build Principal" est terminé

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }} # Condition: seulement si le build a réussi
    steps:
    - name: Checkout du code (nécessaire pour certains contextes ou scripts de déploiement)
      uses: actions/checkout@v4
    - name: Télécharger l'artefact du build
      uses: actions/download-artifact@v4
      with:
        name: build-artifact # Doit correspondre au nom de l'artefact uploadé
        # path: ./destination # Optionnel, sinon à la racine
        # Spécifier le run_id est crucial si vous avez plusieurs actions/upload-artifact avec le même nom
        # ou pour récupérer celui du workflow déclencheur.
        # Pour workflow_run, GHA le gère implicitement pour les artefacts du workflow déclencheur.
    - name: Simuler un déploiement
      run: |
        echo "Deploying project avec l'artefact..."
        cat fichier_construit.txt # Vérifier que le fichier est là
</code></pre>
</li>
<li>
<p>Poussez les modifications. Un push sur <code>main</code> devrait lancer <code>Build Principal</code>, et si celui-ci réussit, <code>Deploy Après Build</code> devrait se lancer.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Structurer des processus CI/CD complexes en workflows plus petits et gérables.</p>
<p><strong>Application réelle :</strong>
Un workflow de build et test qui, en cas de succès, déclenche un workflow de déploiement sur un environnement de staging, puis potentiellement un autre pour la production.</p>
<h3 id="exercice-16--utiliser-des-workflows-réutilisables"><a class="header" href="#exercice-16--utiliser-des-workflows-réutilisables">Exercice 16 : Utiliser des workflows réutilisables</a></h3>
<p><strong>Objectif :</strong> Créer un workflow qui peut être appelé par d'autres workflows (<code>workflow_call</code>).</p>
<ol>
<li>
<p>Créez un fichier <code>workflow-reutilisable.yml</code> :</p>
<pre><code class="language-yaml">name: Mon Workflow Réutilisable

on:
  workflow_call: # Définit ce workflow comme étant réutilisable
    inputs:
      message_perso:
        description: 'Message à afficher'
        required: true
        type: string
      executer_tests:
        description: 'Faut-il exécuter les tests ?'
        required: false
        type: boolean
        default: false
    outputs: # Optionnel : définir des outputs
      resultat_reutilisable:
        description: 'Un résultat du workflow réutilisable'
        value: ${{ jobs.tache_reutilisable.outputs.result_output }}


jobs:
  tache_reutilisable:
    runs-on: ubuntu-latest
    outputs: # Définir les outputs du job
      result_output: ${{ steps.etape_reutilisable.outputs.result }}
    steps:
      - id: etape_reutilisable
        run: |
          echo "Message reçu : ${{ inputs.message_perso }}"
          if [ "${{ inputs.executer_tests }}" == "true" ]; then
            echo "Exécution des tests demandée..."
          else
            echo "Pas de tests demandés."
          fi
          echo "result=SuccesDuReutilisable" &gt;&gt; $GITHUB_OUTPUT
</code></pre>
</li>
<li>
<p>Créez un fichier <code>workflow-appelant.yml</code> pour appeler le workflow réutilisable :</p>
<pre><code class="language-yaml">name: Workflow Appellant

on: [push]

jobs:
  appel_du_workflow:
    # Important: Pour appeler un workflow réutilisable du même dépôt :
    uses: ./.github/workflows/workflow-reutilisable.yml
    # Pour un workflow dans un autre dépôt :
    # uses: VOTRE_ORG/VOTRE_REPO/.github/workflows/workflow-reutilisable.yml@main_ou_tag_ou_sha
    with:
      message_perso: "Salut depuis le workflow appellant !"
      executer_tests: true
    # secrets: inherit # Pour passer les secrets, si besoin
  
  utiliser_output:
    runs-on: ubuntu-latest
    needs: appel_du_workflow # S'assurer qu'il tourne après
    steps:
      - run: echo "Résultat du workflow réutilisable : ${{ needs.appel_du_workflow.outputs.resultat_reutilisable }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Centraliser et partager des logiques de workflow communes, réduisant la duplication et facilitant la maintenance.</p>
<p><strong>Application réelle :</strong>
Créer un workflow de build ou de test standardisé que plusieurs dépôts de votre organisation peuvent appeler.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="fiche-dexercices-non-guidés-sur-les-github-actions"><a class="header" href="#fiche-dexercices-non-guidés-sur-les-github-actions">Fiche d'Exercices Non-Guidés sur les GitHub Actions</a></h3>
<hr />
<h2 id="niveau-1--débutant-1"><a class="header" href="#niveau-1--débutant-1">Niveau 1 : Débutant</a></h2>
<h3 id="exercice-1--créer-un-dépôt-et-configurer-github-actions-1"><a class="header" href="#exercice-1--créer-un-dépôt-et-configurer-github-actions-1">Exercice 1 : Créer un dépôt et configurer GitHub Actions</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer un dépôt GitHub et configurer GitHub Actions.</p>
<ol>
<li>Créez un dépôt sur GitHub.</li>
<li>Clonez le dépôt localement.</li>
<li>Dans le dépôt, créez un répertoire <code>.github/workflows</code>.</li>
<li>Dans ce répertoire, créez un fichier <code>main.yml</code>.</li>
</ol>
<hr />
<h3 id="exercice-2--créer-une-action-simple-1"><a class="header" href="#exercice-2--créer-une-action-simple-1">Exercice 2 : Créer une action simple</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub simple qui s'exécute sur chaque push.</p>
<ol>
<li>Créez une action GitHub simple qui s'exécute sur chaque push.</li>
<li>Faites en sorte que cette action affiche "Hello, world!" dans les logs.</li>
</ol>
<hr />
<h3 id="exercice-3--exécuter-un-script-multi-lignes-1"><a class="header" href="#exercice-3--exécuter-un-script-multi-lignes-1">Exercice 3 : Exécuter un script multi-lignes</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter un script multi-lignes dans une action GitHub.</p>
<ol>
<li>Modifiez le fichier <code>main.yml</code> pour exécuter un script multi-lignes.</li>
<li>Faites en sorte que le script affiche plusieurs lignes de texte dans les logs.</li>
</ol>
<hr />
<h3 id="exercice-4--utiliser-des-actions-de-la-marketplace-1"><a class="header" href="#exercice-4--utiliser-des-actions-de-la-marketplace-1">Exercice 4 : Utiliser des actions de la marketplace</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser une action de la GitHub Marketplace.</p>
<ol>
<li>Choisissez une action dans la GitHub Marketplace.</li>
<li>Modifiez le fichier <code>main.yml</code> pour utiliser cette action.</li>
</ol>
<hr />
<h3 id="exercice-5--ajouter-des-secrets-1"><a class="header" href="#exercice-5--ajouter-des-secrets-1">Exercice 5 : Ajouter des secrets</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des secrets dans GitHub Actions.</p>
<ol>
<li>Ajoutez un secret dans les paramètres de votre dépôt GitHub.</li>
<li>Modifiez le fichier <code>main.yml</code> pour utiliser ce secret dans une action.</li>
</ol>
<hr />
<h3 id="exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions-1"><a class="header" href="#exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions-1">Exercice 6 : Utiliser des matrices pour tester plusieurs versions</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des matrices pour tester plusieurs versions d'un langage.</p>
<ol>
<li>Modifiez le fichier <code>main.yml</code> pour utiliser une matrice avec différentes versions d'un langage (par exemple, Node.js, Python).</li>
<li>Assurez-vous que votre action teste le code sur chaque version spécifiée dans la matrice.</li>
</ol>
<hr />
<h2 id="niveau-2--intermédiaire-1"><a class="header" href="#niveau-2--intermédiaire-1">Niveau 2 : Intermédiaire</a></h2>
<h3 id="exercice-7--exécuter-des-tests-unitaires-1"><a class="header" href="#exercice-7--exécuter-des-tests-unitaires-1">Exercice 7 : Exécuter des tests unitaires</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter des tests unitaires dans GitHub Actions.</p>
<ol>
<li>Créez un projet avec des tests unitaires.</li>
<li>Modifiez le fichier <code>main.yml</code> pour exécuter les tests unitaires à chaque push.</li>
</ol>
<hr />
<h3 id="exercice-8--déployer-sur-github-pages-1"><a class="header" href="#exercice-8--déployer-sur-github-pages-1">Exercice 8 : Déployer sur GitHub Pages</a></h3>
<p><strong>Objectif :</strong> Apprendre à déployer un site sur GitHub Pages via GitHub Actions.</p>
<ol>
<li>Créez un site statique dans votre dépôt.</li>
<li>Modifiez le fichier <code>main.yml</code> pour déployer ce site sur GitHub Pages à chaque push sur la branche principale.</li>
</ol>
<hr />
<h3 id="exercice-9--utiliser-des-workflows-multi-jobs-1"><a class="header" href="#exercice-9--utiliser-des-workflows-multi-jobs-1">Exercice 9 : Utiliser des workflows multi-jobs</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer des workflows multi-jobs.</p>
<ol>
<li>Créez un workflow avec plusieurs jobs.</li>
<li>Assurez-vous que les jobs s'exécutent dans l'ordre correct.</li>
</ol>
<hr />
<h3 id="exercice-10--utiliser-des-artefacts-1"><a class="header" href="#exercice-10--utiliser-des-artefacts-1">Exercice 10 : Utiliser des artefacts</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des artefacts pour stocker et partager des fichiers entre les jobs.</p>
<ol>
<li>Modifiez le fichier <code>main.yml</code> pour créer un artefact dans un job.</li>
<li>Téléchargez cet artefact dans un autre job et utilisez-le.</li>
</ol>
<hr />
<h2 id="niveau-3--avancé-1"><a class="header" href="#niveau-3--avancé-1">Niveau 3 : Avancé</a></h2>
<h3 id="exercice-11--créer-une-action-personnalisée-1"><a class="header" href="#exercice-11--créer-une-action-personnalisée-1">Exercice 11 : Créer une action personnalisée</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub personnalisée.</p>
<ol>
<li>Créez un répertoire pour votre action personnalisée.</li>
<li>Créez un fichier <code>action.yml</code> et un script associé pour cette action.</li>
<li>Modifiez le fichier <code>main.yml</code> pour utiliser cette action personnalisée.</li>
</ol>
<hr />
<h3 id="exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes-1"><a class="header" href="#exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes-1">Exercice 12 : Utiliser des conditions pour contrôler les étapes</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des conditions pour contrôler l'exécution des étapes dans un workflow.</p>
<ol>
<li>Ajoutez des conditions à certaines étapes de votre workflow pour qu'elles ne s'exécutent que sous certaines conditions.</li>
</ol>
<hr />
<h3 id="exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé-1"><a class="header" href="#exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé-1">Exercice 13 : Utiliser des secrets pour déploiement sécurisé</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des secrets pour sécuriser les déploiements.</p>
<ol>
<li>Ajoutez des secrets nécessaires pour le déploiement dans les paramètres du dépôt GitHub.</li>
<li>Modifiez le fichier <code>main.yml</code> pour utiliser ces secrets lors du déploiement.</li>
</ol>
<hr />
<h3 id="exercice-14--déclencher-des-workflows-manuellement-1"><a class="header" href="#exercice-14--déclencher-des-workflows-manuellement-1">Exercice 14 : Déclencher des workflows manuellement</a></h3>
<p><strong>Objectif :</strong> Apprendre à déclencher des workflows manuellement via GitHub Actions.</p>
<ol>
<li>Modifiez le fichier <code>main.yml</code> pour ajouter un déclencheur manuel.</li>
<li>Déclenchez le workflow manuellement depuis l'onglet "Actions" de votre dépôt GitHub.</li>
</ol>
<hr />
<h3 id="exercice-15--gérer-les-dépendances-entre-workflows-1"><a class="header" href="#exercice-15--gérer-les-dépendances-entre-workflows-1">Exercice 15 : Gérer les dépendances entre workflows</a></h3>
<p><strong>Objectif :</strong> Apprendre à gérer les dépendances entre différents workflows.</p>
<ol>
<li>Créez deux fichiers de workflow : un pour le build et un pour le déploiement.</li>
<li>Configurez le workflow de déploiement pour qu'il soit déclenché à la fin du workflow de build.</li>
</ol>
<hr />
<h3 id="exercice-16--utiliser-des-workflows-réutilisables-1"><a class="header" href="#exercice-16--utiliser-des-workflows-réutilisables-1">Exercice 16 : Utiliser des workflows réutilisables</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer et utiliser des workflows réutilisables.</p>
<ol>
<li>Créez un fichier de workflow réutilisable.</li>
<li>Modifiez un autre workflow pour utiliser ce workflow réutilisable.</li>
</ol>
<hr />
<p>Ces exercices couvrent une gamme variée de compétences et de concepts nécessaires pour maîtriser les GitHub Actions, allant des bases pour les débutants à des défis avancés pour les utilisateurs plus expérimentés. Chaque exercice est conçu pour vous fournir des compétences pratiques que vous pouvez appliquer directement à vos propres projets et workflows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp-guidé--de-maven-local-à-lintégration-continue-avec-github-actions-java"><a class="header" href="#tp-guidé--de-maven-local-à-lintégration-continue-avec-github-actions-java">TP Guidé : De Maven Local à l'Intégration Continue avec GitHub Actions (Java)</a></h1>
<p><strong>Objectif Général :</strong>
Ce TP est divisé en deux grands exercices.</p>
<ol>
<li><strong>Exercice 1 :</strong> Maîtriser le cycle de développement et de test d'un projet Java avec Maven, entièrement en local, en appliquant une approche TDD-light.</li>
<li><strong>Exercice 2 :</strong> Prendre le projet fonctionnel localement et mettre en place une chaîne d'Intégration Continue (CI) avec GitHub Actions pour automatiser les builds et les tests.</li>
</ol>
<p><strong>Prérequis :</strong></p>
<ul>
<li>Git installé et configuré.</li>
<li>JDK (version 8 ou supérieure, compatible avec l'archétype ; 11+ est bien pour la CI) et Apache Maven installés.</li>
<li>Un compte GitHub.</li>
</ul>
<hr />
<h2 id="exercice-1--maîtriser-maven-en-local-avec-une-approche-tdd-light"><a class="header" href="#exercice-1--maîtriser-maven-en-local-avec-une-approche-tdd-light">Exercice 1 : Maîtriser Maven en Local avec une Approche TDD-Light</a></h2>
<p><strong>Objectif :</strong> Créer un projet Java avec Maven, le compiler et tester avec <code>mvn package</code>, puis ajouter une nouvelle fonctionnalité en suivant un mini-cycle TDD (écrire un test qui échoue, écrire le code pour le faire passer).</p>
<h3 id="11-générer-le-projet-maven"><a class="header" href="#11-générer-le-projet-maven">1.1. Générer le Projet Maven</a></h3>
<ol>
<li>
<p><strong>Ouvre ton terminal</strong> et navigue vers le dossier où tu souhaites créer ton projet.</p>
</li>
<li>
<p><strong>Génère le projet</strong> avec la commande standard de l'archétype <code>maven-archetype-quickstart</code>:</p>
<pre><code class="language-bash">mvn archetype:generate -DgroupId=com.maventdd.app -DartifactId=maSuperAppJava -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
</code></pre>
<ul>
<li>Cela crée un dossier <code>maSuperAppJava</code>.</li>
</ul>
</li>
<li>
<p><strong>Navigue dans le dossier du projet</strong> :</p>
<pre><code class="language-bash">cd maSuperAppJava
</code></pre>
<p>Tu y trouveras la structure Maven classique avec un <code>pom.xml</code>, <code>src/main/java/com/maventdd/app/App.java</code> et <code>src/test/java/com/maventdd/app/AppTest.java</code>.
L'archétype <code>maven-archetype-quickstart:1.4</code> utilise typiquement JUnit 4.x. Pour cet exercice, <strong>nous n'allons PAS modifier le <code>pom.xml</code> initialement</strong> pour les dépendances de test, on utilise ce qui est fourni.</p>
<p><em>Optionnel (mais bonne pratique pour la suite et la CI) :</em> Tu peux juste t'assurer que ton <code>pom.xml</code> spécifie une version de Java pour le compilateur que tu utiliseras aussi dans GitHub Actions (par exemple Java 11). Si la section <code>&lt;properties&gt;</code> n'existe pas, ajoute-la. Si elle existe, ajoute ou modifie <code>maven.compiler.source</code> et <code>maven.compiler.target</code> :</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
</li>
</ol>
<h3 id="12-premier-build-et-tests-locaux-cycle-vert-initial"><a class="header" href="#12-premier-build-et-tests-locaux-cycle-vert-initial">1.2. Premier Build et Tests Locaux (Cycle Vert Initial)</a></h3>
<p>La commande <code>mvn package</code> va compiler ton code, exécuter les tests (ceux de <code>AppTest.java</code> qui sont fournis et qui doivent passer), et créer un fichier JAR.</p>
<ol>
<li><strong>Lance le build complet (compilation, tests, packaging) :</strong>
<pre><code class="language-bash">mvn package
</code></pre>
Tu devrais voir des logs de compilation et de test, et à la fin : <code>[INFO] BUILD SUCCESS</code>. Les tests par défaut sont passés. Le JAR est dans le dossier <code>target/</code>.</li>
</ol>
<h3 id="13-préparation-pour-le-cycle-tdd-light--nouvelle-fonctionnalité"><a class="header" href="#13-préparation-pour-le-cycle-tdd-light--nouvelle-fonctionnalité">1.3. Préparation pour le Cycle TDD-Light : Nouvelle Fonctionnalité</a></h3>
<p>Nous allons ajouter une classe <code>Calculatrice</code> avec une méthode <code>additionner</code>.</p>
<ol>
<li>
<p><strong>Crée la classe <code>Calculatrice.java</code></strong> dans <code>src/main/java/com/maventdd/app/</code> (à côté de <code>App.java</code>) :</p>
<pre><code class="language-java">package com.maventdd.app; // Assure-toi que le package est correct

public class Calculatrice {
    public int additionner(int a, int b) {
        // Laisser "cassé" ou non implémenté pour l'instant
        throw new UnsupportedOperationException("Méthode additionner() pas encore implémentée !");
    }
}
</code></pre>
</li>
<li>
<p><strong>Crée la classe de test <code>CalculatriceTest.java</code></strong> dans <code>src/test/java/com/maventdd/app/</code> (à côté de <code>AppTest.java</code>).
Utilise la syntaxe JUnit 4 (comme dans <code>AppTest.java</code> généré) :</p>
<pre><code class="language-java">package com.maventdd.app; // Assure-toi que le package est correct

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatriceTest {
    @Test
    public void testAdditionner() {
        Calculatrice calc = new Calculatrice();
        assertEquals(5, calc.additionner(2, 3));
    }
}
</code></pre>
</li>
<li>
<p><strong>Modifie <code>App.java</code></strong> pour instancier <code>Calculatrice</code> (juste pour s'assurer qu'elle est bien prise en compte par la compilation si besoin, bien que les tests devraient suffire) :</p>
<pre><code class="language-java">package com.maventdd.app;

public class App {
    public static void main( String[] args ) {
        System.out.println( "Hello World!" );
        Calculatrice calc = new Calculatrice(); // Ajout pour que la classe soit "vue"
    }
}
</code></pre>
</li>
</ol>
<h3 id="14-deuxième-build-et-tests-locaux-cycle-rouge"><a class="header" href="#14-deuxième-build-et-tests-locaux-cycle-rouge">1.4. Deuxième Build et Tests Locaux (Cycle Rouge)</a></h3>
<ol>
<li><strong>Relance le build complet :</strong>
<pre><code class="language-bash">mvn package
</code></pre>
Cette fois, tu devrais voir <code>[INFO] BUILD FAILURE</code>. Le nouveau test <code>CalculatriceTest.testAdditionner</code> échoue car la méthode <code>additionner</code> lève une exception (ou retourne une mauvaise valeur si tu as choisi cette option). C'est notre étape "rouge".</li>
</ol>
<h3 id="15-implémenter-la-fonctionnalité-cycle-vert"><a class="header" href="#15-implémenter-la-fonctionnalité-cycle-vert">1.5. Implémenter la Fonctionnalité (Cycle Vert)</a></h3>
<ol>
<li><strong>Modifie <code>Calculatrice.java</code></strong> pour implémenter correctement la méthode :
<pre><code class="language-java">package com.maventdd.app;

public class Calculatrice {
    public int additionner(int a, int b) {
        return a + b; // L'implémentation correcte !
    }
}
</code></pre>
</li>
<li><strong>Relance le build complet :</strong>
<pre><code class="language-bash">mvn package
</code></pre>
Maintenant, tu devrais revoir <code>[INFO] BUILD SUCCESS</code>. Tous les tests (ceux de <code>AppTest</code> et <code>CalculatriceTest</code>) passent.</li>
</ol>
<p><strong>Bravo pour cette première partie !</strong> Tu as vu comment Maven compile, teste, et package, et tu as fait un mini-cycle TDD en local.</p>
<hr />
<h2 id="exercice-2--intégration-continue-avec-github-actions"><a class="header" href="#exercice-2--intégration-continue-avec-github-actions">Exercice 2 : Intégration Continue avec GitHub Actions</a></h2>
<p><strong>Objectif :</strong> Automatiser le processus de build et de test avec GitHub Actions à chaque fois que tu pousses du code.</p>
<h3 id="21-versionner-le-projet-avec-git-et-pousser-sur-github"><a class="header" href="#21-versionner-le-projet-avec-git-et-pousser-sur-github">2.1. Versionner le Projet avec Git et Pousser sur GitHub</a></h3>
<ol>
<li>Si ce n'est pas déjà fait, <strong>initialise un dépôt Git</strong> à la racine de <code>maSuperAppJava</code> et fais ton premier commit avec le code fonctionnel :
<pre><code class="language-bash">git init
echo "target/" &gt; .gitignore
echo ".idea/" &gt;&gt; .gitignore
echo "*.iml" &gt;&gt; .gitignore
echo ".vscode/" &gt;&gt; .gitignore
echo ".DS_Store" &gt;&gt; .gitignore
# (Si tu avais déjà un .git, fais juste les add/commit nécessaires)
git add .
git commit -m "Projet Java Maven avec Calculatrice fonctionnelle et tests OK"
</code></pre>
</li>
<li><strong>Crée un dépôt distant</strong> sur GitHub (par exemple, nomme-le <code>maSuperAppJava-CI</code>).</li>
<li><strong>Lie ton dépôt local au dépôt distant</strong> et <strong>pousse ton code</strong> :
<pre><code class="language-bash">git remote add origin &lt;URL_DE_TON_DEPOT_GITHUB.git&gt;
git branch -M main
git push -u origin main
</code></pre>
</li>
</ol>
<h3 id="22-créer-le-workflow-github-actions"><a class="header" href="#22-créer-le-workflow-github-actions">2.2. Créer le Workflow GitHub Actions</a></h3>
<ol>
<li>
<p>À la racine de ton projet <code>maSuperAppJava</code>, crée le dossier <code>.github/</code> s'il n'existe pas, puis dedans un dossier <code>workflows/</code>.</p>
</li>
<li>
<p>Dans <code>.github/workflows/</code>, crée un fichier nommé <code>maven-ci.yml</code> (ou le nom que tu veux) avec le contenu suivant :</p>
<pre><code class="language-yaml">name: Java CI with Maven

on: [push] # Déclenche le workflow à chaque push sur n'importe quelle branche

jobs:
  build_and_test: # Nom du job
    runs-on: ubuntu-latest # Utilise une machine virtuelle Ubuntu fournie par GitHub

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Action pour récupérer ton code du dépôt

      - name: Set up JDK 17 # Ou la version que tu as configurée dans ton pom.xml
        uses: actions/setup-java@v4 # Action pour configurer Java
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven' # Met en cache les dépendances Maven pour accélérer les builds suivants

      - name: Build and test with Maven
        working-directory: ./java/my-app # Attention a mettre le bon dossier
        run: mvn -B package # -B pour batch mode. 'package' compile, teste, et package.
</code></pre>
</li>
</ol>
<h3 id="23-push-du-workflow-et-vérification-sur-github-actions"><a class="header" href="#23-push-du-workflow-et-vérification-sur-github-actions">2.3. Push du Workflow et Vérification sur GitHub Actions</a></h3>
<ol>
<li><strong>Commit et push</strong> ton nouveau fichier de workflow :
<pre><code class="language-bash">git add .github/workflows/maven-ci.yml
git commit -m "Ajout du workflow GitHub Actions pour build et test Maven"
git push
</code></pre>
</li>
<li>Va sur ton dépôt GitHub, dans l'onglet <strong>"Actions"</strong>.</li>
<li>Tu devrais voir ton workflow (<code>Java CI with Maven</code>) s'exécuter. Clique dessus pour voir les détails des étapes (<code>steps</code>).</li>
<li>Le workflow devrait <strong>réussir</strong> (passer au vert), car il exécute <code>mvn -B package</code>, qui inclut les tests, et tous tes tests locaux passaient.</li>
</ol>
<h3 id="24-simuler-un-Échec-cycle-rouge-en-ci"><a class="header" href="#24-simuler-un-Échec-cycle-rouge-en-ci">2.4. Simuler un Échec (Cycle Rouge en CI)</a></h3>
<ol>
<li>Retourne dans ton code local, dans <code>Calculatrice.java</code>. <strong>Introduis une erreur</strong> dans la méthode <code>additionner</code> :
<pre><code class="language-java">// Dans Calculatrice.java
public int additionner(int a, int b) {
    return a + b + 1; // Oups, une erreur !
}
</code></pre>
</li>
<li><strong>Commit et push</strong> cette modification "cassée" :
<pre><code class="language-bash">git add src/main/java/com/maventdd/app/Calculatrice.java
git commit -m "Erreur intentionnelle dans Calculatrice.additionner"
git push
</code></pre>
</li>
<li>Retourne sur GitHub Actions. Le nouveau workflow lancé par ce push devrait <strong>échouer</strong> à l'étape "Build and test with Maven". Regarde les logs pour voir l'échec du test.</li>
</ol>
<h3 id="25-corriger-et-valider-cycle-vert-en-ci"><a class="header" href="#25-corriger-et-valider-cycle-vert-en-ci">2.5. Corriger et Valider (Cycle Vert en CI)</a></h3>
<ol>
<li>Dans ton code local, <strong>corrige l'erreur</strong> dans <code>Calculatrice.java</code> :
<pre><code class="language-java">// Dans Calculatrice.java
public int additionner(int a, int b) {
    return a + b; // C'est corrigé !
}
</code></pre>
</li>
<li><strong>Commit et push</strong> la correction :
<pre><code class="language-bash">git add src/main/java/com/maventdd/app/Calculatrice.java
git commit -m "Correction de Calculatrice.additionner"
git push
</code></pre>
</li>
<li>Sur GitHub Actions, le dernier workflow devrait maintenant <strong>réussir</strong>.</li>
</ol>
<hr />
<p><strong>Félicitations !</strong>
Tu as maintenant :</p>
<ul>
<li>Créé et testé un projet Java avec Maven en local.</li>
<li>Mis en place une Intégration Continue avec GitHub Actions qui build et teste ton projet à chaque push.</li>
<li>Expérimenté le cycle "rouge/vert" directement dans ton pipeline CI.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp-non-guidé--de-maven-local-à-lintégration-continue-avec-github-actions-java---challenge"><a class="header" href="#tp-non-guidé--de-maven-local-à-lintégration-continue-avec-github-actions-java---challenge">TP Non Guidé : De Maven Local à l'Intégration Continue avec GitHub Actions (Java - Challenge)</a></h1>
<p><strong>Objectif Général :</strong>
Ce TP est conçu pour être réalisé après avoir compris les bases de Maven et de GitHub Actions. Il vise à consolider votre compréhension du cycle de développement Java avec Maven et son automatisation via GitHub Actions en vous faisant appliquer les principes vus précédemment.</p>
<ol>
<li><strong>Exercice 1 :</strong> Développer une petite fonctionnalité en local en utilisant une approche TDD-light avec Maven.</li>
<li><strong>Exercice 2 :</strong> Mettre en place une chaîne d'Intégration Continue pour valider votre travail avec GitHub Actions.</li>
</ol>
<p><strong>Ressource Utile :</strong></p>
<ul>
<li>Pour vous rafraîchir la mémoire sur les commandes Maven de base et la structure d'un projet : <a href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">Maven in 5 Minutes</a></li>
</ul>
<p><strong>Prérequis :</strong></p>
<ul>
<li>Maîtrise des commandes Git de base et interaction avec un dépôt distant (GitHub).</li>
<li>Connaissance de la commande <code>mvn archetype:generate</code> pour créer un projet Maven.</li>
<li>Compréhension du cycle de vie Maven, notamment la phase <code>package</code>.</li>
<li>Notions de base sur la syntaxe des workflows GitHub Actions.</li>
<li>JDK (version 17 ou supérieure recommandée) et Apache Maven installés et configurés localement.</li>
</ul>
<hr />
<h2 id="exercice-1--développement-local-dune-utility-string-avec-maven-approche-tdd-light"><a class="header" href="#exercice-1--développement-local-dune-utility-string-avec-maven-approche-tdd-light">Exercice 1 : Développement Local d'une Utility String avec Maven (Approche TDD-Light)</a></h2>
<p><strong>Objectif :</strong> Mettre en place un projet Maven, y ajouter une nouvelle classe utilitaire pour les chaînes de caractères, et implémenter deux méthodes (<code>renverser</code> et <code>estPalindrome</code>) en suivant un cycle "test d'abord" pour chacune.</p>
<h3 id="11-initialisation-du-projet"><a class="header" href="#11-initialisation-du-projet">1.1. Initialisation du Projet</a></h3>
<ol>
<li><strong>Créez un nouveau projet Maven</strong> en utilisant l'archétype <code>maven-archetype-quickstart</code>.
<ul>
<li><code>groupId</code>: <code>com.formation.stringutils</code></li>
<li><code>artifactId</code>: <code>monStringUtilsApp</code></li>
</ul>
</li>
<li>Assurez-vous que le projet généré compile et que les tests par défaut (s'il y en a, fournis par l'archétype) passent en utilisant la commande Maven appropriée pour builder et tester (typiquement <code>mvn package</code>).</li>
<li>Configurez le <code>pom.xml</code> pour utiliser <strong>Java 17</strong> pour la compilation (C'est normalement la configuration par defaut)</li>
</ol>
<h3 id="12-cycle-tdd-pour-la-fonction-renverserstring-chaine"><a class="header" href="#12-cycle-tdd-pour-la-fonction-renverserstring-chaine">1.2. Cycle TDD pour la Fonction <code>renverser(String chaine)</code></a></h3>
<p>Vous allez maintenant ajouter une classe <code>StringUtils</code> avec une méthode <code>public String renverser(String chaine)</code>.</p>
<ol>
<li><strong>Écrivez le Test d'Abord :</strong>
<ul>
<li>Créez une nouvelle classe de test <code>StringUtilsTest.java</code> dans le répertoire de test approprié.</li>
<li>Dans cette classe, écrivez une méthode de test (en utilisant la syntaxe JUnit 4.x, généralement fournie par l'archétype <code>maven-archetype-quickstart:1.4</code>) qui vérifiera le bon fonctionnement de la future méthode <code>renverser</code>. Testez au moins deux cas (ex: <code>"radar"</code>, <code>"Java"</code>). Ce test doit initialement échouer.</li>
</ul>
</li>
<li><strong>Créez la Classe et la Méthode (non implémentée) :</strong>
<ul>
<li>Créez la classe <code>StringUtils.java</code> dans le répertoire source principal approprié.</li>
<li>Ajoutez la signature de la méthode <code>public String renverser(String chaine)</code>. Pour l'instant, faites en sorte qu'elle lève une <code>UnsupportedOperationException</code> ou qu'elle retourne <code>null</code> (ou une chaîne vide) pour que le test échoue.</li>
</ul>
</li>
<li><strong>Vérification du Cycle Rouge :</strong>
<ul>
<li>Lancez la commande Maven pour builder et tester votre projet.</li>
<li>Confirmez que le build échoue et que l'échec est bien dû à votre nouveau test pour <code>StringUtils.renverser()</code>.</li>
</ul>
</li>
<li><strong>Implémentation de la Fonctionnalité :</strong>
<ul>
<li>Maintenant, modifiez la méthode <code>StringUtils.renverser()</code> pour qu'elle implémente correctement la logique de renversement de la chaîne de caractères.</li>
</ul>
</li>
<li><strong>Vérification du Cycle Vert :</strong>
<ul>
<li>Relancez la commande Maven pour builder et tester.</li>
<li>Assurez-vous que tous les tests (y compris celui pour <code>renverser</code>) passent et que le build est un succès.</li>
</ul>
</li>
</ol>
<h3 id="13-cycle-tdd-pour-la-fonction-estpalindromestring-chaine"><a class="header" href="#13-cycle-tdd-pour-la-fonction-estpalindromestring-chaine">1.3. Cycle TDD pour la Fonction <code>estPalindrome(String chaine)</code></a></h3>
<p>Ajoutez une nouvelle méthode <code>public boolean estPalindrome(String chaine)</code> à votre classe <code>StringUtils</code>. Un palindrome est un mot qui se lit de la même manière dans les deux sens (ex: "radar", "kayak"). Pour cet exercice, considérez que la casse et les espaces ne comptent pas (ex: "Kayak" est un palindrome, "Engage le jeu que je le gagne" est un palindrome).</p>
<ol>
<li><strong>Écrivez le Test d'Abord (dans <code>StringUtilsTest.java</code>) :</strong>
<ul>
<li>Ajoutez une nouvelle méthode de test pour <code>estPalindrome(String chaine)</code>.</li>
<li>Testez plusieurs cas : un palindrome simple, un non-palindrome, un palindrome avec casse différente, une chaîne vide (qui peut être considérée comme un palindrome), et un palindrome avec des espaces.</li>
<li>Ce nouveau test doit faire échouer le build.</li>
</ul>
</li>
<li><strong>Ajoutez la Signature de la Méthode (non implémentée) :</strong>
<ul>
<li>Ajoutez <code>public boolean estPalindrome(String chaine)</code> à <code>StringUtils.java</code>, la faisant lever une <code>UnsupportedOperationException</code> ou retourner <code>false</code> par défaut.</li>
</ul>
</li>
<li><strong>Vérification du Cycle Rouge :</strong>
<ul>
<li>Lancez <code>mvn package</code>. Le build doit échouer à cause du test <code>estPalindrome()</code>.</li>
</ul>
</li>
<li><strong>Implémentation de la Fonctionnalité :</strong>
<ul>
<li>Implémentez la logique de <code>StringUtils.estPalindrome()</code>.</li>
</ul>
</li>
<li><strong>Vérification du Cycle Vert :</strong>
<ul>
<li>Relancez <code>mvn package</code>. Tous les tests doivent maintenant passer.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="exercice-2--automatisation-avec-github-actions-et-nouveau-cycle-tdd"><a class="header" href="#exercice-2--automatisation-avec-github-actions-et-nouveau-cycle-tdd">Exercice 2 : Automatisation avec GitHub Actions et Nouveau Cycle TDD</a></h2>
<p><strong>Objectif :</strong> Mettre en place un workflow GitHub Actions pour votre projet. Puis, ajouter une nouvelle fonctionnalité (<code>compterVoyelles</code>) en suivant le cycle TDD directement avec le feedback de la CI.</p>
<h3 id="21-préparation-du-dépôt-github-et-ci-initiale"><a class="header" href="#21-préparation-du-dépôt-github-et-ci-initiale">2.1. Préparation du Dépôt GitHub et CI Initiale</a></h3>
<ol>
<li>Assurez-vous que votre projet local <code>monStringUtilsApp</code> est un dépôt Git.</li>
<li>Créez un fichier <code>.gitignore</code> adapté aux projets Maven.</li>
<li>Commitez toutes vos modifications (le projet avec <code>StringUtils.renverser()</code> et <code>StringUtils.estPalindrome()</code> fonctionnels et testés).</li>
<li>Créez un nouveau dépôt distant sur GitHub et poussez votre branche <code>main</code>.</li>
<li><strong>Mettez en place un workflow GitHub Actions</strong> dans <code>.github/workflows/</code> qui :
<ul>
<li>Se déclenche sur chaque <code>push</code>.</li>
<li>Fait un checkout du code.</li>
<li>Configure l'environnement Java (JDK 17). Pensez à utiliser le cache Maven.</li>
<li>Lance la commande Maven <code>mvn -B package</code>.</li>
</ul>
</li>
<li>Poussez ce workflow. Vérifiez sur GitHub Actions que le pipeline s'exécute et passe au vert.</li>
</ol>
<h3 id="22-cycle-tdd-pour-une-nouvelle-fonctionnalité-comptervoyelles-avec-la-ci"><a class="header" href="#22-cycle-tdd-pour-une-nouvelle-fonctionnalité-comptervoyelles-avec-la-ci">2.2. Cycle TDD pour une Nouvelle Fonctionnalité (<code>compterVoyelles</code>) avec la CI</a></h3>
<p>Vous allez ajouter une méthode <code>public int compterVoyelles(String chaine)</code> à <code>StringUtils</code>.</p>
<ol>
<li><strong>Écrivez le Nouveau Test Localement :</strong>
<ul>
<li>Dans <code>StringUtilsTest.java</code>, ajoutez une méthode de test pour <code>compterVoyelles(String chaine)</code>.</li>
<li>Testez avec des chaînes contenant des voyelles (majuscules et minuscules, par exemple 'a', 'e', 'i', 'o', 'u'), et une chaîne sans voyelles.</li>
</ul>
</li>
<li><strong>Ajoutez la Signature de la Méthode (non implémentée) dans <code>StringUtils.java</code> :</strong>
<ul>
<li>Faites-la lever une <code>UnsupportedOperationException</code> ou retourner <code>0</code>.</li>
</ul>
</li>
<li><strong>Commit et Push (Cycle Rouge en CI) :</strong>
<ul>
<li>Commitez le nouveau test et la signature de la nouvelle méthode.</li>
<li>Poussez sur GitHub.</li>
<li>Allez sur GitHub Actions et <strong>observez l'échec du pipeline</strong>. Analysez les logs pour confirmer que c'est bien votre nouveau test <code>compterVoyelles</code> qui échoue.</li>
</ul>
</li>
<li><strong>Implémentez la Fonctionnalité Localement :</strong>
<ul>
<li>Codez la logique de <code>StringUtils.compterVoyelles()</code>.</li>
</ul>
</li>
<li><strong>Testez en Local :</strong>
<ul>
<li>Lancez <code>mvn package</code> localement pour vous assurer que tous les tests (y compris <code>compterVoyelles</code>) passent.</li>
</ul>
</li>
<li><strong>Commit et Push la Correction (Cycle Vert en CI) :</strong>
<ul>
<li>Commitez l'implémentation de <code>compterVoyelles</code>.</li>
<li>Poussez sur GitHub.</li>
<li>Vérifiez sur GitHub Actions que le pipeline passe maintenant au vert.</li>
</ul>
</li>
</ol>
<hr />
<p><strong>Bravo !</strong>
Vous avez appliqué les principes de TDD-light en local et mis en place une chaîne d'intégration continue robuste pour votre projet Java, en observant l'impact direct de vos modifications sur le statut du pipeline.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutoriels-de-la-documentation-de-docker"><a class="header" href="#tutoriels-de-la-documentation-de-docker">Tutoriels de la documentation de docker</a></h1>
<ul>
<li><a href="https://docs.docker.com/get-started/workshop/">Docker Workshop</a></li>
<li><a href="https://docs.docker.com/guides/java/">Containerize Java Docker App Tutorial</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercice-pratique--Évolution-et-conteneurisation-dune-application-java"><a class="header" href="#exercice-pratique--Évolution-et-conteneurisation-dune-application-java">Exercice Pratique : Évolution et Conteneurisation d'une Application Java</a></h1>
<p><strong>Objectif Général :</strong>
Cet exercice vise à modifier une application Java existante pour la rendre interactive et à la conteneuriser avec Docker. Vous appliquerez les bonnes pratiques pour la création d'une méthode principale fonctionnelle et la construction d'une image Docker.</p>
<p><strong>Contexte :</strong>
Vous repartirez du projet Java <code>maSuperAppJava</code> précédemment créé avec Maven. Ce projet inclut une classe <code>Calculatrice</code> avec une méthode <code>additionner(int a, int b)</code> fonctionnelle et testée. L'objectif est maintenant d'utiliser cette calculatrice dans la méthode <code>main</code> de l'application et de packager l'ensemble dans une image Docker.</p>
<hr />
<h2 id="partie-1--amélioration-de-la-classe-principale-appjava"><a class="header" href="#partie-1--amélioration-de-la-classe-principale-appjava">Partie 1 : Amélioration de la Classe Principale (<code>App.java</code>)</a></h2>
<p>L'objectif de cette partie est de rendre la méthode <code>main</code> de la classe <code>com.maventdd.app.App</code> capable d'interagir avec l'utilisateur et d'utiliser la logique métier de la classe <code>Calculatrice</code>.</p>
<p><strong>Instructions :</strong></p>
<ol>
<li>
<p><strong>Modification de <code>App.java</code> :</strong></p>
<ul>
<li>Adaptez la méthode <code>main</code> pour qu'elle accepte deux arguments numériques (entiers) passés en ligne de commande lors de son exécution.</li>
<li>Ces deux nombres devront être utilisés comme opérandes pour la méthode <code>additionner</code> de la classe <code>Calculatrice</code>.</li>
<li>Le résultat de l'addition devra être affiché de manière claire et compréhensible sur la sortie standard (console).</li>
<li>Implémentez une gestion des erreurs basique :
<ul>
<li>Si le nombre d'arguments fournis n'est pas correct (différent de deux), l'application devra afficher un message d'erreur explicite indiquant l'usage attendu et se terminer.</li>
<li>Si les arguments fournis ne peuvent pas être interprétés comme des nombres entiers, un message d'erreur approprié devra également être affiché avant la terminaison du programme.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Compilation et Test Local :</strong></p>
<ul>
<li>Utilisez Maven pour compiler votre projet et générer l'artefact JAR (<code>mvn package</code>).</li>
<li>Testez le bon fonctionnement de votre application en exécutant le JAR généré directement depuis votre terminal. Assurez-vous de tester les scénarios nominaux (avec des entrées valides) ainsi que les cas d'erreur que vous avez implémentés (nombre incorrect d'arguments, arguments non numériques).</li>
</ul>
</li>
</ol>
<hr />
<h2 id="partie-2--dockerisation-de-lapplication"><a class="header" href="#partie-2--dockerisation-de-lapplication">Partie 2 : Dockerisation de l'Application</a></h2>
<p>L'objectif de cette partie est de créer une image Docker pour votre application Java, permettant de l'exécuter de manière isolée et reproductible.</p>
<p><strong>Instructions :</strong></p>
<ol>
<li>
<p><strong>Création du <code>Dockerfile</code> :</strong></p>
<ul>
<li>À la racine de votre projet <code>maSuperAppJava</code> (au même niveau que le fichier <code>pom.xml</code>), créez un fichier nommé <code>Dockerfile</code> (sans extension).</li>
<li>Ce <code>Dockerfile</code> devra définir les étapes nécessaires pour construire l'image de votre application :
<ul>
<li><strong>Image de Base :</strong> Spécifiez une image de base Java (JRE) officielle et à jour (par exemple, une image basée sur Temurin ou OpenJDK, compatible avec la version de Java configurée dans votre <code>pom.xml</code>).</li>
<li><strong>Copie de l'Artefact :</strong> Incluez les instructions pour copier l'artefact JAR de votre application (préalablement construit par Maven et se trouvant dans le répertoire <code>target/</code>) dans l'image Docker.</li>
<li><strong>Point d'Entrée (<code>ENTRYPOINT</code>) ou Commande (<code>CMD</code>) :</strong> Définissez la commande qui sera exécutée au démarrage d'un conteneur basé sur votre image. Cette commande doit lancer votre application Java (via sa classe principale <code>com.maventdd.app.App</code>) et doit permettre de lui transmettre les deux arguments numériques attendus par la méthode <code>main</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Construction de l'Image Docker :</strong></p>
<ul>
<li>Assurez-vous que votre service Docker est en cours d'exécution.</li>
<li>Depuis votre terminal, positionnez-vous à la racine de votre projet <code>maSuperAppJava</code>.</li>
<li>Construisez l'image Docker en utilisant la commande <code>docker build</code>. Attribuez un nom (par exemple, <code>masuperappjava</code> ou <code>votre-nom/masuperappjava</code>) et un tag (par exemple, <code>1.0</code> ou <code>latest</code>) à votre image pour faciliter son identification.</li>
</ul>
</li>
<li>
<p><strong>Test de l'Image Docker :</strong></p>
<ul>
<li>Une fois l'image construite avec succès, exécutez un conteneur à partir de celle-ci en utilisant la commande <code>docker run</code>.</li>
<li>Lors du lancement du conteneur, fournissez deux nombres entiers comme arguments.</li>
<li>Vérifiez que la sortie affichée par le conteneur correspond au résultat attendu de l'addition des deux nombres fournis.</li>
<li>Testez également le comportement en cas d'arguments incorrects (nombre, type) pour vous assurer que la gestion des erreurs de l'application fonctionne aussi dans l'environnement conteneurisé.</li>
</ul>
</li>
</ol>
<hr />
<p><strong>Livrables Attendus :</strong></p>
<ul>
<li>Le code source modifié du fichier <code>src/main/java/com/maventdd/app/App.java</code>.</li>
<li>Le fichier <code>Dockerfile</code> créé à la racine de votre projet.</li>
</ul>
<p><strong>Critères de Validation :</strong></p>
<ul>
<li>La méthode <code>main</code> de <code>App.java</code> prend correctement en charge les arguments de la ligne de commande, utilise <code>Calculatrice.additionner()</code>, affiche le résultat et gère les erreurs d'arguments lors de l'exécution locale via <code>java -cp ...</code>.</li>
<li>La commande <code>mvn package</code> s'exécute avec succès.</li>
<li>L'image Docker est construite avec succès via <code>docker build .</code> sans erreurs.</li>
<li>Un conteneur démarré à partir de l'image (<code>docker run &lt;nom_image&gt; &lt;arg1&gt; &lt;arg2&gt;</code>) exécute l'application, affiche le résultat correct de l'addition des arguments fournis et gère correctement les erreurs d'arguments.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutoriel-de-la-documentation-officielle-sur-les-github-actions"><a class="header" href="#tutoriel-de-la-documentation-officielle-sur-les-github-actions">Tutoriel de la documentation officielle sur les Github Actions</a></h1>
<ul>
<li><a href="https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images">Publier une image Docker avec Github Actions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercice-pratique-2--publication-automatisée-dimages-docker-avec-github-actions"><a class="header" href="#exercice-pratique-2--publication-automatisée-dimages-docker-avec-github-actions">Exercice Pratique 2 : Publication Automatisée d'Images Docker avec GitHub Actions</a></h1>
<p><strong>Objectif Général :</strong>
Cet exercice a pour but de vous apprendre à automatiser la construction et la publication de vos images Docker vers GitHub Container Registry (GHCR) en utilisant un workflow GitHub Actions, avec un accent sur des conditions de déclenchement spécifiques.</p>
<p><strong>Contexte :</strong>
Vous avez préalablement dockerisé l'application <code>maSuperAppJava</code> et disposez d'un <code>Dockerfile</code> fonctionnel à la racine de votre projet. Votre projet est versionné avec Git et hébergé sur GitHub.</p>
<p><strong>Prérequis :</strong></p>
<ul>
<li>L'exercice 1 ("Évolution et Conteneurisation d'une Application Java") doit être complété avec succès.</li>
<li>Votre projet Java, incluant le <code>Dockerfile</code>, doit être poussé sur votre dépôt GitHub distant.</li>
<li>Vous devez avoir une compréhension de base du fonctionnement des GitHub Actions.</li>
<li><strong>Il est fortement recommandé d'avoir consulté et compris le tutoriel officiel de GitHub : <a href="https://docs.github.com/en/actions/publishing-packages/publishing-docker-images">Publishing Docker images</a>. Cet exercice s'appuie sur les concepts qui y sont présentés.</strong></li>
</ul>
<hr />
<h2 id="instructions--mise-en-place-du-workflow-github-actions"><a class="header" href="#instructions--mise-en-place-du-workflow-github-actions">Instructions : Mise en Place du Workflow GitHub Actions</a></h2>
<p>Vous allez créer un workflow GitHub Actions qui se chargera de construire l'image Docker de votre application et de la publier sur GitHub Container Registry, uniquement lorsque des modifications pertinentes sont apportées aux branches principales.</p>
<ol>
<li>
<p><strong>Création du Fichier de Workflow :</strong></p>
<ul>
<li>Dans votre dépôt GitHub, au sein du répertoire <code>.github/workflows/</code>, créez un nouveau fichier YAML pour votre workflow (par exemple, <code>publish-docker-image.yml</code>).</li>
</ul>
</li>
<li>
<p><strong>Définition du Déclencheur :</strong></p>
<ul>
<li>Configurez le workflow pour qu'il se déclenche <strong>uniquement</strong> dans les conditions suivantes :
<ul>
<li>L'événement est un <code>push</code>.</li>
<li>Le <code>push</code> est effectué sur votre branche de développement principale (généralement <code>main</code> ou <code>master</code>).</li>
<li><strong>ET</strong> au moins un des fichiers modifiés dans ce <code>push</code> est un fichier source Java de votre application (par exemple, les fichiers avec l'extension <code>.java</code> situés dans vos répertoires <code>src/main/java</code> ou <code>src/test/java</code>).</li>
</ul>
</li>
<li>Pour vous aider à configurer ces conditions de déclenchement précises, référez-vous à la documentation GitHub sur les événements qui déclenchent les workflows, en particulier la section concernant l'événement <code>push</code> : <a href="https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#push">GitHub Docs - Events that trigger workflows #push</a>.</li>
</ul>
</li>
<li>
<p><strong>Conception du Job de Publication :</strong></p>
<ul>
<li>Définissez un job unique (par exemple, <code>build-and-publish</code>) qui s'exécutera sur un runner hébergé par GitHub (<code>ubuntu-latest</code> est un choix courant).</li>
<li>Ce job devra comprendre les étapes suivantes :
<ul>
<li><strong>Récupération du Code (<code>checkout</code>) :</strong> Intégrez une étape pour cloner le code source de votre dépôt.</li>
<li><strong>Connexion à GHCR :</strong> Implémentez une étape pour vous authentifier auprès de GitHub Container Registry. Référez-vous à la documentation de l'action <code>docker/login-action</code>. L'authentification utilisera typiquement le <code>GITHUB_TOKEN</code> fourni par GitHub Actions.</li>
<li><strong>Extraction des Métadonnées de l'Image :</strong> Pour taguer votre image de manière dynamique et cohérente, utilisez une action comme <code>docker/metadata-action</code>. Configurez-la pour générer des tags pertinents pour les images construites à partir des branches principales (par exemple, un tag <code>latest</code>, le nom de la branche, ou le SHA du commit).</li>
<li><strong>Construction et Publication de l'Image :</strong> Ajoutez l'étape finale pour construire votre image Docker à partir de votre <code>Dockerfile</code> et la pousser (publier) vers GitHub Container Registry. L'action <code>docker/build-push-action</code> est conçue pour cela.
<ul>
<li>Assurez-vous que le nom de l'image respecte la convention de GHCR (généralement <code>ghcr.io/VOTRE_NOM_UTILISATEUR_OU_ORGANISATION/NOM_DE_VOTRE_DEPOT:TAG</code> ou similaire, que l'action de métadonnées peut aider à formuler).</li>
<li>Configurez cette étape pour utiliser les tags générés par l'action de métadonnées.</li>
<li>Spécifiez que le <code>push</code> doit être effectué (<code>push: true</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Commit et Push du Workflow :</strong></p>
<ul>
<li>Une fois votre fichier de workflow rédigé, commitez-le et poussez-le vers votre dépôt GitHub.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="validation-"><a class="header" href="#validation-">Validation :</a></h2>
<ol>
<li>
<p><strong>Test des Conditions de Déclenchement :</strong></p>
<ul>
<li>Après avoir poussé votre workflow, effectuez les tests suivants pour valider sa logique de déclenchement :
<ul>
<li><strong>Test 1 :</strong> Modifiez un fichier non-Java (par exemple, <code>README.md</code>) et poussez cette modification sur votre branche principale (<code>main</code> ou <code>master</code>). Le workflow <strong>ne devrait pas</strong> se déclencher.</li>
<li><strong>Test 2 :</strong> Modifiez un fichier source Java (par exemple, <code>App.java</code> ou <code>Calculatrice.java</code>) et poussez cette modification sur votre branche principale. Le workflow <strong>devrait</strong> se déclencher.</li>
<li><strong>Test 3 :</strong> Créez une nouvelle branche, modifiez un fichier source Java et poussez cette modification sur cette nouvelle branche. Le workflow <strong>ne devrait pas</strong> se déclencher.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Surveillance de l'Exécution (si déclenché) :</strong></p>
<ul>
<li>Si le workflow s'est déclenché (Test 2), rendez-vous dans l'onglet "Actions" de votre dépôt GitHub.</li>
<li>Observez l'exécution de votre workflow. Vérifiez que chaque étape se déroule comme prévu et que le workflow se termine avec succès.</li>
</ul>
</li>
<li>
<p><strong>Vérification sur GHCR :</strong></p>
<ul>
<li>Accédez à la section "Packages" de votre profil utilisateur ou de votre organisation sur GitHub.</li>
<li>Confirmez que votre image Docker y a été publiée avec les bons tags (par exemple, <code>latest</code>, le SHA du commit, ou le nom de la branche).</li>
</ul>
</li>
<li>
<p><strong>(Recommandé) Test de l'Image Publiée :</strong></p>
<ul>
<li>Sur votre machine locale (ou tout autre environnement ayant accès à internet et Docker), essayez de tirer l'image fraîchement publiée depuis GHCR :
<code>docker pull ghcr.io/VOTRE_NOM_UTILISATEUR/NOM_IMAGE:TAG</code></li>
<li>Exécutez un conteneur à partir de cette image pour confirmer qu'elle est fonctionnelle :
<code>docker run --rm ghcr.io/VOTRE_NOM_UTILISATEUR/NOM_IMAGE:TAG &lt;argument1&gt; &lt;argument2&gt;</code>
(N'oubliez pas les arguments si votre application en attend).</li>
</ul>
</li>
</ol>
<hr />
<p><strong>Livrables Attendus :</strong></p>
<ul>
<li>Le fichier YAML du workflow GitHub Actions (par exemple, <code>.github/workflows/publish-docker-image.yml</code>) commité et poussé sur votre dépôt.</li>
</ul>
<p><strong>Critères de Validation :</strong></p>
<ul>
<li>Le workflow GitHub Actions se déclenche <strong>uniquement</strong> lorsque des fichiers source Java sont modifiés lors d'un <code>push</code> sur la branche <code>main</code> (ou <code>master</code>).</li>
<li>Toutes les étapes du workflow (checkout, login, build, push) s'exécutent avec succès dans l'onglet "Actions" lorsque le workflow est correctement déclenché.</li>
<li>L'image Docker de votre application est visible et accessible dans la section "Packages" de votre dépôt sur GitHub Container Registry, avec des tags appropriés reflétant la source de la construction (par exemple, <code>latest</code>, SHA du commit, nom de la branche).</li>
<li>L'image Docker tirée depuis GHCR peut être exécutée avec succès et l'application fonctionne comme prévu.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="travail-pratique--documenter-votre-projet-java-avec-doxygen"><a class="header" href="#travail-pratique--documenter-votre-projet-java-avec-doxygen">Travail Pratique : Documenter Votre Projet Java avec Doxygen</a></h1>
<p><strong>Objectif Général :</strong>
Ce travail pratique a pour objectif de vous initier à la génération de documentation professionnelle pour votre code Java en utilisant Doxygen. Vous apprendrez à commenter votre code efficacement, à configurer Doxygen, et à générer une documentation HTML navigable pour votre projet <code>maStringUtilsApp</code>.</p>
<hr />
<h2 id="introduction-à-doxygen"><a class="header" href="#introduction-à-doxygen">Introduction à Doxygen</a></h2>
<p><strong>Qu'est-ce que Doxygen ?</strong>
Doxygen est un outil extrêmement populaire et puissant utilisé pour générer de la documentation directement à partir du code source commenté. Il analyse vos fichiers de code, extrait les commentaires formatés d'une manière spécifique (pour Java, il comprend nativement les commentaires Javadoc <code>/** ... */</code>), ainsi que la structure de votre code (classes, méthodes, etc.), et produit une documentation complète dans divers formats (HTML, PDF, LaTeX, etc.).</p>
<p><strong>Pourquoi utiliser Doxygen ?</strong></p>
<ul>
<li><strong>Documentation Synchronisée :</strong> La documentation est générée depuis le code, elle a donc plus de chances de rester à jour par rapport à une documentation écrite manuellement et séparément.</li>
<li><strong>Compréhension du Code :</strong> Une bonne documentation aide les autres développeurs (et vous-même dans le futur !) à comprendre rapidement l'architecture, le fonctionnement des classes et des méthodes de votre projet.</li>
<li><strong>Professionnalisme :</strong> Fournir une documentation claire et bien structurée est une marque de professionnalisme et facilite la maintenance et l'évolution du projet.</li>
<li><strong>Automatisation :</strong> La génération de la documentation peut être intégrée dans des processus d'Intégration Continue (CI/CD).</li>
</ul>
<p><strong>Comment ça fonctionne (en bref) ?</strong></p>
<ol>
<li>Vous <strong>annotez votre code Java</strong> avec des commentaires de style Javadoc, en utilisant des balises spéciales Doxygen (comme <code>@param</code>, <code>@return</code>, <code>@brief</code>) pour décrire les éléments de votre code.</li>
<li>Vous <strong>configurez Doxygen</strong> à l'aide d'un fichier de configuration (nommé <code>Doxyfile</code>) qui lui indique quels fichiers analyser, où sauvegarder la documentation, le nom du projet, et de nombreuses autres options.</li>
<li>Vous <strong>exécutez Doxygen</strong>, qui lit votre code et le <code>Doxyfile</code> pour produire la documentation dans le format désiré.</li>
</ol>
<p><strong>Ressources Officielles (fortement recommandées) :</strong></p>
<ul>
<li><strong>Pour bien démarrer avec Doxygen :</strong> <a href="https://www.doxygen.nl/manual/starting.html">Manuel Officiel - Starting Point</a></li>
<li><strong>Comment documenter le code pour Doxygen :</strong> <a href="https://www.doxygen.nl/manual/docblocks.html">Manuel Officiel - Documenting the code</a></li>
</ul>
<p><strong>Contexte de ce TP :</strong>
Nous allons appliquer Doxygen au projet <code>maStringUtilsApp</code> (dont le <code>groupId</code> est <code>com.formation.stringutils</code> et l'<code>artifactId</code> est <code>maStringUtilsApp</code>, comme vu dans le TP "De Maven Local à l'Intégration Continue"). Vous documenterez la classe <code>StringUtils.java</code> et ses méthodes (<code>renverser</code>, <code>estPalindrome</code>, <code>compterVoyelles</code>) que vous avez développées. Nous supposerons donc que votre code se trouve dans le package <code>com.formation.stringutils</code>.</p>
<p><strong>Prérequis :</strong></p>
<ul>
<li>Le projet <code>maStringUtilsApp</code> fonctionnel, avec la classe <code>StringUtils</code> dans le package <code>com.formation.stringutils</code>.</li>
<li>Doxygen installé sur votre machine. (Si ce n'est pas fait, consultez le site officiel de Doxygen. Pour les diagrammes, Graphviz est aussi recommandé).</li>
</ul>
<hr />
<h2 id="exercice-1--documentation-de-base-des-méthodes"><a class="header" href="#exercice-1--documentation-de-base-des-méthodes">Exercice 1 : Documentation de Base des Méthodes</a></h2>
<p><strong>Objectif :</strong> Apprendre à ajouter des commentaires Doxygen/Javadoc essentiels aux méthodes de votre classe <code>StringUtils</code> et générer une première documentation.</p>
<ol>
<li>
<p><strong>Commentez les méthodes de <code>StringUtils.java</code> :</strong>
Ouvrez votre fichier <code>src/main/java/com/formation/stringutils/StringUtils.java</code> et ajoutez ou complétez les commentaires Javadoc pour chaque méthode (<code>renverser</code>, <code>estPalindrome</code>, <code>compterVoyelles</code>).</p>
<pre><code class="language-java">// Fichier : src/main/java/com/formation/stringutils/StringUtils.java
package com.formation.stringutils;

public class StringUtils {

    /**
     * @brief Renverse une chaîne de caractères.
     * Cette méthode prend une chaîne en entrée et retourne sa version inversée.
     * Si la chaîne d'entrée est null, la méthode retourne null.
     *
     * @param chaine La chaîne de caractères à renverser.
     * @return La chaîne renversée, ou null si la chaîne d'entrée est null.
     */
    public String renverser(String chaine) {
        if (chaine == null) return null;
        return new StringBuilder(chaine).reverse().toString();
    }

    /**
     * @brief Vérifie si une chaîne est un palindrome.
     * Un palindrome est un mot ou une phrase qui se lit de la même manière dans les deux sens.
     * Cette méthode ignore la casse et les espaces lors de la vérification.
     *
     * @param chaine La chaîne à vérifier.
     * @return true si la chaîne est un palindrome (en ignorant casse et espaces), false sinon. Retourne false pour une chaîne null.
     */
    public boolean estPalindrome(String chaine) {
        if (chaine == null) return false;
        String chaineNettoyee = chaine.replaceAll("\\s+", "").toLowerCase();
        String chaineRenversee = new StringBuilder(chaineNettoyee).reverse().toString();
        return chaineNettoyee.equals(chaineRenversee);
    }

    /**
     * @brief Compte le nombre de voyelles dans une chaîne.
     * Les voyelles prises en compte sont 'a', 'e', 'i', 'o', 'u', insensibles à la casse.
     *
     * @param chaine La chaîne dans laquelle compter les voyelles.
     * @return Le nombre total de voyelles trouvées dans la chaîne. Retourne 0 si la chaîne est null ou vide.
     */
    public int compterVoyelles(String chaine) {
        if (chaine == null || chaine.isEmpty()) {
            return 0;
        }
        int count = 0;
        String voyelles = "aeiouAEIOU";
        for (char c : chaine.toCharArray()) {
            if (voyelles.indexOf(c) != -1) {
                count++;
            }
        }
        return count;
    }
}
</code></pre>
<p><strong>Explication des balises Doxygen/Javadoc utilisées :</strong></p>
<ul>
<li><code>@brief &lt;description&gt;</code> : Fournit une description courte et concise de l'élément (ici, une méthode). Apparaît souvent en résumé.</li>
<li><code>@param &lt;nom_param&gt; &lt;description&gt;</code> : Décrit un paramètre spécifique de la méthode, en précisant son nom et son rôle.</li>
<li><code>@return &lt;description&gt;</code> : Explique ce que la méthode retourne.</li>
<li><code>@throws &lt;TypeException&gt; &lt;description&gt;</code> (ou <code>@exception</code>) : Documente les exceptions qu'une méthode est susceptible de lever et dans quelles circonstances (non utilisé dans cet exemple simple de <code>StringUtils</code>, mais bon à savoir).</li>
</ul>
</li>
<li>
<p><strong>Génération du fichier de configuration <code>Doxyfile</code> :</strong></p>
<ul>
<li>Dans votre terminal, naviguez à la racine de votre projet <code>maStringUtilsApp</code>.</li>
<li>Exécutez la commande :
<pre><code class="language-bash">doxygen -g
</code></pre>
Cela crée un fichier de configuration nommé <code>Doxyfile</code>.
<blockquote>
<p>Vous pouvez également lancer la commande : <code>doxygen -g NomDeVotreDoxyfile</code> pour créer un fichier de configuration avec un nom que vous choisissez. Si le fichier <code>Doxyfile</code> ou <code>NomDeVotreDoxyfile</code> existe déjà, Doxygen le renommera en ajoutant <code>.bak</code> avant d'en créer un nouveau.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Configuration du <code>Doxyfile</code> :</strong>
Ouvrez le fichier <code>Doxyfile</code> avec un éditeur de texte et modifiez (ou décommentez et modifiez) les options suivantes :</p>
<ul>
<li><code>PROJECT_NAME = "Documentation du Projet maStringUtilsApp"</code>
<ul>
<li><strong>Rôle :</strong> Définit le titre principal de votre documentation générée.</li>
</ul>
</li>
<li><code>OUTPUT_DIRECTORY = docs_stringutils</code>
<ul>
<li><strong>Rôle :</strong> Spécifie le nom du répertoire où Doxygen placera les fichiers de documentation générés.</li>
</ul>
</li>
<li><code>INPUT = ./src/main/java</code>
<ul>
<li><strong>Rôle :</strong> Indique à Doxygen le(s) dossier(s) ou fichier(s) contenant le code source à analyser. Ici, on pointe vers la racine des sources Java de Maven.</li>
</ul>
</li>
<li><code>RECURSIVE = YES</code>
<ul>
<li><strong>Rôle :</strong> Si mis à <code>YES</code>, Doxygen explorera les sous-dossiers des chemins spécifiés dans <code>INPUT</code>. Essentiel pour les projets Java structurés en packages.</li>
</ul>
</li>
<li><code>FILE_PATTERNS = *.java</code>
<ul>
<li><strong>Rôle :</strong> Permet de filtrer les types de fichiers à analyser. Ici, on se concentre sur les fichiers Java.</li>
</ul>
</li>
<li><code>OPTIMIZE_OUTPUT_JAVA = YES</code>
<ul>
<li><strong>Rôle :</strong> Active des optimisations et des analyses spécifiques au langage Java, ce qui peut améliorer la pertinence et la présentation de la documentation pour les projets Java.</li>
</ul>
</li>
<li><code>JAVADOC_AUTOBRIEF = YES</code>
<ul>
<li><strong>Rôle :</strong> Si <code>YES</code>, Doxygen considérera automatiquement la première phrase d'un commentaire Javadoc (avant le premier point suivi d'un espace, ou avant une ligne vide) comme une description brève (<code>@brief</code>), même si la balise <code>@brief</code> n'est pas explicitement présente.</li>
</ul>
</li>
<li><code>EXTRACT_ALL = NO</code>
<ul>
<li><strong>Rôle :</strong> Si <code>NO</code>, Doxygen ne documentera que les éléments de code qui possèdent des commentaires Doxygen/Javadoc. <code>NO</code> est généralement préférable pour une documentation d'API ciblée.</li>
</ul>
</li>
<li><code>EXTRACT_PRIVATE = NO</code>
<ul>
<li><strong>Rôle :</strong> Si <code>NO</code>, les membres privés des classes ne seront pas inclus dans la documentation.</li>
</ul>
</li>
<li><code>EXTRACT_STATIC = YES</code>
<ul>
<li><strong>Rôle :</strong> Assure que les membres statiques sont inclus dans la documentation (important pour notre classe <code>StringUtils</code> si ses méthodes sont statiques, sinon adaptez).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Génération de la documentation :</strong></p>
<ul>
<li>Toujours dans votre terminal, à la racine du projet, exécutez :
<pre><code class="language-bash">doxygen 
</code></pre>
<blockquote>
<p>Si vous avez utilisé un nom personnalisé pour votre Doxyfile, lancez : <code>doxygen NomDeVotreDoxyfile</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Consultation de la documentation :</strong></p>
<ul>
<li>Ouvrez le fichier <code>docs_stringutils/html/index.html</code> (ou le chemin que vous avez défini dans <code>OUTPUT_DIRECTORY</code>) dans un navigateur web.</li>
<li>Explorez la documentation : vous devriez trouver votre classe <code>StringUtils</code> et voir comment vos commentaires ont été transformés en une documentation structurée pour chaque méthode.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="exercice-2--documentation-de-la-classe-stringutils"><a class="header" href="#exercice-2--documentation-de-la-classe-stringutils">Exercice 2 : Documentation de la Classe <code>StringUtils</code></a></h2>
<p><strong>Objectif :</strong> Ajouter une documentation au niveau de la classe <code>StringUtils</code> elle-même.</p>
<ol>
<li>
<p><strong>Commentez la classe <code>StringUtils</code> :</strong>
Ajoutez un commentaire Javadoc juste avant la déclaration de la classe <code>StringUtils</code> dans votre fichier <code>src/main/java/com/formation/stringutils/StringUtils.java</code>.</p>
<pre><code class="language-java">// Fichier : src/main/java/com/formation/stringutils/StringUtils.java
package com.formation.stringutils;

/**
 * @brief Fournit une collection de méthodes utilitaires pour la manipulation de chaînes de caractères.
 *
 * Cette classe offre diverses fonctionnalités (statiques ou non, selon votre implémentation) 
 * pour des opérations courantes sur les chaînes, telles que le renversement, 
 * la vérification de palindromes, et le comptage de voyelles.
 *
 * @author Votre Nom / Nom de l'Équipe
 * @version 1.0
 * @date 14 Mai 2025 
 */
public class StringUtils {
    // ... (vos méthodes commentées de l'exercice 1) ...
}
</code></pre>
<p><strong>Nouvelles balises (ou rappel de leur usage contextuel) :</strong></p>
<ul>
<li><code>@author &lt;nom&gt;</code> : Identifie l'auteur de la classe.</li>
<li><code>@version &lt;texte_version&gt;</code> : Spécifie la version de la classe ou du module.</li>
<li><code>@date &lt;date&gt;</code> : Indique une date pertinente (création, dernière modification).</li>
</ul>
</li>
<li>
<p><strong>Adaptez le <code>Doxyfile</code> (si nécessaire) :</strong>
Normalement, les configurations de l'exercice 1 devraient suffire. Le <code>PROJECT_NAME</code> et <code>OUTPUT_DIRECTORY</code> peuvent rester les mêmes ou être adaptés si vous souhaitez des sorties séparées pour chaque étape d'apprentissage.</p>
</li>
<li>
<p><strong>Régénérez la documentation :</strong></p>
<pre><code class="language-bash">doxygen
</code></pre>
</li>
<li>
<p><strong>Vérifiez le résultat :</strong>
Rafraîchissez <code>docs_stringutils/html/index.html</code> dans votre navigateur. En naviguant vers la classe <code>StringUtils</code> (via l'onglet "Classes" par exemple), vous devriez maintenant voir la description que vous avez ajoutée pour la classe elle-même.</p>
</li>
</ol>
<hr />
<h2 id="exercice-3--création-dune-page-daccueil-personnalisée"><a class="header" href="#exercice-3--création-dune-page-daccueil-personnalisée">Exercice 3 : Création d'une Page d'Accueil Personnalisée</a></h2>
<p><strong>Objectif :</strong> Remplacer la page d'accueil par défaut de Doxygen par une page personnalisée écrite en Markdown, pour mieux présenter votre projet <code>maStringUtilsApp</code>.</p>
<ol>
<li>
<p><strong>Créez un fichier <code>mainpage.md</code> :</strong>
À la racine de votre projet <code>maStringUtilsApp</code>, créez un fichier nommé <code>mainpage.md</code>.</p>
<pre><code class="language-markdown"># Documentation du Projet `maStringUtilsApp`

Bienvenue sur la documentation officielle de `maStringUtilsApp` !

Ce projet a été développé dans le cadre de la formation CI/CD et met en œuvre une classe utilitaire Java, `StringUtils`, pour diverses opérations sur les chaînes de caractères. Il illustre également l'utilisation de Maven, des tests unitaires avec JUnit, et la génération de cette documentation avec Doxygen.

## Contenu Principal

La fonctionnalité clé est fournie par la classe `com.formation.stringutils.StringUtils`. 
Vous pouvez explorer :
* La [Liste complète des Classes](./annotated.html) pour accéder directement à `StringUtils`.
* La [Liste des Paquets](./namespaces.html) pour voir la structure du package.

## Fonctionnalités Implémentées

La classe `StringUtils` inclut les méthodes suivantes :
-   `renverser(String)`
-   `estPalindrome(String)`
-   `compterVoyelles(String)`

Consultez leur documentation détaillée pour plus d'informations.

---
*Cette documentation a été générée avec Doxygen.*
</code></pre>
</li>
<li>
<p><strong>Modifiez le <code>Doxyfile</code> :</strong></p>
<ul>
<li>Vous pouvez affiner <code>PROJECT_NAME</code> si vous le souhaitez : <code>PROJECT_NAME = "maStringUtilsApp - Documentation Officielle"</code></li>
<li>Si vous voulez une sortie séparée pour cette version : <code>OUTPUT_DIRECTORY = docs_final_stringutils</code></li>
<li>Ajoutez <code>mainpage.md</code> à la directive <code>INPUT</code>. Elle peut contenir plusieurs entrées séparées par des espaces. Assurez-vous que le chemin vers vos sources Java est toujours présent :
<code>INPUT = ./src/main/java ./mainpage.md</code></li>
<li>Indiquez à Doxygen d'utiliser ce fichier Markdown comme page principale :
<code>USE_MDFILE_AS_MAINPAGE = mainpage.md</code>
<ul>
<li><strong>Rôle :</strong> Cette option cruciale dit à Doxygen de prendre le contenu du fichier Markdown spécifié et de l'utiliser comme contenu pour la page <code>index.html</code> générée.</li>
</ul>
</li>
<li>Vérifiez que <code>MARKDOWN_SUPPORT = YES</code> (généralement activé par défaut).
<ul>
<li><strong>Rôle :</strong> Permet à Doxygen de parser et de convertir correctement la syntaxe Markdown en HTML.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Générez la documentation :</strong></p>
<pre><code class="language-bash">doxygen
</code></pre>
</li>
<li>
<p><strong>Vérifiez le résultat :</strong>
Ouvrez <code>docs_final_stringutils/html/index.html</code> (ou le dossier de sortie que vous avez configuré). Vous devriez être accueilli par votre page personnalisée !</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="travail-pratique--automatisation-de-la-génération-de-documentation-doxygen-avec-github-actions"><a class="header" href="#travail-pratique--automatisation-de-la-génération-de-documentation-doxygen-avec-github-actions">Travail Pratique : Automatisation de la Génération de Documentation Doxygen avec GitHub Actions</a></h1>
<p><strong>Objectif Général :</strong>
L'objectif de ce travail pratique est d'intégrer la génération de votre documentation Doxygen (créée pour le projet <code>maStringUtilsApp</code>) dans votre pipeline d'Intégration Continue existant avec GitHub Actions. La documentation générée sera ensuite archivée en tant qu'artefact de build, la rendant accessible après chaque exécution du workflow.</p>
<p><strong>Contexte :</strong>
Vous avez déjà configuré Doxygen pour votre projet Java <code>maStringUtilsApp</code> (basé sur le <code>groupId: com.formation.stringutils</code>), vous disposez d'un <code>Doxyfile</code> fonctionnel et votre code source est commenté. Vous avez également un workflow GitHub Actions qui compile et teste ce projet. Nous allons maintenant enrichir ce workflow.</p>
<p><strong>Prérequis :</strong></p>
<ul>
<li>Les exercices précédents sur la configuration et la génération de documentation Doxygen pour <code>maStringUtilsApp</code> ont été complétés avec succès (un <code>Doxyfile</code> est présent et fonctionnel à la racine du projet).</li>
<li>Votre projet <code>maStringUtilsApp</code> est hébergé sur un dépôt GitHub.</li>
<li>Un workflow GitHub Actions fonctionnel existe déjà pour ce projet, capable de compiler le code Java et d'exécuter les tests (par exemple, avec Maven via <code>mvn package</code> ou <code>mvn test</code>).</li>
<li>Familiarité avec la syntaxe des workflows GitHub Actions et l'utilisation de <code>actions/upload-artifact</code>.</li>
</ul>
<hr />
<h2 id="instructions--intégration-de-doxygen-dans-le-workflow-ci"><a class="header" href="#instructions--intégration-de-doxygen-dans-le-workflow-ci">Instructions : Intégration de Doxygen dans le Workflow CI</a></h2>
<p>Vous allez modifier votre workflow GitHub Actions existant pour y inclure les étapes de génération et d'archivage de la documentation Doxygen.</p>
<ol>
<li>
<p><strong>Modification du Workflow Existant :</strong></p>
<ul>
<li>Ouvrez le fichier YAML de votre workflow CI actuel (celui qui s'occupe de la compilation et des tests de <code>maStringUtilsApp</code>, souvent dans <code>.github/workflows/</code>).</li>
<li>Repérez le job qui effectue la compilation et les tests Java. La génération de la documentation Doxygen devrait logiquement s'effectuer <strong>après</strong> que ces étapes se soient terminées avec succès, pour s'assurer que la documentation est générée pour une version valide et testée du code.</li>
</ul>
</li>
<li>
<p><strong>Ajout des Étapes pour Doxygen dans le Job Existant :</strong>
Au sein du job identifié, après les étapes de compilation et de test, ajoutez les nouvelles étapes suivantes :</p>
<ul>
<li>
<p><strong>Étape 1 : Installation de Doxygen (et Graphviz) sur le Runner</strong></p>
<ul>
<li>Ajoutez une commande <code>run</code> pour installer Doxygen et Graphviz. Graphviz est nécessaire si vous souhaitez que Doxygen génère des diagrammes (comme les graphes de classes, etc.).</li>
<li>Sur les runners <code>ubuntu-latest</code> fournis par GitHub, vous pouvez généralement utiliser <code>apt-get</code> pour cela. Pensez à faire un <code>sudo apt-get update</code> avant.
<em>Indice : <code>sudo apt-get update &amp;&amp; sudo apt-get install -y doxygen graphviz</code></em></li>
</ul>
</li>
<li>
<p><strong>Étape 2 : Génération de la Documentation Doxygen</strong></p>
<ul>
<li>Ajoutez une commande <code>run</code> pour exécuter Doxygen.</li>
<li>Cette commande doit utiliser le <code>Doxyfile</code> que vous avez configuré à la racine de votre projet.</li>
<li>Assurez-vous que cette commande est exécutée depuis le répertoire racine de votre projet (là où se trouve le <code>Doxyfile</code>). C'est généralement le cas par défaut après l'action <code>actions/checkout</code>.
<em>Indice : la commande est simplement <code>doxygen Doxyfile</code> ou <code>doxygen</code> si le fichier s'appelle <code>Doxyfile</code>.</em></li>
</ul>
</li>
<li>
<p><strong>Étape 3 : Archivage de la Documentation Générée</strong></p>
<ul>
<li>Utilisez l'action <code>actions/upload-artifact@v3</code> (ou une version plus récente si disponible) pour sauvegarder le répertoire contenant votre documentation HTML générée.</li>
<li><strong><code>name</code> :</strong> Donnez un nom significatif à votre artefact (par exemple, <code>documentation-html-stringutils</code>).</li>
<li><strong><code>path</code> :</strong> Spécifiez le chemin vers le répertoire où Doxygen a généré la documentation. Ce chemin doit correspondre à la valeur de <code>OUTPUT_DIRECTORY</code> que vous avez définie dans votre <code>Doxyfile</code> (par exemple, <code>docs_final_stringutils</code> ou <code>docs_stringutils</code> selon ce que vous aviez configuré dans les exercices Doxygen précédents).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Commit et Push des Modifications :</strong></p>
<ul>
<li>Sauvegardez les modifications apportées à votre fichier de workflow.</li>
<li>Commitez et poussez ces changements sur votre dépôt GitHub.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="validation--1"><a class="header" href="#validation--1">Validation :</a></h2>
<ol>
<li>
<p><strong>Surveillance de l'Exécution du Workflow :</strong></p>
<ul>
<li>Rendez-vous dans l'onglet "Actions" de votre dépôt GitHub.</li>
<li>Observez l'exécution du workflow déclenchée par votre dernier push.</li>
<li>Vérifiez que les nouvelles étapes (installation de Doxygen, génération de la documentation, archivage de l'artefact) s'exécutent sans erreur.</li>
</ul>
</li>
<li>
<p><strong>Vérification de l'Artefact :</strong></p>
<ul>
<li>Une fois le workflow terminé avec succès, accédez à la page de résumé de cette exécution.</li>
<li>Dans la section "Artifacts", vous devriez trouver l'artefact que vous avez nommé (par exemple, <code>documentation-html-stringutils</code>).</li>
<li>Téléchargez cet artefact.</li>
</ul>
</li>
<li>
<p><strong>Consultation de la Documentation Archivée :</strong></p>
<ul>
<li>Décompressez l'artefact téléchargé sur votre machine locale.</li>
<li><strong>Astuce pour une meilleure visualisation :</strong> Ouvrez un terminal, naviguez avec <code>cd</code> jusqu'au répertoire racine de votre documentation HTML décompressée (celui qui contient <code>index.html</code>), puis lancez un serveur web local simple avec Python 3 :
<pre><code class="language-bash">python3 -m http.server 8000
</code></pre>
Ouvrez ensuite <code>http://localhost:8000</code> dans votre navigateur. Pour arrêter le serveur, retournez au terminal et faites <code>Ctrl+C</code>.</li>
<li>Sinon, ouvrez directement le fichier <code>index.html</code> (ou la page principale de votre documentation) dans un navigateur.</li>
<li>Vérifiez que la documentation est complète et correspond à ce que vous attendiez.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="optionnel-défi-supplémentaire--déploiement-sur-github-pages"><a class="header" href="#optionnel-défi-supplémentaire--déploiement-sur-github-pages">(Optionnel) Défi Supplémentaire : Déploiement sur GitHub Pages</a></h2>
<p>Si vous êtes à l'aise et que vous avez déjà travaillé avec le déploiement sur GitHub Pages</p>
<ul>
<li>Adaptez votre workflow pour qu'en plus de créer un artefact, il déploie le contenu du répertoire de documentation Doxygen sur la branche <code>gh-pages</code> de votre dépôt.</li>
<li>Vous pourriez utiliser des actions populaires comme <code>peaceiris/actions-gh-pages@v3</code> ou une autre de votre choix.</li>
<li>N'oubliez pas de configurer correctement votre dépôt GitHub pour servir les GitHub Pages depuis la branche <code>gh-pages</code>.</li>
</ul>
<blockquote>
<p>Vous pouvez vous aider de la <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site">documentation</a> de Github, pour realiser ces etapes</p>
</blockquote>
<hr />
<p><strong>Livrables Attendus :</strong></p>
<ul>
<li>Le fichier YAML de votre workflow GitHub Actions modifié, incluant les étapes pour Doxygen.</li>
</ul>
<p><strong>Critères de Validation :</strong></p>
<ul>
<li>Le workflow GitHub Actions s'exécute avec succès après l'intégration des étapes Doxygen.</li>
<li>Les logs du workflow confirment l'installation de Doxygen et l'exécution de la commande de génération sans erreur.</li>
<li>Un artefact contenant la documentation HTML complète est créé et peut être téléchargé depuis la page de résumé du workflow.</li>
<li>La documentation HTML contenue dans l'artefact est valide et consultable.</li>
<li><strong>(Pour le défi optionnel)</strong> La documentation Doxygen est accessible en ligne via GitHub Pages en navigant vers <code>https://nomUtilisateur.github.io/nomRepo</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examen-final-certifiant--pipeline-cicd-from-scratch"><a class="header" href="#examen-final-certifiant--pipeline-cicd-from-scratch">Examen Final Certifiant : Pipeline CI/CD "From Scratch"</a></h1>
<p><strong>Durée :</strong> 4 heures<br />
<strong>Format :</strong> En équipe de 3 personnes<br />
<strong>Objectif :</strong> Mettre en œuvre une chaîne d'intégration et de déploiement continu complète pour une nouvelle application Java.</p>
<hr />
<h2 id="instructions-générales"><a class="header" href="#instructions-générales">Instructions Générales</a></h2>
<ul>
<li><strong>Collaboration :</strong> Vous travaillerez en équipe de trois. La communication et la répartition des tâches au sein de l'équipe sont essentielles. Utilisez Git et GitHub pour collaborer efficacement.</li>
<li><strong>Ressources Autorisées :</strong> Cet examen est à "livre ouvert". Vous pouvez consulter vos notes personnelles, les TPs précédents, la documentation officielle des outils (Java, Maven, Git, Docker, Doxygen, GitHub Actions), et des ressources en ligne (Stack Overflow, blogs techniques, etc.). <strong>L'utilisation d'IA génératives pour produire directement du code ou des configurations de workflow est interdite.</strong> L'objectif est d'évaluer votre capacité à appliquer les connaissances acquises.</li>
<li><strong>Livrables Finaux :</strong>
<ul>
<li>Un dépôt GitHub contenant le projet fonctionnel, le <code>Dockerfile</code>, le <code>Doxyfile</code>, le workflow GitHub Actions,</li>
<li>Une image Docker de l'application publiée sur GitHub Container Registry (GHCR).</li>
<li>La documentation Doxygen devra être disponible en tant qu'artefact du workflow.</li>
<li>Un <code>README.md</code> qui explique comment lancer la documentation</li>
</ul>
</li>
</ul>
<hr />
<h2 id="scénario--le-gestionnaire-de-micro-tâches-taskmaster-lite"><a class="header" href="#scénario--le-gestionnaire-de-micro-tâches-taskmaster-lite">Scénario : Le Gestionnaire de Micro-Tâches "TaskMaster Lite"</a></h2>
<p>Votre équipe est chargée de développer "TaskMaster Lite", une application en ligne de commande ultra-simple pour gérer une liste de tâches personnelles. Pour cette première version, l'application devra permettre d'ajouter des tâches et de lister toutes les tâches enregistrées. Les tâches seront stockées en mémoire pour la durée de vie de l'application (pas de persistance de données requise pour cet examen).</p>
<p><strong>Fonctionnalités minimales attendues pour l'application Java :</strong></p>
<ol>
<li><strong>Ajouter une tâche :</strong> L'utilisateur peut entrer une commande pour ajouter une description de tâche (ex: <code>add "Faire les courses"</code>).</li>
<li><strong>Lister les tâches :</strong> L'utilisateur peut entrer une commande pour afficher toutes les tâches actuellement enregistrées, chacune avec un identifiant simple (ex: <code>list</code>).</li>
</ol>
<hr />
<h2 id="tâches-à-réaliser"><a class="header" href="#tâches-à-réaliser">Tâches à Réaliser</a></h2>
<p>Votre mission est de développer <code>TaskMaster Lite</code> et de mettre en place son pipeline CI/CD. Voici les grandes étapes :</p>
<h3 id="phase-1--initialisation-conception-et-développement-local-focus--git-java-maven-tdd"><a class="header" href="#phase-1--initialisation-conception-et-développement-local-focus--git-java-maven-tdd">Phase 1 : Initialisation, Conception et Développement Local (Focus : Git, Java, Maven, TDD)</a></h3>
<ol>
<li>
<p><strong>Coordination &amp; Dépôt GitHub (Responsable d'équipe désigné ou première personne à agir) :</strong></p>
<ul>
<li>Créez un <strong>nouveau dépôt GitHub public</strong> pour votre projet <code>TaskMasterLite-[NomEquipe]</code>.</li>
<li>Ajoutez les deux autres membres de l'équipe comme collaborateurs sur le dépôt.</li>
<li>Tous les membres doivent cloner le dépôt.</li>
</ul>
</li>
<li>
<p><strong>Stratégie de Branches &amp; <code>.gitignore</code> (En équipe) :</strong></p>
<ul>
<li>Mettez en place une branche <code>develop</code> à partir de <code>main</code>.</li>
<li>Convenez d'une stratégie pour les branches de fonctionnalités (ex: <code>feature/add-task</code>, <code>feature/list-tasks</code>).</li>
<li>Créez et configurez un fichier <code>.gitignore</code> adapté pour un projet Java Maven (ignorant les fichiers <code>target/</code>, logs, fichiers IDE, etc.). Commitez-le.</li>
</ul>
</li>
<li>
<p><strong>Mise en Place du Projet Java Maven (From Scratch) :</strong></p>
<ul>
<li>Initialisez votre projet en tant que projet Maven. Vous pouvez utiliser <code>mvn archetype:generate</code> (par exemple, avec <code>maven-archetype-quickstart</code> et l'adapter) ou créer la structure de dossiers (<code>src/main/java</code>, <code>src/test/java</code>) et le fichier <code>pom.xml</code> manuellement.</li>
<li>Configurez le <code>pom.xml</code> pour :
<ul>
<li>Utiliser Java 17.</li>
<li>Inclure la dépendance JUnit 5 (<code>junit-jupiter-api</code> et <code>junit-jupiter-engine</code>).</li>
<li>Configurer le plugin Maven Surefire pour l'exécution des tests (s'il n'est pas déjà configuré par l'archétype).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Développement des Fonctionnalités avec TDD-Light :</strong></p>
<ul>
<li>Pour la fonctionnalité "Ajouter une tâche" :
<ul>
<li>Créez une classe de test (ex: <code>TaskManagerTest.java</code>).</li>
<li>Écrivez une méthode de test qui vérifie l'ajout d'une tâche à une liste (par exemple, la taille de la liste augmente, la tâche ajoutée est retrouvable). Ce test doit échouer initialement.</li>
<li>Créez la classe (ex: <code>TaskManager.java</code>) et la méthode nécessaire (ex: <code>void addTask(String description)</code>) avec une implémentation minimale pour que le test puisse compiler mais échouer.</li>
<li>Implémentez la logique d'ajout de tâche pour que le test passe. Les tâches peuvent être stockées dans une <code>List&lt;String&gt;</code> ou une <code>List&lt;TaskObject&gt;</code> simple en mémoire.</li>
</ul>
</li>
<li>Pour la fonctionnalité "Lister les tâches" :
<ul>
<li>Dans <code>TaskManagerTest.java</code>, écrivez une méthode de test qui vérifie que la liste des tâches retournée correspond à celles ajoutées.</li>
<li>Ajoutez la méthode (ex: <code>List&lt;String&gt; getAllTasks()</code>) à <code>TaskManager.java</code> et implémentez-la.</li>
</ul>
</li>
<li>Créez une classe principale <code>App.java</code> avec une méthode <code>main</code> qui permet d'interagir basiquement avec <code>TaskManager</code> via la console (lire les commandes "add" et "list" et appeler les méthodes correspondantes).</li>
<li>Assurez-vous que <code>mvn clean package</code> (ou <code>mvn clean test</code>) s'exécute avec succès localement.</li>
<li>Commitez régulièrement votre progression sur vos branches de fonctionnalités et fusionnez-les dans <code>develop</code>.</li>
</ul>
</li>
</ol>
<h3 id="phase-2--documentation-conteneurisation--automatisation-focus--doxygen-docker-github-actions"><a class="header" href="#phase-2--documentation-conteneurisation--automatisation-focus--doxygen-docker-github-actions">Phase 2 : Documentation, Conteneurisation &amp; Automatisation (Focus : Doxygen, Docker, GitHub Actions)</a></h3>
<ol start="5">
<li>
<p><strong>Documentation du Code avec Doxygen :</strong></p>
<ul>
<li>Ajoutez des commentaires Javadoc/Doxygen significatifs à vos classes (<code>TaskManager</code>, <code>App</code>, et toute autre classe de modèle que vous auriez créée) et à leurs méthodes publiques.</li>
<li>Générez un fichier <code>Doxyfile</code> (<code>doxygen -g</code>).</li>
<li>Configurez le <code>Doxyfile</code> a minima :
<ul>
<li><code>PROJECT_NAME</code></li>
<li><code>INPUT</code> (pointant vers <code>src/main/java</code>)</li>
<li><code>OUTPUT_DIRECTORY</code></li>
<li><code>RECURSIVE = YES</code></li>
<li><code>OPTIMIZE_OUTPUT_JAVA = YES</code></li>
<li><code>JAVADOC_AUTOBRIEF = YES</code></li>
</ul>
</li>
<li>Générez la documentation HTML localement et vérifiez son apparence.</li>
</ul>
</li>
<li>
<p><strong>Conteneurisation avec Docker :</strong></p>
<ul>
<li>Créez un <code>Dockerfile</code> à la racine de votre projet.</li>
<li>Ce <code>Dockerfile</code> doit :
<ul>
<li>Partir d'une image de base JRE appropriée (ex: <code>eclipse-temurin:17-jre-jammy</code>).</li>
<li>Copier le fichier JAR de votre application (généré par <code>mvn package</code> dans le dossier <code>target/</code>) dans l'image.</li>
<li>Définir la commande <code>ENTRYPOINT</code> (ou <code>CMD</code>) pour exécuter votre application <code>TaskMaster Lite</code> (la classe <code>App</code> avec sa méthode <code>main</code>).</li>
</ul>
</li>
<li>Construisez votre image Docker localement et testez-la en lançant un conteneur pour vérifier que l'interaction en ligne de commande fonctionne.</li>
</ul>
</li>
<li>
<p><strong>Mise en Place du Pipeline GitHub Actions :</strong></p>
<ul>
<li>Créez un fichier de workflow</li>
<li>Configurez-le pour se déclencher sur les <code>push</code> vers les branches <code>develop</code> et <code>master</code></li>
<li>Définissez plusieurs jobs pour réaliser les tâches suivantes :
<ul>
<li><strong>Job <code>build-and-test</code> :</strong>
<ul>
<li>Checkout du code.</li>
<li>Configuration de Java 17 et Maven (avec mise en cache des dépendances).</li>
<li>Exécution de <code>mvn -B clean package</code> (pour compiler, tester, et créer le JAR).</li>
</ul>
</li>
<li><strong>Job <code>dockerize-and-publish</code> (dépendant du succès de <code>build-and-test</code>) :</strong>
<ul>
<li>Checkout du code (nécessaire si c'est un job séparé).</li>
<li>Télécharger l'artefact JAR du job précédent (si vous l'avez uploadé) OU s'assurer que le JAR est disponible (le rebuilder si besoin, mais moins optimal). Il est plus simple de builder le JAR dans ce job après un checkout.</li>
<li>Se connecter à GitHub Container Registry (GHCR) en utilisant <code>docker/login-action</code> et le secret <code>GITHUB_TOKEN</code>.</li>
<li>(Optionnel mais recommandé) Utiliser <code>docker/metadata-action</code> pour générer des tags pour votre image.</li>
<li>Construire l'image Docker.</li>
<li>Pousser l'image vers GHCR avec au moins un tag (ex: <code>latest</code> ou le SHA du commit). Le nom de l'image doit être du type <code>ghcr.io/VOTRE_NOM_UTILISATEUR_GITHUB/taskmasterlite-nomequipe:tag</code>.</li>
</ul>
</li>
<li><strong>Job <code>document-and-archive</code> (dépendant du succès de <code>build-and-test</code>) :</strong>
<ul>
<li>Checkout du code.</li>
<li>Installation de Doxygen et Graphviz.</li>
<li>Génération de la documentation Doxygen en utilisant votre <code>Doxyfile</code>.</li>
<li>Archivage du répertoire HTML de la documentation générée en tant qu'artefact de build (en utilisant <code>actions/upload-artifact</code>). Nommez l'artefact de manière explicite (ex: <code>taskmaster-lite-documentation</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Validation Finale :</strong></p>
<ul>
<li>Assurez-vous que votre workflow complet s'exécute avec succès sur GitHub Actions lors d'un push sur <code>develop</code> ou sur <code>master</code>.</li>
<li>Vérifiez que l'image Docker est bien publiée sur GHCR.</li>
<li>Téléchargez l'artefact de documentation et vérifiez son contenu localement (utilisez <code>python3 -m http.server</code> pour la visualiser correctement).</li>
</ul>
</li>
</ol>
<hr />
<h2 id="bonus-optionnel-déploiement-de-la-documentation-sur-github-pages"><a class="header" href="#bonus-optionnel-déploiement-de-la-documentation-sur-github-pages">(Bonus Optionnel) Déploiement de la Documentation sur GitHub Pages</a></h2>
<ul>
<li>Modifiez votre workflow pour déployer la documentation Doxygen (générée à l'étape <code>document-and-archive</code>) sur GitHub Pages pour le dépôt de votre projet d'examen.</li>
<li>Utilisez l'action <code>peaceiris/actions-gh-pages</code> ou une méthode de votre choix (script Git).</li>
<li>Configurez les paramètres de votre dépôt pour activer GitHub Pages depuis la branche <code>gh-pages</code> (ou la source que vous aurez choisie).</li>
<li><strong>Critère Bonus :</strong> La documentation est accessible en ligne à l'URL <code>https://&lt;nomUtilisateurGitHub&gt;.github.io/&lt;NomDeVotreRepoExamen&gt;/</code>.</li>
</ul>
<hr />
<h2 id="critères-dÉvaluation-principaux"><a class="header" href="#critères-dÉvaluation-principaux">Critères d'Évaluation Principaux</a></h2>
<ul>
<li><strong>Collaboration et Gestion de Version :</strong> Qualité et fréquence des commits, utilisation des branches, clarté de l'historique.</li>
<li><strong>Application Java &amp; Maven :</strong> Projet Maven correctement structuré et configuré, fonctionnalités de <code>TaskMaster Lite</code> implémentées et fonctionnelles, tests unitaires pertinents et qui passent.</li>
<li><strong>Dockerfile :</strong> Correction et efficacité du Dockerfile, image Docker qui se construit et exécute l'application.</li>
<li><strong>Doxygen :</strong> Qualité des commentaires Javadoc/Doxygen, configuration du <code>Doxyfile</code>, documentation HTML générée et archivée.</li>
<li><strong>Workflow GitHub Actions :</strong>
<ul>
<li>Déclenchement correct et exécution réussie de tous les jobs et étapes.</li>
<li>Compilation, tests, création du JAR.</li>
<li>Build et push de l'image Docker sur GHCR (nommage et tagging corrects).</li>
<li>Génération et archivage de la documentation Doxygen.</li>
</ul>
</li>
<li><strong>Respect des consignes et propreté générale du projet.</strong></li>
</ul>
<p>Bon courage à toute l'équipe ! Montrez-moi ce que vous avez appris !</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
