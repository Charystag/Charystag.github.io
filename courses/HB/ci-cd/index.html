<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Github Actions - CI-CD</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Day 1</li><li class="chapter-item expanded "><a href="day_1/Github-actions-guided.html" class="active"><strong aria-hidden="true">1.</strong> Github Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day_1/Github-actions-non-guided.html"><strong aria-hidden="true">1.1.</strong> non guided</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Day 2</li><li class="chapter-item expanded "><a href="day_2/tests_java.html"><strong aria-hidden="true">2.</strong> Tests Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day_2/tests_java_non_guide.html"><strong aria-hidden="true">2.1.</strong> non guided</a></li></ol></li><li class="chapter-item expanded "><a href="day_2/tutoriels_docker.html"><strong aria-hidden="true">3.</strong> Tutoriels Docker</a></li><li class="chapter-item expanded affix "><li class="part-title">Day 3</li><li class="chapter-item expanded "><a href="day_3/dockerize_java_app.html"><strong aria-hidden="true">4.</strong> Dockerisation Application Java</a></li><li class="chapter-item expanded "><a href="day_3/tutoriel_github_actions.html"><strong aria-hidden="true">5.</strong> Tutoriel Github Actions</a></li><li class="chapter-item expanded "><a href="day_3/publish_java_docker_image.html"><strong aria-hidden="true">6.</strong> Publication Image Java</a></li><li class="chapter-item expanded "><a href="day_3/documentation_guided.html"><strong aria-hidden="true">7.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="day_3/auto_documentation.html"><strong aria-hidden="true">8.</strong> Documentation Automatique</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CI-CD</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="exercices-github-actions"><a class="header" href="#exercices-github-actions">Exercices GitHub Actions</a></h1>
<h2 id="niveau-1--débutant"><a class="header" href="#niveau-1--débutant">Niveau 1 : Débutant</a></h2>
<h3 id="exercice-1--créer-un-dépôt-et-configurer-github-actions"><a class="header" href="#exercice-1--créer-un-dépôt-et-configurer-github-actions">Exercice 1 : Créer un dépôt et configurer GitHub Actions</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer un dépôt GitHub et configurer GitHub Actions.</p>
<ol>
<li>Créez un dépôt sur GitHub.</li>
<li>Clonez le dépôt localement.</li>
<li>Dans le dépôt, créez un répertoire <code>.github/workflows</code>.</li>
<li>Dans ce répertoire, créez un fichier <code>main.yml</code> (ou <code>ci.yml</code>).</li>
</ol>
<p><strong>Intérêt :</strong>
Configurer GitHub Actions dès le début vous permet d'automatiser les tâches dès que vous commencez à travailler sur votre projet. Cela vous aide à garantir que les tests sont exécutés, que le code est construit correctement, et éventuellement déployé automatiquement.</p>
<p><strong>Application réelle :</strong>
Vous pouvez automatiser des tâches courantes telles que l'exécution de tests, le linting du code, ou même le déploiement de votre application après chaque commit ou merge dans la branche principale.</p>
<h3 id="exercice-2--créer-une-action-simple"><a class="header" href="#exercice-2--créer-une-action-simple">Exercice 2 : Créer une action simple</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub simple qui s'exécute sur chaque push.</p>
<ol>
<li>
<p>Ajoutez le contenu suivant dans le fichier <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: CI Simple

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Run a one-line script
      run: echo "Hello, world depuis GitHub Actions !"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement dans l'onglet "Actions" de votre dépôt.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Comprendre comment déclencher une action simple vous donne les bases pour automatiser des processus plus complexes. Savoir utiliser les actions de base est essentiel pour la CI/CD.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser cette connaissance pour automatiser des tâches simples, comme envoyer un message de notification à une équipe via Slack chaque fois qu'un push est effectué.</p>
<h3 id="exercice-3--exécuter-un-script-multi-lignes"><a class="header" href="#exercice-3--exécuter-un-script-multi-lignes">Exercice 3 : Exécuter un script multi-lignes</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter un script multi-lignes dans une action GitHub.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour inclure un script multi-lignes :</p>
<pre><code class="language-yaml">name: CI Multi-lignes

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Run a multi-line script
      run: |
        echo "Ceci est la première ligne du script."
        echo "Et voici une deuxième ligne pour montrer que ça marche."
        echo "On peut ajouter autant de commandes qu'on veut ici."
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les scripts multi-lignes vous permettent d'effectuer des tâches plus complexes et plus longues dans vos workflows GitHub Actions.</p>
<p><strong>Application réelle :</strong>
Automatiser l'installation d'un environnement de développement, exécuter des tests, et générer des rapports de test peuvent être réalisés en utilisant des scripts multi-lignes.</p>
<h3 id="exercice-4--utiliser-des-actions-de-la-marketplace"><a class="header" href="#exercice-4--utiliser-des-actions-de-la-marketplace">Exercice 4 : Utiliser des actions de la marketplace</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser une action de la GitHub Marketplace.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser l'action <code>actions/setup-node</code> de la marketplace :</p>
<pre><code class="language-yaml">name: CI avec Setup Node

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20' # Utilisation d'une version LTS spécifique

    - name: Vérifier la version de Node.js
      run: node -v
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute correctement et affiche la version de Node.js.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
La GitHub Marketplace offre de nombreuses actions créées par la communauté, ce qui vous permet de ne pas réinventer la roue et de bénéficier de fonctionnalités déjà prêtes à l'emploi.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser des actions pour configurer automatiquement Node.js (comme ici), Python, Java, déployer des applications sur AWS, ou envoyer des notifications Slack, sans avoir à écrire le code de ces actions vous-même.</p>
<h3 id="exercice-5--ajouter-des-secrets"><a class="header" href="#exercice-5--ajouter-des-secrets">Exercice 5 : Ajouter des secrets</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des secrets dans GitHub Actions.</p>
<ol>
<li>
<p>Dans les paramètres de votre dépôt GitHub (<code>Settings &gt; Secrets and variables &gt; Actions</code>), ajoutez un nouveau "repository secret" nommé <code>MY_SUPER_SECRET</code> avec une valeur bidon (ex: <code>CestTresSecret</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser le secret :</p>
<pre><code class="language-yaml">name: CI avec Secrets

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Utiliser un secret (de manière sécurisée)
      env:
        MON_SECRET_UTILISE_EN_INTERNE: ${{ secrets.MY_SUPER_SECRET }}
      run: |
        echo "Le script va utiliser le secret mais ne l'affichera PAS directement."
        # Pour la démo, on va juste prouver qu'il est là :
        if [ -n "$MON_SECRET_UTILISE_EN_INTERNE" ]; then
          echo "Le secret est bien passé en variable d'env !"
        else
          echo "Oops, le secret n'est pas là."
          exit 1
        fi
        # ATTENTION : NE JAMAIS FAIRE 'echo ${{ secrets.MY_SUPER_SECRET }}' pour un vrai secret en production.
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute et que le log indique que le secret est bien passé.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les secrets vous permettent de gérer en toute sécurité les informations sensibles comme les tokens d'API, les clés de chiffrement et autres données confidentielles.</p>
<p><strong>Application réelle :</strong>
Vous pouvez utiliser des secrets pour stocker les informations d'identification nécessaires pour déployer une application sur un serveur, vous connecter à un registry Docker, ou pour accéder à une API tierce de manière sécurisée.</p>
<h3 id="exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions"><a class="header" href="#exercice-6--utiliser-des-matrices-pour-tester-plusieurs-versions">Exercice 6 : Utiliser des matrices pour tester plusieurs versions</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des matrices pour tester plusieurs versions d'un langage.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour utiliser une matrice avec différentes versions de Node.js :</p>
<pre><code class="language-yaml">name: CI avec Matrice Node.js

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: ['18', '20'] # Versions LTS spécifiques

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}

    - name: Afficher la version de Node.js
      run: echo "Test avec Node.js $(node -v) sur ${{ runner.os }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que l'action s'exécute en parallèle pour chaque version de Node.js spécifiée.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les matrices permettent de tester votre code sur différentes versions d'un langage ou dans différents environnements (OS, etc.), assurant ainsi une compatibilité et une robustesse maximales.</p>
<p><strong>Application réelle :</strong>
Tester une application Node.js sur plusieurs versions de Node.js pour garantir qu'elle fonctionne correctement sur les versions que vos utilisateurs sont susceptibles d'utiliser. Idem pour Python, Java, etc.</p>
<hr />
<h2 id="niveau-2--intermédiaire"><a class="header" href="#niveau-2--intermédiaire">Niveau 2 : Intermédiaire</a></h2>
<h3 id="exercice-7--exécuter-des-tests-unitaires"><a class="header" href="#exercice-7--exécuter-des-tests-unitaires">Exercice 7 : Exécuter des tests unitaires</a></h3>
<p><strong>Objectif :</strong> Apprendre à exécuter des tests unitaires dans GitHub Actions.</p>
<ol>
<li>
<p>Créez un projet Node.js simple avec un <code>package.json</code> et des tests unitaires (par exemple avec Jest ou Mocha). Assurez-vous d'avoir un script de test dans <code>package.json</code> (ex: <code>"test": "jest"</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour exécuter les tests :</p>
<pre><code class="language-yaml">name: CI avec Tests Unitaires

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Installer les dépendances
      run: npm ci

    - name: Exécuter les tests
      run: npm test
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que les tests s'exécutent correctement.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Automatiser les tests unitaires garantit que chaque modification de code est testée immédiatement, ce qui améliore la qualité du code et réduit les risques d'introduire des bugs.</p>
<p><strong>Application réelle :</strong>
À chaque push, les tests sont automatiquement exécutés, ce qui permet de détecter et de corriger rapidement les régressions.</p>
<h3 id="exercice-8--déployer-sur-github-pages"><a class="header" href="#exercice-8--déployer-sur-github-pages">Exercice 8 : Déployer sur GitHub Pages</a></h3>
<p><strong>Objectif :</strong> Apprendre à déployer un site statique sur GitHub Pages via GitHub Actions.</p>
<ol>
<li>
<p>Créez un site statique simple dans votre dépôt. Si vous utilisez un framework (comme Angular, React, Vue), assurez-vous que la commande <code>npm run build</code> génère les fichiers statiques dans un dossier (souvent <code>dist</code> ou <code>build</code>).</p>
</li>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour déployer le site.</p>
<pre><code class="language-yaml">name: Déploiement sur GitHub Pages

on:
  push:
    branches:
      - main # Ou la branche que vous voulez déployer

permissions:
  contents: write # Nécessaire pour que l'action puisse pusher sur la branche gh-pages

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      # Si c'est un projet Node.js qui nécessite un build (ex: Angular, React, Vue)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Installer les dépendances et Builder
        run: |
          npm ci
          npm run build # Assurez-vous que ce script génère dans './build' ou './dist'

      - name: Déployer sur GitHub Pages
        uses: peaceiris/actions-gh-pages@v3 # Action populaire et stable pour ça
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist # Adaptez au dossier de sortie de votre build (ex: ./build, ./public)
</code></pre>
<p><strong>Note importante pour GitHub Pages :</strong> Allez dans les paramètres de votre dépôt (<code>Settings &gt; Pages</code>), et sous "Build and deployment", pour "Source", sélectionnez "GitHub Actions".</p>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez que le site est déployé sur GitHub Pages.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Automatiser le déploiement d'un site sur GitHub Pages vous permet de mettre à jour votre site web automatiquement à chaque changement de code.</p>
<p><strong>Application réelle :</strong>
Déployer automatiquement un site de documentation, un portfolio, ou un site web statique chaque fois que du nouveau contenu est ajouté ou modifié dans le dépôt.</p>
<h3 id="exercice-9--utiliser-des-workflows-multi-jobs"><a class="header" href="#exercice-9--utiliser-des-workflows-multi-jobs">Exercice 9 : Utiliser des workflows multi-jobs</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer des workflows multi-jobs qui peuvent dépendre les uns des autres.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> pour inclure plusieurs jobs :</p>
<pre><code class="language-yaml">name: CI Multi-Jobs

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un build
      run: |
        echo "Compilation du projet..."
        mkdir -p output # Créer le dossier output
        echo "Résultat du build" &gt; output/build_result.txt
    - name: Uploader l'artefact du build
      uses: actions/upload-artifact@v4
      with:
        name: build-output
        path: output/

  test:
    runs-on: ubuntu-latest
    needs: build # Dépend du job 'build'
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Télécharger l'artefact du build
      uses: actions/download-artifact@v4
      with:
        name: build-output
        path: downloaded_build_output
    - name: Simuler des tests
      run: |
        echo "Exécution des tests sur le résultat du build..."
        cat downloaded_build_output/build_result.txt
        echo "Tests terminés !"

  deploy:
    runs-on: ubuntu-latest
    needs: test # Dépend du job 'test'
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un déploiement
      run: echo "Déploiement du projet..."
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub et vérifiez l'exécution séquentielle et conditionnelle des jobs.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les workflows multi-jobs permettent de structurer les tâches en étapes distinctes, exécutées en parallèle ou séquentiellement (avec <code>needs</code>), améliorant ainsi l'efficacité et la clarté des processus CI/CD.</p>
<p><strong>Application réelle :</strong>
Exécuter des tests unitaires, puis des tests d'intégration, et enfin déployer l'application, chaque tâche étant gérée comme un job distinct et dépendant du succès du précédent.</p>
<h3 id="exercice-10--utiliser-des-artefacts"><a class="header" href="#exercice-10--utiliser-des-artefacts">Exercice 10 : Utiliser des artefacts</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des artefacts pour stocker et partager des fichiers entre les jobs. (Cet exercice est très similaire au précédent qui utilise déjà des artefacts).</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> (ou créez-en un nouveau) :</p>
<pre><code class="language-yaml">name: CI avec Artefacts

on: [push]

jobs:
  job1_produire_artefact:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Créer un fichier artefact
      run: echo "Contenu de mon artefact !" &gt; mon_artefact.txt

    - name: Uploader l'artefact
      uses: actions/upload-artifact@v4
      with:
        name: resultat-job1
        path: mon_artefact.txt

  job2_consommer_artefact:
    runs-on: ubuntu-latest
    needs: job1_produire_artefact
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Télécharger l'artefact
      uses: actions/download-artifact@v4
      with:
        name: resultat-job1
        # path: ./destination_optionnelle # par défaut à la racine du workspace

    - name: Utiliser l'artefact
      run: cat mon_artefact.txt
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les artefacts permettent de sauvegarder des fichiers générés pendant l'exécution d'un job pour les utiliser dans des jobs suivants ou pour les télécharger ultérieurement.</p>
<p><strong>Application réelle :</strong>
Générer des rapports de test, des binaires compilés, ou des archives de votre application dans un job et les utiliser pour déploiement ou analyse dans un autre job.</p>
<hr />
<h2 id="niveau-3--avancé"><a class="header" href="#niveau-3--avancé">Niveau 3 : Avancé</a></h2>
<h3 id="exercice-11--créer-une-action-personnalisée"><a class="header" href="#exercice-11--créer-une-action-personnalisée">Exercice 11 : Créer une action personnalisée</a></h3>
<p><strong>Objectif :</strong> Apprendre à créer une action GitHub personnalisée (en JavaScript/Node.js).</p>
<ol>
<li>
<p>Créez un répertoire <code>my-custom-action</code> à la racine de votre dépôt.</p>
</li>
<li>
<p>Dans <code>my-custom-action</code>, créez <code>action.yml</code> :</p>
<pre><code class="language-yaml">name: 'Mon Action Perso'
description: 'Salue une personne et donne l heure.'
inputs:
  qui_saluer:
    description: 'Qui saluer ?'
    required: true
    default: 'Monde'
outputs:
  temps:
    description: 'L heure de la salutation.'
runs:
  using: 'node20' # Utiliser une version Node.js LTS
  main: 'index.js'
</code></pre>
</li>
<li>
<p>Dans <code>my-custom-action</code>, initialisez un projet Node (<code>npm init -y</code>) et installez les dépendances (<code>npm install @actions/core @actions/github</code>). Puis créez <code>index.js</code> :</p>
<pre><code class="language-javascript">// my-custom-action/index.js
const core = require('@actions/core');
// const github = require('@actions/github'); // Pas utilisé dans cet exemple simple

async function run() {
  try {
    const quiASaluer = core.getInput('qui_saluer');
    console.log(`Bonjour, ${quiASaluer} !`);

    const time = (new Date()).toTimeString();
    core.setOutput("temps", time);
  } catch (error) {
    core.setFailed(error.message);
  }
}

run();
</code></pre>
<p><strong>Note :</strong> Pour que cette action soit utilisable dans le workflow, vous devrez commiter <code>my-custom-action/index.js</code>, <code>my-custom-action/action.yml</code>, <code>my-custom-action/package.json</code>, <code>my-custom-action/package-lock.json</code> et le dossier <code>node_modules</code> de l'action, OU mieux, utiliser un bundler comme <code>@vercel/ncc</code> pour packager votre action en un seul fichier JS (plus avancé, mais meilleure pratique). Pour cet exo, le plus simple est de tout commiter ou de faire un <code>npm install</code> dans l'action elle-même (voir ci-dessous).</p>
</li>
<li>
<p>Modifiez votre fichier de workflow principal pour utiliser cette action :</p>
<pre><code class="language-yaml">name: CI avec Action Personnalisée

on: [push]

jobs:
  build_avec_action_perso:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    # Option 1: Si node_modules n'est pas commité avec l'action
    - name: Installer les dépendances de l'action perso
      run: npm install --prefix my-custom-action # Exécute npm install dans le dossier de l'action

    - name: Exécuter mon action personnalisée
      id: salutation
      uses: ./my-custom-action # Chemin vers le dossier de l'action locale
      with:
        qui_saluer: 'les Participants à la Formation'

    - name: Afficher l'output de l'action
      run: echo "L'action a été exécutée à ${{ steps.salutation.outputs.temps }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications sur GitHub.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Créer vos propres actions vous permet de réutiliser du code logique complexe dans plusieurs workflows.</p>
<p><strong>Application réelle :</strong>
Automatiser une tâche spécifique à votre entreprise.</p>
<h3 id="exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes"><a class="header" href="#exercice-12--utiliser-des-conditions-pour-contrôler-les-étapes">Exercice 12 : Utiliser des conditions pour contrôler les étapes</a></h3>
<p><strong>Objectif :</strong> Apprendre à utiliser des expressions conditionnelles (<code>if:</code>) pour contrôler l'exécution.</p>
<ol>
<li>
<p>Modifiez le fichier <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: CI avec Conditions

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Étape toujours exécutée
      run: echo "Cette étape s'exécute toujours."

    - name: Étape conditionnelle (branche main uniquement)
      if: github.ref == 'refs/heads/main'
      run: echo "Cette étape s'exécute SEULEMENT sur la branche main."

    # Pour les événements de push, on accède au message du dernier commit (head_commit)
    - name: Autre condition (pas si le commit contient '[skip ci]')
      if: "!contains(github.event.head_commit.message, '[skip ci]')"
      run: echo "Cette étape ne s'exécute PAS si le message de commit contient '[skip ci]'."
</code></pre>
</li>
<li>
<p>Poussez les modifications et testez différents scénarios.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Les conditions rendent vos workflows plus flexibles.</p>
<p><strong>Application réelle :</strong>
Déployer seulement depuis <code>main</code>, sauter des tests sur des branches de dev.</p>
<h3 id="exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé"><a class="header" href="#exercice-13--utiliser-des-secrets-pour-déploiement-sécurisé">Exercice 13 : Utiliser des secrets pour déploiement sécurisé</a></h3>
<p><strong>Objectif :</strong> Utiliser des secrets GitHub pour des informations sensibles.</p>
<ol>
<li>
<p>Ajoutez des secrets <code>AWS_ACCESS_KEY_ID</code> et <code>AWS_SECRET_ACCESS_KEY</code> dans les paramètres du dépôt.</p>
</li>
<li>
<p>Modifiez <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: Déploiement sur AWS avec Secrets

on:
  push:
    branches: [main]

jobs:
  deploy_to_aws:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4

    - name: Configurer les identifiants AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1 # Changez si besoin

    - name: Simuler un déploiement sur AWS
      run: |
        echo "Tentative de déploiement sur AWS..."
        # Exemple: aws s3 ls # Liste les buckets S3 pour prouver que la config AWS marche
        echo "Déploiement (simulé) terminé."
</code></pre>
</li>
<li>
<p>Poussez les modifications.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Sécuriser les informations sensibles.</p>
<p><strong>Application réelle :</strong>
Stocker clés API, tokens, mots de passe pour des déploiements sur des services cloud.</p>
<h3 id="exercice-14--déclencher-des-workflows-manuellement"><a class="header" href="#exercice-14--déclencher-des-workflows-manuellement">Exercice 14 : Déclencher des workflows manuellement</a></h3>
<p><strong>Objectif :</strong> Apprendre à déclencher des workflows manuellement (<code>workflow_dispatch</code>).</p>
<ol>
<li>
<p>Modifiez <code>main.yml</code> :</p>
<pre><code class="language-yaml">name: Déclenchement Manuel

on:
  workflow_dispatch: # Permet le déclenchement manuel
    inputs: # Optionnel : définir des inputs pour le déclenchement manuel
      logLevel:
        description: 'Niveau de log'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tag:
        description: 'Tag à utiliser'
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Run a one-line script
      run: |
        echo "Workflow déclenché manuellement !"
        echo "Niveau de log : ${{ github.event.inputs.logLevel }}"
        echo "Tag : ${{ github.event.inputs.tag }}"
</code></pre>
</li>
<li>
<p>Poussez. Allez dans l'onglet "Actions" de votre dépôt, sélectionnez ce workflow, et cliquez sur "Run workflow".</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Contrôle manuel pour des tâches comme des déploiements en production ou des scripts de maintenance.</p>
<p><strong>Application réelle :</strong>
Déclencher un déploiement vers la production après validation manuelle.</p>
<h3 id="exercice-15--gérer-les-dépendances-entre-workflows"><a class="header" href="#exercice-15--gérer-les-dépendances-entre-workflows">Exercice 15 : Gérer les dépendances entre workflows</a></h3>
<p><strong>Objectif :</strong> Déclencher un workflow après la complétion d'un autre (<code>workflow_run</code>).</p>
<ol>
<li>
<p>Créez deux fichiers de workflow : <code>build.yml</code> et <code>deploy.yml</code>.
<code>build.yml</code> :</p>
<pre><code class="language-yaml">name: Build Principal

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout du code
      uses: actions/checkout@v4
    - name: Simuler un build et créer un artefact
      run: |
        echo "Building project..."
        mkdir -p mon_build
        echo "Contenu du build" &gt; mon_build/fichier_construit.txt
    - name: Uploader l'artefact du build
      uses: actions/upload-artifact@v4
      with:
        name: build-artifact
        path: mon_build/ # Uploader le dossier
</code></pre>
<p><code>deploy.yml</code> :</p>
<pre><code class="language-yaml">name: Deploy Après Build

on:
  workflow_run:
    workflows: ["Build Principal"] # Nom du workflow déclencheur
    types:
      - completed # Se déclenche quand "Build Principal" est terminé

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }} # Condition: seulement si le build a réussi
    steps:
    - name: Checkout du code (nécessaire pour certains contextes ou scripts de déploiement)
      uses: actions/checkout@v4
    - name: Télécharger l'artefact du build
      uses: actions/download-artifact@v4
      with:
        name: build-artifact # Doit correspondre au nom de l'artefact uploadé
        # path: ./destination # Optionnel, sinon à la racine
        # Spécifier le run_id est crucial si vous avez plusieurs actions/upload-artifact avec le même nom
        # ou pour récupérer celui du workflow déclencheur.
        # Pour workflow_run, GHA le gère implicitement pour les artefacts du workflow déclencheur.
    - name: Simuler un déploiement
      run: |
        echo "Deploying project avec l'artefact..."
        cat fichier_construit.txt # Vérifier que le fichier est là
</code></pre>
</li>
<li>
<p>Poussez les modifications. Un push sur <code>main</code> devrait lancer <code>Build Principal</code>, et si celui-ci réussit, <code>Deploy Après Build</code> devrait se lancer.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Structurer des processus CI/CD complexes en workflows plus petits et gérables.</p>
<p><strong>Application réelle :</strong>
Un workflow de build et test qui, en cas de succès, déclenche un workflow de déploiement sur un environnement de staging, puis potentiellement un autre pour la production.</p>
<h3 id="exercice-16--utiliser-des-workflows-réutilisables"><a class="header" href="#exercice-16--utiliser-des-workflows-réutilisables">Exercice 16 : Utiliser des workflows réutilisables</a></h3>
<p><strong>Objectif :</strong> Créer un workflow qui peut être appelé par d'autres workflows (<code>workflow_call</code>).</p>
<ol>
<li>
<p>Créez un fichier <code>workflow-reutilisable.yml</code> :</p>
<pre><code class="language-yaml">name: Mon Workflow Réutilisable

on:
  workflow_call: # Définit ce workflow comme étant réutilisable
    inputs:
      message_perso:
        description: 'Message à afficher'
        required: true
        type: string
      executer_tests:
        description: 'Faut-il exécuter les tests ?'
        required: false
        type: boolean
        default: false
    outputs: # Optionnel : définir des outputs
      resultat_reutilisable:
        description: 'Un résultat du workflow réutilisable'
        value: ${{ jobs.tache_reutilisable.outputs.result_output }}


jobs:
  tache_reutilisable:
    runs-on: ubuntu-latest
    outputs: # Définir les outputs du job
      result_output: ${{ steps.etape_reutilisable.outputs.result }}
    steps:
      - id: etape_reutilisable
        run: |
          echo "Message reçu : ${{ inputs.message_perso }}"
          if [ "${{ inputs.executer_tests }}" == "true" ]; then
            echo "Exécution des tests demandée..."
          else
            echo "Pas de tests demandés."
          fi
          echo "result=SuccesDuReutilisable" &gt;&gt; $GITHUB_OUTPUT
</code></pre>
</li>
<li>
<p>Créez un fichier <code>workflow-appelant.yml</code> pour appeler le workflow réutilisable :</p>
<pre><code class="language-yaml">name: Workflow Appellant

on: [push]

jobs:
  appel_du_workflow:
    # Important: Pour appeler un workflow réutilisable du même dépôt :
    uses: ./.github/workflows/workflow-reutilisable.yml
    # Pour un workflow dans un autre dépôt :
    # uses: VOTRE_ORG/VOTRE_REPO/.github/workflows/workflow-reutilisable.yml@main_ou_tag_ou_sha
    with:
      message_perso: "Salut depuis le workflow appellant !"
      executer_tests: true
    # secrets: inherit # Pour passer les secrets, si besoin
  
  utiliser_output:
    runs-on: ubuntu-latest
    needs: appel_du_workflow # S'assurer qu'il tourne après
    steps:
      - run: echo "Résultat du workflow réutilisable : ${{ needs.appel_du_workflow.outputs.resultat_reutilisable }}"
</code></pre>
</li>
<li>
<p>Poussez les modifications.</p>
</li>
</ol>
<p><strong>Intérêt :</strong>
Centraliser et partager des logiques de workflow communes, réduisant la duplication et facilitant la maintenance.</p>
<p><strong>Application réelle :</strong>
Créer un workflow de build ou de test standardisé que plusieurs dépôts de votre organisation peuvent appeler.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="day_1/Github-actions-non-guided.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="day_1/Github-actions-non-guided.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
