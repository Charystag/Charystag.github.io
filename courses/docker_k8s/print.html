<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker-K8s</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course/part1/intro.html"><strong aria-hidden="true">1.</strong> Introduction à Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course/part1/contenerisation.html"><strong aria-hidden="true">1.1.</strong> Histoire de la conteneurisation</a></li><li class="chapter-item expanded "><a href="course/part1/docker_basics.html"><strong aria-hidden="true">1.2.</strong> Bases de Docker</a></li><li class="chapter-item expanded "><a href="course/part1/images_and_containers.html"><strong aria-hidden="true">1.3.</strong> Images et containers</a></li><li class="chapter-item expanded "><a href="course/part1/volumes.html"><strong aria-hidden="true">1.4.</strong> Volumes et persistence des données</a></li><li class="chapter-item expanded "><a href="course/part1/wrap_up.html"><strong aria-hidden="true">1.5.</strong> Résumé</a></li></ol></li><li class="chapter-item expanded "><a href="course/part2/intro.html"><strong aria-hidden="true">2.</strong> Concepts Avancés de Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course/part2/networking.html"><strong aria-hidden="true">2.1.</strong> Mise en Réseau avec Docker</a></li><li class="chapter-item expanded "><a href="course/part2/compose.html"><strong aria-hidden="true">2.2.</strong> Docker Compose</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/index.html"><strong aria-hidden="true">3.</strong> Exercices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/ms_builds.html"><strong aria-hidden="true">3.1.</strong> Multistage Builds</a></li><li class="chapter-item expanded "><a href="exercises/nginx_server_setup.html"><strong aria-hidden="true">3.2.</strong> Nginx Server Setup</a></li><li class="chapter-item expanded "><a href="exercises/nginx_reverse_proxy.html"><strong aria-hidden="true">3.3.</strong> Nginx Reverse Proxy</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/hello-minikube.html"><strong aria-hidden="true">4.</strong> Kubernetes Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/first-deployment.html"><strong aria-hidden="true">4.1.</strong> First Deployment</a></li><li class="chapter-item expanded "><a href="exercises/kubernetes_volumes.html"><strong aria-hidden="true">4.2.</strong> Kubernetes Volumes</a></li><li class="chapter-item expanded "><a href="exercises/kubernetes-networking.html"><strong aria-hidden="true">4.3.</strong> Kubernetes Networking</a></li><li class="chapter-item expanded "><a href="exercises/scaling.html"><strong aria-hidden="true">4.4.</strong> Application Scaling</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/first-deployment-non-guided.html"><strong aria-hidden="true">5.</strong> Kubernetes Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/kubernetes-volumes-non-guided.html"><strong aria-hidden="true">5.1.</strong> Kubernetes Volumes Exercise</a></li><li class="chapter-item expanded "><a href="exercises/kubernetes-networking-non-guided.html"><strong aria-hidden="true">5.2.</strong> Kubernetes Networking Exercise</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docker-K8s</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="partie-1--introduction-à-la-conteneurisation-et-à-docker"><a class="header" href="#partie-1--introduction-à-la-conteneurisation-et-à-docker"><strong>Partie 1 : Introduction à la Conteneurisation et à Docker</strong></a></h1>
<h2 id="introduction"><a class="header" href="#introduction"><strong>Introduction</strong></a></h2>
<p>Au cours des dernières décennies, l'infrastructure informatique a connu une évolution spectaculaire, passant de serveurs physiques imposants à des technologies modernes telles que les conteneurs. Cette transition a transformé la manière dont les entreprises développent, testent, déploient et gèrent leurs applications.</p>
<p>La conteneurisation est devenue une pièce maîtresse dans l'écosystème du cloud et des environnements modernes. Elle répond aux défis de flexibilité, de scalabilité et d'efficacité posés par les approches traditionnelles. Contrairement aux machines virtuelles, les conteneurs sont légers, portables et permettent de s’assurer que les applications fonctionnent de manière cohérente, quel que soit l’environnement dans lequel elles sont exécutées.</p>
<p>Docker, l’outil le plus populaire de conteneurisation, a démocratisé cette technologie. Il offre une interface simple et intuitive pour créer, partager et gérer des conteneurs. Mais avant d’approfondir les aspects pratiques de Docker, il est essentiel de comprendre les concepts fondamentaux de la conteneurisation : son origine, ses caractéristiques, ses avantages, et ses cas d’usage.</p>
<p>Dans cette première partie, nous explorerons :</p>
<p>L’évolution des infrastructures informatiques, en retraçant le chemin des serveurs physiques aux conteneurs.
Les caractéristiques clés des conteneurs, notamment leur légèreté, leur portabilité et leur capacité d’isolation.
Les avantages stratégiques de la conteneurisation, tels que l’efficacité des ressources, la scalabilité rapide, et la consistance des environnements.
Les cas d’usage courants, qui illustreront pourquoi cette technologie est devenue incontournable pour des architectures modernes comme les microservices ou les pipelines CI/CD.</p>
<p>Enrichie de démonstrations pratiques et de quiz interactifs, cette partie vous donnera les bases nécessaires pour comprendre pourquoi la conteneurisation est une révolution pour l’informatique d’entreprise et pour les développeurs. À la fin de cette section, vous aurez une vision claire de ce que la conteneurisation peut apporter à vos projets, ainsi qu'une bonne compréhension des concepts fondamentaux pour passer à l’utilisation de Docker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i1-quest-ce-que-la-conteneurisation-"><a class="header" href="#i1-quest-ce-que-la-conteneurisation-"><strong>I.1 Qu'est-ce que la Conteneurisation ?</strong></a></h1>
<h2 id="i1a-Évolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><a class="header" href="#i1a-Évolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><strong>I.1.a Évolution des infrastructures : des serveurs physiques aux conteneurs</strong></a></h2>
<p>L'évolution de l'infrastructure informatique est fondamentale pour comprendre pourquoi et comment les conteneurs ont transformé l'informatique moderne.</p>
<ol>
<li>
<p><strong>Serveurs physiques</strong><br />
À l'origine, chaque application fonctionnait sur un serveur physique dédié. Cette configuration impliquait souvent un surdimensionnement des ressources pour gérer les charges maximales, conduisant à un gaspillage considérable.<br />
<em>Exemple : Imaginez un serveur dédié uniquement à une application de gestion de fichiers, mais n’utilisé qu'à 30 % de sa capacité la majorité du temps.</em></p>
</li>
<li>
<p><strong>Machines virtuelles (VMs)</strong><br />
L’introduction des <strong>hyperviseurs</strong> (par exemple, VMware, Hyper-V) a permis de partitionner un serveur physique en plusieurs machines virtuelles, chacune exécutant son propre système d'exploitation. Bien que cette technologie ait optimisé l’utilisation des ressources, elle nécessitait encore une copie complète du système d’exploitation par VM, augmentant la consommation en mémoire et en stockage.<br />
→ Pour approfondir : <a href="https://www.redhat.com/fr/topics/containers/containers-vs-vms">Red Hat – VMs vs Containers</a>.</p>
</li>
<li>
<p><strong>Conteneurs</strong><br />
Contrairement aux VMs, les conteneurs partagent le noyau du système d’exploitation avec leur hôte. Cela les rend légers, rapides à démarrer, et facilement portables. Par exemple, un conteneur peut contenir uniquement une application et ses dépendances, sans inclure un système d'exploitation complet.<br />
→ En savoir plus : <a href="https://docs.docker.com/get-started/overview/">Documentation Docker – Qu'est-ce qu'un conteneur ?</a>.</p>
</li>
</ol>
<p><img src="course/part1/../../img/part1/Container_Evolution.svg" alt="History of contenerization" /></p>
<hr />
<h2 id="i1b-caractéristiques-clés-des-conteneurs"><a class="header" href="#i1b-caractéristiques-clés-des-conteneurs"><strong>I.1.b Caractéristiques clés des conteneurs</strong></a></h2>
<ul>
<li><strong>Légèreté :</strong> Les conteneurs utilisent moins de ressources qu'une VM, car ils ne nécessitent pas un système d'exploitation complet.</li>
<li><strong>Portabilité :</strong> Une fois créé, un conteneur peut être exécuté de manière identique sur un ordinateur local, un serveur on-premise ou dans un environnement cloud.</li>
<li><strong>Isolation :</strong> Grâce aux technologies de namespaces et cgroups, chaque conteneur est isolé du reste du système, évitant ainsi des conflits entre applications.<br />
→ Découvrez les bases des namespaces et cgroups dans la <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">documentation Linux</a>.</li>
</ul>
<hr />
<h2 id="i1c-les-avantages-de-la-conteneurisation"><a class="header" href="#i1c-les-avantages-de-la-conteneurisation"><strong>I.1.c Les avantages de la conteneurisation</strong></a></h2>
<ul>
<li><strong>Efficacité des ressources :</strong> Contrairement aux VMs, les conteneurs partagent le noyau avec l’hôte, ce qui réduit considérablement l’utilisation de la mémoire et des CPU.</li>
<li><strong>Scalabilité rapide :</strong> Les conteneurs peuvent être créés, dupliqués, ou supprimés en quelques secondes, ce qui les rend idéaux pour gérer des charges variables.</li>
<li><strong>Consistance des environnements :</strong> Avec les conteneurs, "ça marche sur ma machine" devient un problème du passé, car chaque conteneur inclut tout ce dont l'application a besoin pour fonctionner.</li>
</ul>
<hr />
<h2 id="i1d-cas-dusage-courants-des-conteneurs"><a class="header" href="#i1d-cas-dusage-courants-des-conteneurs"><strong>I.1.d Cas d’usage courants des conteneurs</strong></a></h2>
<ul>
<li><strong>Microservices :</strong> Permettent de diviser une application complexe en composants plus petits et indépendants.</li>
<li><strong>CI/CD :</strong> Intégration et déploiement continus grâce à des environnements identiques pour le développement, les tests et la production.</li>
<li><strong>Tests :</strong> Facilite la création rapide d'environnements jetables pour tester de nouvelles fonctionnalités.<br />
→ Cas pratique : <a href="https://netflixtechblog.com/">Netflix et les conteneurs</a>: découvrez comment Netflix utilise les conteneurs pour le streaming mondial.</li>
</ul>
<hr />
<h2 id="exercices-pratiques"><a class="header" href="#exercices-pratiques"><strong>Exercices pratiques</strong></a></h2>
<h4 id="exercice-1--comparaison-entre-vms-et-conteneurs"><a class="header" href="#exercice-1--comparaison-entre-vms-et-conteneurs"><strong>Exercice 1 : Comparaison entre VMs et conteneurs</strong></a></h4>
<ol>
<li>Téléchargez <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> et <a href="https://www.virtualbox.org/">VirtualBox</a>.</li>
<li>Démarrez une machine virtuelle avec VirtualBox et installez un serveur web simple comme Apache. Notez les ressources consommées (RAM et CPU).</li>
<li>Démarrez un conteneur avec Docker (exemple : <code>docker run -d -p 8080:80 nginx</code>) et observez les ressources consommées.</li>
<li>Comparez le temps de démarrage, la mémoire et le CPU utilisés entre les deux configurations.</li>
</ol>
<h4 id="exercice-2--visualisation-des-namespaces-et-cgroups"><a class="header" href="#exercice-2--visualisation-des-namespaces-et-cgroups"><strong>Exercice 2 : Visualisation des namespaces et cgroups</strong></a></h4>
<ol>
<li>Lancez un conteneur avec Docker :
<pre><code class="language-bash">docker run -it --name test-container ubuntu /bin/bash
</code></pre>
</li>
<li>Depuis l’hôte, observez les namespaces associés au conteneur en exécutant :
<pre><code class="language-bash">lsns
</code></pre>
</li>
<li>Affichez les cgroups actifs pour le conteneur avec :
<pre><code class="language-bash">cat /sys/fs/cgroup/&lt;group_path&gt;/tasks
</code></pre>
</li>
<li>Résumez vos observations : que voyez-vous en termes d’isolation ?</li>
</ol>
<h2 id="quizz-dintroduction"><a class="header" href="#quizz-dintroduction"><strong>Quizz d'introduction</strong></a></h2>
<p>Vous pouvez maintenant tester votre compréhension des notions de base de Docker avec le quizz suivant :</p>
<div class="quiz-placeholder" data-quiz-name="&quot;intro_quizz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Les conteneurs sont légers car ils n'ont pas besoin d'une instance séparée de système d'exploitation. Ils partagent le noyau de l'hôte.\n&quot;,&quot;id&quot;:&quot;f9d735c0-50dc-483f-8c10-822a08289b52&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Oui, les conteneurs partagent le noyau du système d’exploitation de l’hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Non, les conteneurs possèdent leur propre noyau.&quot;,&quot;Seulement s'ils fonctionnent sur Linux.&quot;],&quot;prompt&quot;:&quot;Les conteneurs partagent-ils le noyau du système d’exploitation de l’hôte ?&quot;}},{&quot;context&quot;:&quot;Les machines virtuelles utilisent un hyperviseur pour émuler un système d'exploitation complet, tandis que les conteneurs s'appuient sur le système de l'hôte, ce qui les rend plus légers et rapides.\n&quot;,&quot;id&quot;:&quot;35c26965-2496-4582-9387-0c35b4e88683&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les conteneurs partagent le noyau du système d’exploitation de l’hôte, tandis que les machines virtuelles émulent un système complet.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs sont plus lourds que les machines virtuelles.&quot;,&quot;Les machines virtuelles n'ont pas besoin de système d'exploitation.&quot;,&quot;Les conteneurs nécessitent un hyperviseur supplémentaire pour fonctionner.&quot;],&quot;prompt&quot;:&quot;Quelle est la principale différence entre les conteneurs et les machines virtuelles ?&quot;}},{&quot;context&quot;:&quot;Un conteneur encapsule tout ce dont une application a besoin pour fonctionner : son code, ses dépendances, et ses configurations, garantissant une cohérence totale entre les environnements.\n&quot;,&quot;id&quot;:&quot;55e1ea81-626a-4249-87d2-61dbb395a33a&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;application, dépendances&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est une unité légère et portable d'___ et de ses ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont idéaux pour des scénarios nécessitant une scalabilité, une portabilité et une cohérence, comme les microservices ou les pipelines CI/CD.\n&quot;,&quot;id&quot;:&quot;ec577900-6ec8-4305-946f-3d0850e74b8e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Une architecture basée sur les microservices.&quot;,&quot;Des pipelines d'intégration et de déploiement continus (CI/CD).&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Exécution d'une seule application sur un matériel dédié.&quot;,&quot;Déploiement d’une application monolithique sans mises à jour fréquentes.&quot;,&quot;Traitement par lots sur des serveurs bare-metal.&quot;],&quot;prompt&quot;:&quot;Quels scénarios bénéficient le plus de la conteneurisation ? (Choisissez deux)&quot;}},{&quot;context&quot;:&quot;Les serveurs physiques exécutent directement les applications sur le matériel. Les VMs émulent des environnements OS complets. Les conteneurs partagent le noyau de l’hôte.\n&quot;,&quot;id&quot;:&quot;f532170e-dd96-46a6-91c0-e7bdd59dfc1c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Serveurs physiques : Application unique, non virtualisée.&quot;,&quot;Machines virtuelles : Lourd, émulation complète d'OS.&quot;,&quot;Conteneurs : Léger, partage le noyau de l'hôte.&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Conteneurs : Lourds, émulation complète d'OS.&quot;,&quot;Serveurs physiques : Partage des ressources, processus isolés.&quot;,&quot;Machines virtuelles : Partagent le noyau de l'hôte.&quot;],&quot;prompt&quot;:&quot;Associez les technologies suivantes à leurs caractéristiques : serveurs physiques, machines virtuelles, conteneurs.&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'assurer une isolation au sein des conteneurs, séparant les processus et ressources de l'hôte et des autres conteneurs.\n&quot;,&quot;id&quot;:&quot;6c07415e-b848-499f-8bc1-806143d72bd1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Isoler les processus, systèmes de fichiers et interfaces réseau.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Contrôler la quantité de ressources (CPU, RAM) qu’un conteneur peut utiliser.&quot;,&quot;Gérer les dépendances logicielles à l’intérieur d’un conteneur.&quot;],&quot;prompt&quot;:&quot;Dans une architecture conteneurisée, quel est le rôle des namespaces ?&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'isoler les processus, les systèmes de fichiers, et les interfaces réseau des conteneurs, garantissant une séparation totale entre les conteneurs et l'hôte.\n&quot;,&quot;id&quot;:&quot;cfb52846-c478-4a66-a918-28241abf55ee&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;processus, systèmes de fichiers, interfaces réseau&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Dans une architecture conteneurisée, les namespaces servent à isoler ___, ___ et ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont conçus pour être plus légers et démarrer plus rapidement que les machines virtuelles, car ils n'ont pas besoin d'inclure un système d'exploitation complet.\n&quot;,&quot;id&quot;:&quot;56d269f9-466c-4526-ad36-b7fd5c06b5ba&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;léger, rapidement&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est plus ___ et démarre plus ___ qu'une machine virtuelle.&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="i2-installing-docker-and-understanding-the-docker-cli"><a class="header" href="#i2-installing-docker-and-understanding-the-docker-cli"><strong>I.2 Installing Docker and Understanding the Docker CLI</strong></a></h1>
<p>Cette section se concentre sur l'installation de Docker et la maîtrise des commandes fondamentales de son interface en ligne de commande (CLI).</p>
<h2 id="i2a-installation-de-docker"><a class="header" href="#i2a-installation-de-docker"><strong>I.2.a Installation de Docker</strong></a></h2>
<p>Docker peut être installé sur Windows, macOS et Linux. Les étapes spécifiques varient selon le système d’exploitation. La <a href="https://docs.docker.com/engine/install/">documentation officielle d’installation de Docker</a> fournit un guide complet pour configurer Docker Desktop (Windows/macOS) ou Docker Engine (Linux).</p>
<p>Une fois installé, vérifiez la version de Docker sur votre système avec la commande suivante :</p>
<pre><code class="language-bash">docker --version
</code></pre>
<p>Pour tester le bon fonctionnement de Docker, exécutez un conteneur de test :</p>
<pre><code class="language-bash">docker run hello-world
</code></pre>
<p>Cette commande lance un conteneur qui affiche un message de confirmation si Docker est configuré correctement.</p>
<hr />
<h2 id="i2b-comprendre-les-commandes-de-base-du-docker-cli"><a class="header" href="#i2b-comprendre-les-commandes-de-base-du-docker-cli"><strong>I.2.b Comprendre les commandes de base du Docker CLI</strong></a></h2>
<p>Docker CLI est l'outil principal pour interagir avec Docker. Il permet de gérer les conteneurs, les images et d’autres éléments liés à Docker. Voici un aperçu des commandes essentielles.</p>
<hr />
<h3 id="gestion-des-images"><a class="header" href="#gestion-des-images"><strong>Gestion des images</strong></a></h3>
<p>Les images Docker servent de base pour créer des conteneurs. Voici les commandes principales :</p>
<ul>
<li>
<p><strong>Lister les images disponibles localement :</strong></p>
<pre><code class="language-bash">docker image ls
</code></pre>
<p>Cette commande affiche toutes les images présentes sur votre machine. Pour des détails supplémentaires, consultez la <a href="https://docs.docker.com/reference/cli/docker/image/">documentation docker image ls</a>.</p>
</li>
<li>
<p><strong>Télécharger une image depuis Docker Hub :</strong></p>
<pre><code class="language-bash">docker pull &lt;image_name&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker pull nginx
</code></pre>
<p>Cette commande télécharge l’image <code>nginx</code> depuis Docker Hub. En savoir plus dans la <a href="https://docs.docker.com/reference/cli/docker/image/pull/">documentation docker pull</a>.</p>
</li>
<li>
<p><strong>Supprimer une image locale :</strong></p>
<pre><code class="language-bash">docker image rm &lt;image_id&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker image rm nginx
</code></pre>
<p>Cela supprime l'image <code>nginx</code> de votre système. Consultez la <a href="https://docs.docker.com/reference/cli/docker/image/rm/">documentation docker image rm</a> pour plus d'informations.</p>
</li>
</ul>
<hr />
<h3 id="gestion-des-conteneurs"><a class="header" href="#gestion-des-conteneurs"><strong>Gestion des conteneurs</strong></a></h3>
<p>Un conteneur est une instance en cours d’exécution d’une image Docker. Voici comment gérer les conteneurs :</p>
<ul>
<li>
<p><strong>Créer et démarrer un nouveau conteneur :</strong></p>
<pre><code class="language-bash">docker run &lt;image_name&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker run nginx
</code></pre>
<p>Cela démarre un conteneur basé sur l’image <code>nginx</code>. Pour explorer toutes les options, référez-vous à la <a href="https://docs.docker.com/reference/cli/docker_run/">documentation docker run</a>.</p>
</li>
<li>
<p><strong>Lister les conteneurs actifs :</strong></p>
<pre><code class="language-bash">docker ps
</code></pre>
<p>Pour afficher également les conteneurs arrêtés, ajoutez l’option <code>-a</code> :</p>
<pre><code class="language-bash">docker ps -a
</code></pre>
<p>Consultez la <a href="https://docs.docker.com/reference/cli/docker_ps/">documentation docker ps</a> pour une explication complète des options disponibles.</p>
</li>
<li>
<p><strong>Arrêter un conteneur actif :</strong></p>
<pre><code class="language-bash">docker stop &lt;container_id&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker stop my_nginx
</code></pre>
<p>La commande <code>docker stop</code> envoie un signal SIGTERM au conteneur pour l’arrêter proprement. En savoir plus : <a href="https://docs.docker.com/reference/cli/docker_stop/">documentation docker stop</a>.</p>
</li>
<li>
<p><strong>Redémarrer un conteneur existant :</strong></p>
<pre><code class="language-bash">docker start &lt;container_id&gt;
</code></pre>
<p>Cela relance un conteneur qui a été précédemment arrêté.</p>
</li>
<li>
<p><strong>Supprimer un conteneur arrêté :</strong></p>
<pre><code class="language-bash">docker rm &lt;container_id&gt;
</code></pre>
<p>Cette commande supprime un conteneur arrêté de votre système. Référez-vous à la <a href="https://docs.docker.com/reference/cli/docker_rm/">documentation docker rm</a> pour plus de détails.</p>
</li>
</ul>
<hr />
<h2 id="i2c-explorer-laide-et-la-documentation-docker"><a class="header" href="#i2c-explorer-laide-et-la-documentation-docker"><strong>I.2.c Explorer l’aide et la documentation Docker</strong></a></h2>
<p>Docker CLI fournit des outils intégrés pour accéder à l’aide et aux descriptions des commandes :</p>
<ul>
<li>
<p><strong>Afficher une liste des commandes disponibles :</strong></p>
<pre><code class="language-bash">docker --help
</code></pre>
</li>
<li>
<p><strong>Obtenir des détails sur une commande spécifique :</strong></p>
<pre><code class="language-bash">docker &lt;command&gt; --help
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker run --help
</code></pre>
<p>Cette commande liste les options et paramètres disponibles pour <code>docker run</code>.</p>
</li>
</ul>
<p>Pour une exploration approfondie des fonctionnalités, consultez la <a href="https://docs.docker.com/engine/reference/commandline/docker/">documentation officielle de Docker CLI</a>.</p>
<h2 id="exercices"><a class="header" href="#exercices"><strong>Exercices</strong></a></h2>
<details>
    <summary>Installation de Docker</summary>
Apprenez à installer Docker sur votre machine et à vérifier qu'il est correctement configuré. Cet exercice couvre le téléchargement, l'installation et l'exécution de l'image de test `hello-world`.
</details>
<details>
    <summary>Premier conteneur Docker</summary>
Exécutez votre premier conteneur Docker à l'aide de l'image `hello-world`. Comprenez comment Docker télécharge les images et exécute des conteneurs.
</details>
<details>
    <summary>Exploration des commandes Docker</summary>
Explorez les commandes de base de Docker comme `docker ps`, `docker images`, `docker run` et bien d'autres. Apprenez à interagir avec les conteneurs et à inspecter les images sur votre système.
</details>
<details>
    <summary>Exploration manuelle d’un conteneur</summary>
Plongez dans un conteneur en cours d'exécution pour explorer son système de fichiers, installer des paquets et comprendre le fonctionnement interne des conteneurs.
</details>
<details>
    <summary>Exploration de la documentation Docker</summary>
Apprenez à naviguer dans la documentation officielle de Docker et à utiliser les commandes d’aide intégrées comme `docker --help` pour trouver des informations sur les fonctionnalités et commandes Docker.
</details>
<h2 id="quizz"><a class="header" href="#quizz"><strong>Quizz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;docker_basics&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;La commande `docker run` crée et démarre un nouveau conteneur au premier plan par défaut, sauf indication contraire.\n&quot;,&quot;id&quot;:&quot;a98cbf8c-0852-4e9c-9891-9fd46d308f4a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker run&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker start&quot;,&quot;docker exec&quot;,&quot;docker attach&quot;],&quot;prompt&quot;:&quot;Laquelle de ces commandes démarre un conteneur au premier plan ?&quot;}},{&quot;context&quot;:&quot;Le démon Docker (dockerd) est un service système qui exécute et gère les conteneurs, surveillant les images et les volumes.\n&quot;,&quot;id&quot;:&quot;de0f74d8-0f6e-4686-b6f0-3a6541aa96d5&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Le démon Docker gère les conteneurs et les images en arrière-plan, et il communique avec le client Docker via l'API.&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel est le rôle du démon Docker ?&quot;}},{&quot;context&quot;:&quot;La commande `docker --version` permet de vérifier la version installée de Docker et de s'assurer qu'il est correctement installé.\n&quot;,&quot;id&quot;:&quot;a75dabf8-b9ef-4895-82d7-eefbfb2781ba&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker --version&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker -help&quot;,&quot;docker ps&quot;,&quot;docker status&quot;],&quot;prompt&quot;:&quot;Après avoir installé Docker, quelle commande permet de vérifier que l'installation a réussi ?&quot;}},{&quot;context&quot;:&quot;La commande `docker ps` liste uniquement les conteneurs actifs, tandis que l'option `-a` (all) inclut tous les conteneurs créés, actifs ou inactifs.\n&quot;,&quot;id&quot;:&quot;8f1b9651-0bbf-41a8-bab2-c500d6e14e26&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`docker ps` affiche uniquement les conteneurs en cours d'exécution, tandis que `docker ps -a` affiche tous les conteneurs, y compris ceux arrêtés.&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle est la différence entre `docker ps` et `docker ps -a` ?&quot;}},{&quot;context&quot;:&quot;Le flag `-it` combine `-i` (mode interactif) et `-t` (pseudo-terminal), permettant une interaction directe avec le conteneur.\n&quot;,&quot;id&quot;:&quot;bbf4f901-8310-4eee-b402-1f381c387d99&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;-it&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;-d&quot;,&quot;-rm&quot;,&quot;-exec&quot;],&quot;prompt&quot;:&quot;Quel flag est utilisé pour exécuter un conteneur de manière interactive ?&quot;}},{&quot;context&quot;:&quot;Lorsque `docker ps` est utilisé sans conteneurs actifs, la sortie n'affiche rien d'autre que les colonnes `CONTAINER ID`, `IMAGE`, etc.\n&quot;,&quot;id&quot;:&quot;9acdbfdf-09ba-402e-ae3d-6b713d41de2e&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;La commande retourne un tableau vide avec seulement les en-têtes des colonnes.&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Que se passe-t-il si vous exécutez `docker ps` sans aucun conteneur en cours d'exécution ?&quot;}},{&quot;context&quot;:&quot;La commande `docker images` affiche toutes les images téléchargées et disponibles localement sur votre machine.\n&quot;,&quot;id&quot;:&quot;231d1d8e-1621-4a6a-816e-e2ed41a89da1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker images&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker ps&quot;,&quot;docker pull&quot;,&quot;docker volume ls&quot;],&quot;prompt&quot;:&quot;Quelle commande CLI liste toutes les images disponibles sur votre système local ?&quot;}},{&quot;context&quot;:&quot;Lors de l'installation de Docker, les problèmes liés aux permissions ou au démarrage du service sont fréquents. Les solutions incluent la configuration du groupe Docker ou le redémarrage du démon.\n&quot;,&quot;id&quot;:&quot;a3116060-7dc6-4131-a0de-185154b17d9d&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;1. Problème : Docker nécessite des privilèges d'administrateur. Solution : Ajoutez votre utilisateur au groupe Docker avec la commande `sudo usermod -aG docker &lt;votre_utilisateur&gt;`.\n2. Problème : Le service Docker ne démarre pas. Solution : Redémarrez le service avec `sudo systemctl restart docker`.\n&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Citez deux problèmes courants lors de l'installation de Docker et comment les résoudre.&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="i3-images-et-conteneurs"><a class="header" href="#i3-images-et-conteneurs"><strong>I.3 Images et Conteneurs</strong></a></h1>
<p>Les <strong>images</strong> et les <strong>conteneurs</strong> sont au cœur de la technologie Docker. Comprendre leur relation et savoir les manipuler est essentiel pour utiliser Docker efficacement. Cette section explore leur rôle, leur gestion, et leurs interactions.</p>
<h2 id="i3a-relation-entre-les-images-et-les-conteneurs"><a class="header" href="#i3a-relation-entre-les-images-et-les-conteneurs"><strong>I.3.a Relation entre les images et les conteneurs</strong></a></h2>
<ul>
<li>
<p><strong>Les images :</strong><br />
Une image Docker est un modèle statique qui contient tout ce dont une application a besoin pour fonctionner (code, bibliothèques, configurations, etc.). C'est un blueprint (ou plan) pour créer des conteneurs.<br />
Exemple : Une image <code>nginx</code> contient le serveur web Nginx et ses dépendances.</p>
</li>
<li>
<p><strong>Les conteneurs :</strong><br />
Un conteneur est une instance en cours d'exécution d'une image. Il est éphémère et peut être arrêté, redémarré, ou supprimé sans affecter l'image sous-jacente.<br />
Exemple : Lancer un conteneur à partir de l'image <code>nginx</code> démarre un serveur web.</p>
</li>
</ul>
<p>En résumé :</p>
<ul>
<li><strong>Image</strong> = Modèle de base.</li>
<li><strong>Conteneur</strong> = Instance opérationnelle de l'image.</li>
</ul>
<hr />
<h2 id="i3b-gestion-des-images-docker"><a class="header" href="#i3b-gestion-des-images-docker"><strong>I.3.b Gestion des images Docker</strong></a></h2>
<h5 id="télécharger-des-images-depuis-docker-hub"><a class="header" href="#télécharger-des-images-depuis-docker-hub"><strong>Télécharger des images depuis Docker Hub</strong></a></h5>
<p>Docker Hub est le dépôt public par défaut pour les images Docker. Vous pouvez télécharger une image avec la commande suivante :</p>
<pre><code class="language-bash">docker pull &lt;image_name&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker pull nginx
</code></pre>
<p>Cela télécharge l’image <code>nginx</code> depuis Docker Hub. Consultez la <a href="https://docs.docker.com/reference/cli/docker/image/pull/">documentation docker pull</a> pour plus de détails.</p>
<hr />
<h5 id="créer-des-images-personnalisées-avec-dockerfiles"><a class="header" href="#créer-des-images-personnalisées-avec-dockerfiles"><strong>Créer des images personnalisées avec Dockerfiles</strong></a></h5>
<p>Un <strong>Dockerfile</strong> est un fichier texte contenant une série d’instructions pour construire une image Docker personnalisée. Voici un exemple simple :</p>
<p><strong>Exemple de Dockerfile :</strong></p>
<pre><code class="language-Dockerfile"># Base de l'image
FROM python:3.9

# Ajouter des fichiers locaux dans l'image
COPY app.py /app/app.py

# Définir le répertoire de travail
WORKDIR /app

# Installer des dépendances
RUN pip install flask

# Définir la commande à exécuter
CMD ["python", "app.py"]
</code></pre>
<p>Pour construire une image à partir de ce Dockerfile, utilisez la commande :</p>
<pre><code class="language-bash">docker build -t my_custom_image .
</code></pre>
<ul>
<li><code>-t</code> permet de donner un nom (<code>my_custom_image</code>) à l'image.</li>
<li>Le <code>.</code> indique que le Dockerfile se trouve dans le répertoire actuel.</li>
</ul>
<p>En savoir plus : <a href="https://docs.docker.com/engine/reference/builder/">documentation Dockerfile</a>.</p>
<hr />
<h5 id="lister-et-supprimer-des-images"><a class="header" href="#lister-et-supprimer-des-images"><strong>Lister et supprimer des images</strong></a></h5>
<ul>
<li>
<p><strong>Lister les images locales :</strong></p>
<pre><code class="language-bash">docker image ls
</code></pre>
</li>
<li>
<p><strong>Supprimer une image :</strong></p>
<pre><code class="language-bash">docker image rm &lt;image_id&gt;
</code></pre>
<p>Si une image est utilisée par un conteneur actif, elle ne pourra pas être supprimée.</p>
</li>
</ul>
<p>Pour des explications supplémentaires, consultez la <a href="https://docs.docker.com/reference/cli/docker/image/rm/">documentation docker image rm</a>.</p>
<hr />
<h4 id="i3c-gestion-des-conteneurs-docker"><a class="header" href="#i3c-gestion-des-conteneurs-docker"><strong>I.3.c Gestion des conteneurs Docker</strong></a></h4>
<h5 id="créer-et-exécuter-des-conteneurs"><a class="header" href="#créer-et-exécuter-des-conteneurs"><strong>Créer et exécuter des conteneurs</strong></a></h5>
<ul>
<li>
<p><strong>Créer un conteneur :</strong></p>
<pre><code class="language-bash">docker run &lt;image_name&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker run nginx
</code></pre>
</li>
<li>
<p><strong>Donner un nom à un conteneur :</strong></p>
<pre><code class="language-bash">docker run --name my_nginx nginx
</code></pre>
<p>Le flag <code>--name</code> facilite la gestion des conteneurs en leur attribuant des noms lisibles.</p>
</li>
</ul>
<hr />
<h5 id="démarrer-arrêter-et-redémarrer-des-conteneurs"><a class="header" href="#démarrer-arrêter-et-redémarrer-des-conteneurs"><strong>Démarrer, arrêter et redémarrer des conteneurs</strong></a></h5>
<ul>
<li>
<p><strong>Lister les conteneurs actifs :</strong></p>
<pre><code class="language-bash">docker ps
</code></pre>
</li>
<li>
<p><strong>Arrêter un conteneur actif :</strong></p>
<pre><code class="language-bash">docker stop &lt;container_id&gt;
</code></pre>
</li>
<li>
<p><strong>Redémarrer un conteneur arrêté :</strong></p>
<pre><code class="language-bash">docker start &lt;container_id&gt;
</code></pre>
</li>
<li>
<p><strong>Supprimer un conteneur arrêté :</strong></p>
<pre><code class="language-bash">docker rm &lt;container_id&gt;
</code></pre>
</li>
</ul>
<hr />
<h5 id="conteneurs-interactifs"><a class="header" href="#conteneurs-interactifs"><strong>Conteneurs interactifs</strong></a></h5>
<p>Docker permet d’interagir directement avec des conteneurs actifs via les commandes suivantes :</p>
<ul>
<li>
<p><strong>Exécuter une commande dans un conteneur en cours d'exécution :</strong></p>
<pre><code class="language-bash">docker exec -it &lt;container_id&gt; &lt;command&gt;
</code></pre>
<p>Exemple : Ouvrir un terminal bash dans un conteneur :</p>
<pre><code class="language-bash">docker exec -it &lt;container_id&gt; /bin/bash
</code></pre>
<p>Consultez la <a href="https://docs.docker.com/reference/cli/docker_exec/">documentation docker exec</a> pour plus d'options.</p>
</li>
<li>
<p><strong>Attacher au terminal d’un conteneur :</strong></p>
<pre><code class="language-bash">docker attach &lt;container_id&gt;
</code></pre>
<p>Cette commande connecte votre terminal actuel au terminal du conteneur.</p>
</li>
</ul>
<p><strong>Différence entre <code>exec</code> et <code>attach</code> :</strong></p>
<ul>
<li><code>docker exec</code> crée une nouvelle session dans le conteneur.</li>
<li><code>docker attach</code> attache votre terminal à la session principale du conteneur.</li>
</ul>
<h2 id="exercices-1"><a class="header" href="#exercices-1"><strong>Exercices</strong></a></h2>
<details>
  <summary>Gestion des images</summary>
<h3 id="objectif"><a class="header" href="#objectif">Objectif</a></h3>
<p>Apprendre à gérer les images Docker : les télécharger, les lister, les supprimer et inspecter leurs détails.</p>
<hr />
<h3 id="Étapes"><a class="header" href="#Étapes">Étapes</a></h3>
<ol>
<li>
<p><strong>Télécharger une image</strong></p>
<ul>
<li>Téléchargez l'image <code>nginx</code> à partir de Docker Hub en utilisant la commande :
<pre><code class="language-bash">docker pull nginx
</code></pre>
</li>
<li>Vérifiez que l'image a bien été téléchargée en listant toutes les images disponibles sur votre machine :
<pre><code class="language-bash">docker image ls
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lister les images</strong></p>
<ul>
<li>Observez les informations fournies par <code>docker image ls</code>. Identifiez le <code>REPOSITORY</code>, le <code>TAG</code> et l'<code>IMAGE ID</code> de l'image <code>nginx</code>.</li>
</ul>
</li>
<li>
<p><strong>Inspecter une image</strong></p>
<ul>
<li>Utilisez la commande suivante pour inspecter les détails techniques de l'image <code>nginx</code> :
<pre><code class="language-bash">docker inspect nginx
</code></pre>
</li>
<li>Notez des informations comme la taille de l'image et son point d'entrée (<code>ENTRYPOINT</code>).</li>
</ul>
</li>
<li>
<p><strong>Supprimer une image</strong></p>
<ul>
<li>Supprimez l'image <code>nginx</code> de votre système :
<pre><code class="language-bash">docker image rm nginx
</code></pre>
</li>
<li>Vérifiez que l'image a bien été supprimée en relançant <code>docker image ls</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu"><a class="header" href="#résultat-attendu">Résultat attendu</a></h3>
<ul>
<li>Vous avez téléchargé, listé, inspecté et supprimé une image Docker. À la fin de l'exercice, la commande <code>docker image ls</code> ne doit plus afficher l'image <code>nginx</code>.</li>
</ul>
<hr />
<h3 id="problèmes-potentiels"><a class="header" href="#problèmes-potentiels">Problèmes potentiels</a></h3>
<ul>
<li>Si vous ne parvenez pas à supprimer une image, vérifiez qu'aucun conteneur utilisant cette image n'est en cours d'exécution avec :
<pre><code class="language-bash">docker ps -a
</code></pre>
Ensuite, supprimez les conteneurs associés avec :
<pre><code class="language-bash">docker rm &lt;container_id&gt;
</code></pre>
</li>
</ul>
</details>
<details>
  <summary>Cycle de vie des conteneurs</summary>
<h3 id="objectif-1"><a class="header" href="#objectif-1">Objectif</a></h3>
<p>Comprendre et manipuler les différentes étapes du cycle de vie d’un conteneur Docker.</p>
<hr />
<h3 id="Étapes-1"><a class="header" href="#Étapes-1">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un conteneur</strong></p>
<ul>
<li>Créez un conteneur basé sur l’image <code>nginx</code> sans l’exécuter immédiatement :
<pre><code class="language-bash">docker create nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lister les conteneurs créés</strong></p>
<ul>
<li>Listez tous les conteneurs (en cours d’exécution ou non) avec :
<pre><code class="language-bash">docker ps -a
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Exécuter un conteneur</strong></p>
<ul>
<li>Démarrez le conteneur créé précédemment avec :
<pre><code class="language-bash">docker start &lt;container_id&gt;
</code></pre>
</li>
<li>Vérifiez qu’il fonctionne avec :
<pre><code class="language-bash">docker ps
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Suspendre et reprendre un conteneur</strong></p>
<ul>
<li>Suspendez le conteneur en cours d’exécution :
<pre><code class="language-bash">docker pause &lt;container_id&gt;
</code></pre>
</li>
<li>Reprenez son exécution :
<pre><code class="language-bash">docker unpause &lt;container_id&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Arrêter et supprimer un conteneur</strong></p>
<ul>
<li>Arrêtez le conteneur :
<pre><code class="language-bash">docker stop &lt;container_id&gt;
</code></pre>
</li>
<li>Supprimez-le :
<pre><code class="language-bash">docker rm &lt;container_id&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-1"><a class="header" href="#résultat-attendu-1">Résultat attendu</a></h3>
<p>Vous avez créé, démarré, suspendu, repris, arrêté et supprimé un conteneur Docker.</p>
</details>
<details>
  <summary>Création d’images personnalisées</summary>
<h3 id="objectif-2"><a class="header" href="#objectif-2">Objectif</a></h3>
<p>Créer une image Docker personnalisée à l’aide d’un <code>Dockerfile</code>.</p>
<hr />
<h3 id="Étapes-2"><a class="header" href="#Étapes-2">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un fichier <code>Dockerfile</code></strong></p>
<ul>
<li>Créez un fichier <code>Dockerfile</code> contenant les instructions suivantes :
<pre><code class="language-Dockerfile">FROM alpine
RUN apk add --no-cache curl
CMD ["curl", "--help"]
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Construire l’image</strong></p>
<ul>
<li>Construisez une image Docker à partir du <code>Dockerfile</code> :
<pre><code class="language-bash">docker build -t custom-curl .
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Vérifier l’image</strong></p>
<ul>
<li>Listez les images pour vérifier que votre image personnalisée a été créée :
<pre><code class="language-bash">docker image ls
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Exécuter un conteneur basé sur l’image</strong></p>
<ul>
<li>Lancez un conteneur basé sur l’image :
<pre><code class="language-bash">docker run custom-curl
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-2"><a class="header" href="#résultat-attendu-2">Résultat attendu</a></h3>
<p>Vous avez créé une image Docker personnalisée, construite et exécutée un conteneur basé sur cette image.</p>
</details>
<details>
  <summary>Intégration avec Docker Hub</summary>
<h3 id="objectif-3"><a class="header" href="#objectif-3">Objectif</a></h3>
<p>Apprendre à interagir avec Docker Hub : marquer et publier une image Docker.</p>
<hr />
<h3 id="Étapes-3"><a class="header" href="#Étapes-3">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un compte Docker Hub</strong></p>
<ul>
<li>Créez un compte sur <a href="https://hub.docker.com">Docker Hub</a> si ce n’est pas encore fait.</li>
</ul>
</li>
<li>
<p><strong>Taguer une image</strong></p>
<ul>
<li>Téléchargez l’image <code>nginx</code> si elle n’est pas déjà disponible localement :
<pre><code class="language-bash">docker pull nginx
</code></pre>
</li>
<li>Marquez l’image pour la publier sous votre nom d’utilisateur :
<pre><code class="language-bash">docker tag nginx &lt;votre_nom_utilisateur&gt;/nginx-custom
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Publier l’image</strong></p>
<ul>
<li>Connectez-vous à Docker Hub via le terminal :
<pre><code class="language-bash">docker login
</code></pre>
</li>
<li>Poussez l’image sur Docker Hub :
<pre><code class="language-bash">docker push &lt;votre_nom_utilisateur&gt;/nginx-custom
</code></pre>
</li>
</ul>
</li>
</ol>
<p>docker login <a href="https://docs.docker.com/reference/cli/docker/login/">documentation</a></p>
<ol start="4">
<li><strong>Vérifier sur Docker Hub</strong>
<ul>
<li>Connectez-vous à Docker Hub et vérifiez que l’image a bien été publiée.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-3"><a class="header" href="#résultat-attendu-3">Résultat attendu</a></h3>
<p>L’image est disponible sur Docker Hub sous votre compte.</p>
</details>
<details>
  <summary>Inspection des conteneurs</summary>
<h3 id="objectif-4"><a class="header" href="#objectif-4">Objectif</a></h3>
<p>Inspecter et surveiller les conteneurs Docker en cours d'exécution.</p>
<hr />
<h3 id="Étapes-4"><a class="header" href="#Étapes-4">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer un conteneur</strong></p>
<ul>
<li>Lancez un conteneur <code>nginx</code> :
<pre><code class="language-bash">docker run -d nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Inspecter le conteneur</strong></p>
<ul>
<li>Inspectez les détails techniques du conteneur :
<pre><code class="language-bash">docker inspect &lt;container_id&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Afficher les journaux</strong></p>
<ul>
<li>Consultez les journaux d'exécution du conteneur :
<pre><code class="language-bash">docker logs &lt;container_id&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Surveiller les ressources</strong></p>
<ul>
<li>Surveillez l’utilisation des ressources du conteneur :
<pre><code class="language-bash">docker stats &lt;container_id&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-4"><a class="header" href="#résultat-attendu-4">Résultat attendu</a></h3>
<p>Vous avez inspecté les métadonnées, les journaux et les performances d’un conteneur Docker.</p>
</details>
<h2 id="quizz-1"><a class="header" href="#quizz-1"><strong>Quizz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;images_and_containers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Les données peuvent être persistées dans des volumes ou des montages même si le conteneur n'est plus actif.\n&quot;,&quot;id&quot;:&quot;205941ce-0764-4490-9e58-4516032b28c7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Faux&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Vrai&quot;],&quot;prompt&quot;:&quot;Un conteneur Docker doit toujours être en cours d'exécution pour conserver des données. Est-ce vrai ou faux ?&quot;}},{&quot;context&quot;:&quot;La commande `docker build` permet de créer une image Docker à partir d'un fichier Dockerfile en spécifiant le chemin ou le contexte de construction.\n&quot;,&quot;id&quot;:&quot;67a3de6f-2eca-4a6b-aa19-a5af60e3971d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker build&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker pull&quot;,&quot;docker run&quot;,&quot;docker create&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour construire une image Docker à partir d'un Dockerfile ?&quot;}},{&quot;context&quot;:&quot;`docker pull` interagit avec des registres distants comme DockerHub, tandis que `docker build` est utilisé pour construire des images personnalisées localement.\n&quot;,&quot;id&quot;:&quot;5f99be4f-b419-4105-849b-4908abf696c8&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`docker pull` télécharge une image existante depuis un registre distant, tandis que `docker build` crée une nouvelle image localement à partir d'un Dockerfile.&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Expliquez la différence entre `docker pull` et `docker build`.&quot;}},{&quot;context&quot;:&quot;La commande `docker rmi &lt;nom_image&gt;` supprime les images locales spécifiées par leur ID ou leur nom.\n&quot;,&quot;id&quot;:&quot;c223edaa-440e-4b41-a7bc-88ffe98e171d&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker rmi&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Pour supprimer une image locale, vous utilisez la commande ___ ?&quot;}},{&quot;context&quot;:&quot;Chaque construction d'image crée un nouvel identifiant unique. Les anciennes images restent accessibles sauf si elles sont explicitement supprimées.\n&quot;,&quot;id&quot;:&quot;5af753bc-0a8e-40aa-9d6d-e5fe32005129&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;L'image précédente reste disponible mais est inutilisée.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;L'image précédente est écrasée.&quot;,&quot;L'image précédente est supprimée.&quot;,&quot;L'image précédente reste disponible mais est inutilisée.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il si vous modifiez un Dockerfile et reconstruisez l'image ?&quot;}},{&quot;context&quot;:&quot;`docker exec` permet d'exécuter des commandes dans un conteneur actif, par exemple ouvrir un terminal avec `docker exec -it &lt;nom_conteneur&gt; bash`.\n&quot;,&quot;id&quot;:&quot;56273de0-b6c5-4634-af63-8241ad8a5126&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Oui&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Non&quot;,&quot;Uniquement pour consulter les journaux&quot;,&quot;Uniquement si le conteneur est interactif&quot;],&quot;prompt&quot;:&quot;La commande `docker exec` permet-elle d'interagir avec un conteneur en cours d'exécution ?&quot;}},{&quot;context&quot;:&quot;Les états valides d'un conteneur incluent `running`, `stopped`, ou `paused`. Il n'existe pas d'état appelé `unconfigured`.\n&quot;,&quot;id&quot;:&quot;e30a457e-1473-4f0a-96a0-db01e6e1696e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Non configuré (unconfigured)&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;En cours d'exécution (running)&quot;,&quot;Arrêté (stopped)&quot;,&quot;Gelé (frozen)&quot;],&quot;prompt&quot;:&quot;Laquelle des options suivantes n'est pas un état valide pour un conteneur ?&quot;}},{&quot;context&quot;:&quot;Le cycle de vie d'un conteneur passe par les étapes : création, exécution, arrêt, et suppression éventuelle.\n&quot;,&quot;id&quot;:&quot;87ec29f3-263d-4d86-b673-b7cc380e0759&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Créer, exécuter, stopper, supprimer&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Créer, stopper, supprimer&quot;,&quot;Créer, exécuter, arrêter uniquement&quot;,&quot;Créer, démarrer, supprimer uniquement&quot;],&quot;prompt&quot;:&quot;Identifiez les étapes du cycle de vie d'un conteneur Docker : (Options : créer, exécuter, stopper, supprimer)&quot;}},{&quot;context&quot;:&quot;Pour publier une image sur DockerHub, elle doit être taggée correctement avec le nom du registre et un tag, puis poussée avec `docker\n&quot;,&quot;id&quot;:&quot;1908a8ad-462b-404e-8445-e5a20bf3424c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Vous exécutez `docker tag` suivi de `docker push` pour envoyer l'image sur DockerHub.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Vous taguez l'image avec `docker tag` et exécutez `docker save`.&quot;,&quot;Vous exécutez `docker tag` suivi de `docker push` pour envoyer l'image sur DockerHub.&quot;,&quot;Vous utilisez uniquement `docker push` sans taggage.&quot;],&quot;prompt&quot;:&quot;Quelle est la meilleure description du processus de push et de taggage d'une image sur DockerHub ?&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="i4-gestion-des-données-avec-les-volumes-et-les-bind-mount"><a class="header" href="#i4-gestion-des-données-avec-les-volumes-et-les-bind-mount"><strong>I.4 Gestion des données avec les Volumes et les Bind Mount</strong></a></h1>
<hr />
<p>Les conteneurs Docker sont par nature éphémères. Une fois arrêtés ou supprimés, les données générées dans le conteneur disparaissent. Pour garantir une persistance des données ou partager des fichiers entre l’hôte et les conteneurs, Docker offre deux solutions principales : <strong>les volumes</strong> et <strong>les bind mounts</strong>. Cette section explore ces concepts et leurs cas d’usage.</p>
<hr />
<h2 id="i4a-stockage-persistant-dans-les-conteneurs"><a class="header" href="#i4a-stockage-persistant-dans-les-conteneurs"><strong>I.4.a Stockage persistant dans les conteneurs</strong></a></h2>
<h3 id="volumes--stockage-géré-par-docker"><a class="header" href="#volumes--stockage-géré-par-docker"><strong>Volumes : Stockage géré par Docker</strong></a></h3>
<p>Les volumes sont des unités de stockage gérées directement par Docker. Ils sont indépendants du cycle de vie des conteneurs et sont stockés dans un répertoire contrôlé par Docker, généralement dans <code>/var/lib/docker/volumes/</code>.</p>
<p><strong>Caractéristiques des volumes :</strong></p>
<ul>
<li>Créés et gérés via le CLI Docker.</li>
<li>Conçus pour être sécurisés, performants et portables entre hôtes Docker.</li>
<li>Ils ne nécessitent pas de chemin spécifique sur l’hôte.</li>
</ul>
<p><strong>Créer un volume :</strong></p>
<pre><code class="language-bash">docker volume create my_volume
</code></pre>
<p><strong>Monter un volume dans un conteneur :</strong></p>
<pre><code class="language-bash">docker run -v my_volume:/data nginx
</code></pre>
<p>Dans cet exemple, le répertoire <code>/data</code> dans le conteneur sera associé au volume <code>my_volume</code>.</p>
<p>Pour en savoir plus : <a href="https://docs.docker.com/storage/volumes/">documentation sur les volumes</a>.</p>
<hr />
<h3 id="bind-mounts--mappage-direct-entre-hôte-et-conteneur"><a class="header" href="#bind-mounts--mappage-direct-entre-hôte-et-conteneur"><strong>Bind Mounts : Mappage direct entre hôte et conteneur</strong></a></h3>
<p>Les bind mounts permettent de monter un répertoire ou un fichier spécifique de l’hôte directement dans le conteneur. Contrairement aux volumes, ils ne sont pas gérés par Docker et utilisent des chemins absolus sur l’hôte.</p>
<p><strong>Caractéristiques des bind mounts :</strong></p>
<ul>
<li>Contrôlés directement par l’utilisateur via des chemins spécifiques.</li>
<li>Utilisés pour des tâches de développement local nécessitant des mises à jour en temps réel.</li>
<li>Plus risqués en termes de sécurité et de portabilité.</li>
</ul>
<p><strong>Créer un bind mount :</strong></p>
<pre><code class="language-bash">docker run -v /path/host:/data nginx
</code></pre>
<p>Dans cet exemple, le répertoire <code>/path/host</code> sur l’hôte est monté dans le conteneur au chemin <code>/data</code>.</p>
<p>Pour plus de détails : <a href="https://docs.docker.com/storage/bind-mounts/">documentation sur les bind mounts</a>.</p>
<hr />
<h2 id="i4b-différences-entre-volumes-et-bind-mounts"><a class="header" href="#i4b-différences-entre-volumes-et-bind-mounts"><strong>I.4.b Différences entre volumes et bind mounts</strong></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Aspect</strong></th><th><strong>Volumes</strong></th><th><strong>Bind Mounts</strong></th></tr></thead><tbody>
<tr><td><strong>Gestion</strong></td><td>Géré par Docker.</td><td>Géré par l’utilisateur.</td></tr>
<tr><td><strong>Sécurité</strong></td><td>Plus sécurisé : chemins abstraits.</td><td>Moins sécurisé : accès direct à l’hôte.</td></tr>
<tr><td><strong>Portabilité</strong></td><td>Portables entre environnements Docker.</td><td>Dépend des chemins absolus sur l’hôte.</td></tr>
<tr><td><strong>Performances</strong></td><td>Optimisées pour Docker.</td><td>Dépendent de l’hôte.</td></tr>
<tr><td><strong>Cas d’usage</strong></td><td>Bases de données, stockage persistant.</td><td>Développement local, partage de fichiers.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="i4c-cas-dusage"><a class="header" href="#i4c-cas-dusage"><strong>I.4.c Cas d’usage</strong></a></h2>
<h3 id="stockage-des-données-de-bases-de-données"><a class="header" href="#stockage-des-données-de-bases-de-données"><strong>Stockage des données de bases de données</strong></a></h3>
<p>Lors de l'exécution de bases de données comme MySQL ou PostgreSQL dans des conteneurs, il est crucial de garantir la persistance des données. Les volumes sont idéaux dans ce cas :</p>
<pre><code class="language-bash">docker run -v db_volume:/var/lib/mysql mysql
</code></pre>
<p>Dans cet exemple, toutes les données de la base MySQL seront stockées dans le volume <code>db_volume</code>, qui persiste même si le conteneur est supprimé.</p>
<hr />
<h3 id="développement-local-avec-mises-à-jour-en-direct"><a class="header" href="#développement-local-avec-mises-à-jour-en-direct"><strong>Développement local avec mises à jour en direct</strong></a></h3>
<p>Pour des applications en cours de développement, les bind mounts permettent de synchroniser les fichiers de l’hôte avec ceux du conteneur. Par exemple, pour une application Node.js :</p>
<pre><code class="language-bash">docker run -v /path/to/code:/usr/src/app node
</code></pre>
<p>Toute modification dans <code>/path/to/code</code> sur l’hôte sera immédiatement visible dans le conteneur, facilitant le développement.</p>
<h2 id="exercices-2"><a class="header" href="#exercices-2"><strong>Exercices</strong></a></h2>
<details>
  <summary>Créer un volume</summary>
<h3 id="objectif-5"><a class="header" href="#objectif-5">Objectif</a></h3>
<p>Apprendre à créer un volume Docker, l'attacher à un conteneur, écrire des données dans le volume et vérifier leur persistance.</p>
<hr />
<h3 id="Étapes-5"><a class="header" href="#Étapes-5">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un volume</strong></p>
<ul>
<li>Créez un volume Docker nommé <code>my-volume</code> :
<pre><code class="language-bash">docker volume create my-volume
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer un conteneur avec le volume</strong></p>
<ul>
<li>Lancez un conteneur <code>nginx</code> en attachant le volume :
<pre><code class="language-bash">docker run -d --name nginx-container -v my-volume:/usr/share/nginx/html nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Écrire des données dans le volume</strong></p>
<ul>
<li>Copiez un fichier dans le volume :
<pre><code class="language-bash">docker exec nginx-container sh -c "echo 'Hello, Docker Volume!' &gt; /usr/share/nginx/html/index.html"
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Vérifier la persistance</strong></p>
<ul>
<li>Arrêtez et supprimez le conteneur :
<pre><code class="language-bash">docker stop nginx-container
docker rm nginx-container
</code></pre>
</li>
<li>Relancez un nouveau conteneur en attachant le même volume :
<pre><code class="language-bash">docker run -d --name new-nginx-container -v my-volume:/usr/share/nginx/html nginx
</code></pre>
</li>
<li>Vérifiez que les données sont toujours présentes :
<pre><code class="language-bash">docker exec new-nginx-container cat /usr/share/nginx/html/index.html
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-5"><a class="header" href="#résultat-attendu-5">Résultat attendu</a></h3>
<p>Les données ajoutées au volume sont persistantes, même après la suppression et le redémarrage du conteneur.</p>
</details>
<details>
  <summary>Utiliser des Bind Mounts</summary>
<h3 id="objectif-6"><a class="header" href="#objectif-6">Objectif</a></h3>
<p>Attacher un répertoire local à un conteneur en utilisant un bind mount et tester les mises à jour en temps réel.</p>
<hr />
<h3 id="Étapes-6"><a class="header" href="#Étapes-6">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un répertoire local</strong></p>
<ul>
<li>Créez un répertoire local et ajoutez un fichier :
<pre><code class="language-bash">mkdir ~/bind-mount-test
echo 'Hello, Bind Mount!' &gt; ~/bind-mount-test/index.html
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer un conteneur avec un bind mount</strong></p>
<ul>
<li>Attachez le répertoire local au conteneur <code>nginx</code> :
<pre><code class="language-bash">docker run -d --name nginx-bind -v ~/bind-mount-test:/usr/share/nginx/html -p 8080:80 nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Tester la mise à jour en temps réel</strong></p>
<ul>
<li>Mettez à jour le fichier local :
<pre><code class="language-bash">echo 'Updated Bind Mount!' &gt; ~/bind-mount-test/index.html
</code></pre>
</li>
<li>Accédez au conteneur pour vérifier la mise à jour :
<pre><code class="language-bash">curl http://localhost:8080
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-6"><a class="header" href="#résultat-attendu-6">Résultat attendu</a></h3>
<p>Les modifications des fichiers locaux sont immédiatement visibles dans le conteneur.</p>
</details>
<details>
  <summary>Inspecter les volumes</summary>
<h3 id="objectif-7"><a class="header" href="#objectif-7">Objectif</a></h3>
<p>Lister les volumes Docker et examiner leurs métadonnées.</p>
<hr />
<h3 id="Étapes-7"><a class="header" href="#Étapes-7">Étapes</a></h3>
<ol>
<li>
<p><strong>Lister les volumes</strong></p>
<ul>
<li>Affichez tous les volumes disponibles :
<pre><code class="language-bash">docker volume ls
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Inspecter un volume</strong></p>
<ul>
<li>Inspectez les détails du volume <code>my-volume</code> :
<pre><code class="language-bash">docker volume inspect my-volume
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Vérifier l'emplacement physique</strong></p>
<ul>
<li>Notez le chemin sur le système hôte où les données du volume sont stockées.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-7"><a class="header" href="#résultat-attendu-7">Résultat attendu</a></h3>
<p>Vous avez visualisé les métadonnées du volume, y compris son emplacement physique sur le système hôte.</p>
</details>
<details>
  <summary>Simuler un stockage persistant</summary>
<h3 id="objectif-8"><a class="header" href="#objectif-8">Objectif</a></h3>
<p>Configurer un conteneur MySQL avec un volume, ajouter des données, redémarrer le conteneur et vérifier la persistance des données.</p>
<hr />
<h3 id="Étapes-8"><a class="header" href="#Étapes-8">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un volume pour MySQL</strong></p>
<ul>
<li>Créez un volume nommé <code>mysql-data</code> :
<pre><code class="language-bash">docker volume create mysql-data
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer un conteneur MySQL</strong></p>
<ul>
<li>Lancez un conteneur MySQL avec le volume attaché :
<pre><code class="language-bash">docker run -d --name mysql-container -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Ajouter des données à la base</strong></p>
<ul>
<li>Connectez-vous à MySQL et créez une base de données :
<pre><code class="language-bash">docker exec -it mysql-container mysql -uroot -proot -e "CREATE DATABASE test_db;"
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Redémarrer le conteneur</strong></p>
<ul>
<li>Arrêtez et supprimez le conteneur :
<pre><code class="language-bash">docker stop mysql-container
docker rm mysql-container
</code></pre>
</li>
<li>Relancez un nouveau conteneur MySQL avec le même volume :
<pre><code class="language-bash">docker run -d --name mysql-container -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Vérifier la persistance des données</strong></p>
<ul>
<li>Connectez-vous à MySQL et vérifiez que la base de données <code>test_db</code> existe toujours :
<pre><code class="language-bash">docker exec -it mysql-container mysql -uroot -proot -e "SHOW DATABASES;"
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-8"><a class="header" href="#résultat-attendu-8">Résultat attendu</a></h3>
<p>Les données dans le volume MySQL sont conservées même après la suppression et le redémarrage du conteneur.</p>
</details>
<details>
  <summary>Résoudre les problèmes de montage</summary>
<h3 id="objectif-9"><a class="header" href="#objectif-9">Objectif</a></h3>
<p>Provoquer une erreur de montage en configurant mal un bind mount, identifier le problème et le résoudre.</p>
<hr />
<h3 id="Étapes-9"><a class="header" href="#Étapes-9">Étapes</a></h3>
<ol>
<li>
<p><strong>Provoquer une erreur</strong></p>
<ul>
<li>Lancez un conteneur avec un chemin local inexistant :
<pre><code class="language-bash">docker run -d --name nginx-error -v ./nonexistent:/usr/share/nginx/html nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Observer l'erreur</strong></p>
<ul>
<li>Vérifiez l'état du conteneur :
<pre><code class="language-bash">docker ps -a
</code></pre>
</li>
<li>Observez le message d'erreur avec :
<pre><code class="language-bash">docker logs nginx-error
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Corriger l'erreur</strong></p>
<ul>
<li>Créez le chemin local manquant :
<pre><code class="language-bash">mkdir -p ./nonexistent
</code></pre>
</li>
<li>Relancez le conteneur correctement :
<pre><code class="language-bash">docker run -d --name nginx-fixed -v ./nonexistent:/usr/share/nginx/html nginx
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-9"><a class="header" href="#résultat-attendu-9">Résultat attendu</a></h3>
<p>Vous avez provoqué une erreur de montage, identifié le problème, et corrigé la configuration pour relancer le conteneur avec succès.</p>
</details>
<h2 id="quiz"><a class="header" href="#quiz"><strong>Quiz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;volumes&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Les volumes Docker sont utilisés pour stocker des données qui doivent persister même après la suppression ou le redémarrage d'un conteneur.\n&quot;,&quot;id&quot;:&quot;e2dcaccf-3243-46fc-a87e-e6232f79fdf4&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Fournir un mécanisme de stockage persistant pour les conteneurs.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Exécuter plusieurs conteneurs en parallèle.&quot;,&quot;Créer des images à partir de données persistantes.&quot;,&quot;Améliorer les performances réseau.&quot;],&quot;prompt&quot;:&quot;Quel est le but principal des volumes Docker ?&quot;}},{&quot;context&quot;:&quot;Cette commande crée un volume que vous pouvez utiliser avec un conteneur.&quot;,&quot;id&quot;:&quot;cfb88232-9149-49ec-83bc-c20a21a0f355&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume create&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande Docker est utilisée pour créer un nouveau volume ?&quot;}},{&quot;context&quot;:&quot;La commande `docker volume create` crée un volume que les conteneurs peuvent utiliser pour stocker des données persistantes.\n&quot;,&quot;id&quot;:&quot;9264f6cd-5f01-4371-830a-903b70d37cce&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume create&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker volume add&quot;,&quot;docker volume init&quot;,&quot;docker volume new&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour créer un nouveau volume ?&quot;}},{&quot;context&quot;:&quot;Le flag `-v` ou `--volume` permet de monter un volume dans un conteneur.&quot;,&quot;id&quot;:&quot;c077556c-3c62-41d0-bcac-5473100322f5&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;-v&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel flag est utilisé dans la commande `docker run` pour spécifier un volume ?&quot;}},{&quot;context&quot;:&quot;Les volumes Docker ne sont pas supprimés automatiquement, même si le conteneur qui les utilise est supprimé avec `--rm`.\n&quot;,&quot;id&quot;:&quot;253794bb-c24b-4658-9d3e-4d0f1ba2f997&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Le volume reste intact et disponible pour d'autres conteneurs.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Le volume est supprimé.&quot;,&quot;Le volume est sauvegardé sous un autre nom.&quot;,&quot;Le volume est converti en bind mount.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il lorsqu’un conteneur utilisant un volume est supprimé avec le flag `--rm` ?&quot;}},{&quot;context&quot;:&quot;Cette commande affiche tous les volumes, qu'ils soient utilisés ou non.&quot;,&quot;id&quot;:&quot;57b3ea20-8dff-4e58-ba0c-6cc9a290e2b7&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume ls&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande Docker liste tous les volumes sur l'hôte ?&quot;}},{&quot;context&quot;:&quot;Le flag `-v` ou son équivalent plus explicite `--volume` est utilisé pour attacher des volumes à un conteneur.\n&quot;,&quot;id&quot;:&quot;c167ef50-b3eb-4c02-b4c9-f3eea8ad32a8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;-v&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;--volume&quot;,&quot;--mount&quot;,&quot;-m&quot;],&quot;prompt&quot;:&quot;Quel flag est utilisé pour spécifier un volume dans la commande `docker run` ?&quot;}},{&quot;context&quot;:&quot;Cette commande fournit des informations détaillées sur un volume spécifique.&quot;,&quot;id&quot;:&quot;9e795487-f57f-406d-b075-267e45b3dbd6&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume inspect&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande Docker inspecte les métadonnées d’un volume spécifique ?&quot;}},{&quot;context&quot;:&quot;Les volumes anonymes sont créés sans nom explicite, ce qui les rend difficiles à gérer et à réutiliser.\n&quot;,&quot;id&quot;:&quot;f69bee2a-644c-48c6-a8cd-ba9119b54725&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les volumes anonymes n'ont pas de nom et ne peuvent pas être facilement réutilisés.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les volumes anonymes sont limités en taille.&quot;,&quot;Les volumes nommés ne peuvent pas être partagés entre conteneurs.&quot;,&quot;Les volumes anonymes sont automatiquement supprimés après l'arrêt d'un conteneur.&quot;],&quot;prompt&quot;:&quot;Quelle est la différence entre les volumes anonymes et nommés ?&quot;}},{&quot;context&quot;:&quot;Cette commande supprime tous les volumes inutilisés pour libérer de l’espace disque.&quot;,&quot;id&quot;:&quot;efec88c6-7710-4dba-ba10-3607275952e7&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume prune&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande permet de supprimer les volumes inutilisés dans Docker ?&quot;}},{&quot;context&quot;:&quot;Les bind mounts mappent directement des répertoires du système hôte, ce qui peut poser des problèmes de sécurité en cas de mauvaise configuration.\n&quot;,&quot;id&quot;:&quot;b4a0e1d7-a743-46dc-aee8-bc0bcec41729&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Ils peuvent compromettre la sécurité en exposant des fichiers du système hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Ils ne peuvent pas être utilisés avec des conteneurs en réseau.&quot;,&quot;Ils nécessitent un démon Docker dédié.&quot;,&quot;Ils peuvent compromettre la sécurité en exposant des fichiers du système hôte.&quot;],&quot;prompt&quot;:&quot;Quel est un inconvénient d'utiliser les bind mounts en production ?&quot;}},{&quot;context&quot;:&quot;Les bind mounts permettent d’utiliser un répertoire du système hôte comme volume.&quot;,&quot;id&quot;:&quot;bc357b9f-2767-4fea-98e0-2c24d5eac973&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;bind&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel type de montage mappe directement un répertoire hôte à un conteneur ?&quot;}},{&quot;context&quot;:&quot;Docker crée automatiquement le répertoire manquant sur l’hôte pour éviter les erreurs lors de l’exécution du conteneur.\n&quot;,&quot;id&quot;:&quot;3a52da89-18bd-496b-924e-7e4ce6c91b76&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Un nouveau répertoire est automatiquement créé sur l’hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Le conteneur échoue à démarrer.&quot;,&quot;Le répertoire est ignoré par le conteneur.&quot;,&quot;Un message d’erreur est affiché et le conteneur continue de fonctionner.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il si vous essayez de binder un répertoire inexistant de l’hôte à un conteneur ?&quot;}},{&quot;context&quot;:&quot;Les volumes sont conçus pour stocker des données durables et partagées entre les conteneurs.&quot;,&quot;id&quot;:&quot;67b497c8-3261-4683-a442-c972b454f7b6&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;volumes&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel est le principal mécanisme de gestion du stockage dans Docker pour les données persistantes ?&quot;}},{&quot;context&quot;:&quot;Pour restreindre l’accès, ne partagez pas le volume avec d’autres conteneurs et utilisez des volumes nommés associés explicitement.\n&quot;,&quot;id&quot;:&quot;639271ba-bab1-461e-be33-7c913e954cc8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;En attachant explicitement le volume uniquement au conteneur concerné.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;En utilisant des volumes anonymes.&quot;,&quot;En configurant des permissions de conteneur.&quot;,&quot;En utilisant des bind mounts.&quot;],&quot;prompt&quot;:&quot;Comment garantir qu’un volume soit accessible uniquement par un conteneur spécifique ?&quot;}},{&quot;context&quot;:&quot;`docker volume prune` supprime tous les volumes non utilisés pour libérer de l'espace sur le système hôte.\n&quot;,&quot;id&quot;:&quot;227315f8-7c1c-4be1-a77e-6d1546ee1cc1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume prune&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker volume rm&quot;,&quot;docker prune volumes&quot;,&quot;docker volume gc&quot;],&quot;prompt&quot;:&quot;Quelle commande permet de supprimer les volumes non utilisés sur un hôte Docker ?&quot;}},{&quot;context&quot;:&quot;Les volumes sont mieux adaptés à la production grâce à leur sécurité et leur gestion simplifiée.&quot;,&quot;id&quot;:&quot;6a35ce5e-8eb5-4b19-a134-7c73eb53cdfa&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;volumes&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle méthode est préférée pour stocker les données d'application en production : volumes ou bind mounts ?&quot;}},{&quot;context&quot;:&quot;`docker system prune` supprime les volumes anonymes non utilisés mais laisse intacts les volumes nommés.\n&quot;,&quot;id&quot;:&quot;9cdfcc46-6ea3-4ed9-b328-ac283ad583c9&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les volumes anonymes non utilisés sont supprimés uniquement.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les volumes sont sauvegardés.&quot;,&quot;Les volumes utilisés par des conteneurs sont supprimés.&quot;,&quot;Les volumes anonymes non utilisés sont supprimés uniquement.&quot;],&quot;prompt&quot;:&quot;Quel est l'effet de la commande `docker system prune` sur les volumes ?&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h2 id="exercices-résumés-de-la-partie-1"><a class="header" href="#exercices-résumés-de-la-partie-1"><strong>Exercices résumés de la partie 1</strong></a></h2>
<details>
  <summary>End-to-End Container Workflow</summary>
<h3 id="objectif-10"><a class="header" href="#objectif-10">Objectif</a></h3>
<p>Mettez en œuvre un flux de travail complet : téléchargez une image, créez un conteneur, persistez des données à l’aide d’un volume et analysez les métadonnées du conteneur.</p>
<hr />
<h3 id="Étapes-10"><a class="header" href="#Étapes-10">Étapes</a></h3>
<ol>
<li>
<p><strong>Télécharger une image</strong></p>
<ul>
<li>Téléchargez l'image <code>httpd</code> (Apache Web Server) depuis Docker Hub :
<pre><code class="language-bash">docker pull httpd
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Créer et lancer un conteneur</strong></p>
<ul>
<li>Lancez un conteneur avec un volume nommé <code>web-data</code> pour stocker les fichiers web et exposez le port 8080 :
<pre><code class="language-bash">docker run -d --name apache-container -v web-data:/usr/local/apache2/htdocs -p 8080:80 httpd
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Ajouter des données au volume</strong></p>
<ul>
<li>Ajoutez un fichier HTML dans le volume via le conteneur :
<pre><code class="language-bash">docker exec apache-container sh -c "echo '&lt;h1&gt;Hello, End-to-End Workflow!&lt;/h1&gt;' &gt; /usr/local/apache2/htdocs/index.html"
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Analyser les métadonnées</strong></p>
<ul>
<li>Inspectez les métadonnées du conteneur :
<pre><code class="language-bash">docker inspect apache-container
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Vérifier la persistance</strong></p>
<ul>
<li>Arrêtez et supprimez le conteneur, puis relancez un nouveau conteneur avec le même volume :
<pre><code class="language-bash">docker stop apache-container
docker rm apache-container
docker run -d --name apache-container -v web-data:/usr/local/apache2/htdocs -p 8080:80 httpd
</code></pre>
</li>
<li>Vérifiez que les données sont toujours accessibles à <code>http://localhost:8080</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-10"><a class="header" href="#résultat-attendu-10">Résultat attendu</a></h3>
<p>Vous avez un conteneur opérationnel avec des données persistantes accessibles via un navigateur.</p>
</details>
<details>
  <summary>Custom Application Deployment</summary>
<h3 id="objectif-11"><a class="header" href="#objectif-11">Objectif</a></h3>
<p>Créer une image Docker personnalisée pour une application de base, avec un volume pour les journaux.</p>
<hr />
<h3 id="Étapes-11"><a class="header" href="#Étapes-11">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer une application simple</strong></p>
<ul>
<li>Créez un fichier <code>app.py</code> contenant un script Python simple :
<pre><code class="language-python">from flask import Flask
app = Flask(__name__)

@app.route('/')
def home():
    return "Hello, Custom Application Deployment!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Créer un Dockerfile</strong></p>
<ul>
<li>Créez un fichier <code>Dockerfile</code> :
<pre><code class="language-Dockerfile">FROM python:3.9
WORKDIR /app
COPY app.py .
RUN pip install flask
CMD ["python", "app.py"]
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Construire l'image</strong></p>
<ul>
<li>Construisez l'image avec un tag approprié :
<pre><code class="language-bash">docker build -t custom-app .
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer le conteneur avec un volume</strong></p>
<ul>
<li>Lancez un conteneur en mappant un volume pour les journaux d'application :
<pre><code class="language-bash">docker run -d --name custom-app-container -v app-logs:/app/logs -p 5000:5000 custom-app
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Tester l'application</strong></p>
<ul>
<li>Accédez à l’application à <code>http://localhost:5000</code>.</li>
</ul>
</li>
<li>
<p><strong>Vérifier les journaux</strong></p>
<ul>
<li>Ajoutez des logs dans le script (modifiez <code>app.py</code> pour écrire dans un fichier) et vérifiez leur présence dans le volume.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-11"><a class="header" href="#résultat-attendu-11">Résultat attendu</a></h3>
<p>Une application Python conteneurisée fonctionnant avec des journaux persistants.</p>
</details>
<details>
  <summary>Multi-Container Setup</summary>
<h3 id="objectif-12"><a class="header" href="#objectif-12">Objectif</a></h3>
<p>Déployer une pile web simple avec plusieurs conteneurs Docker et partager des données à l’aide de volumes.</p>
<hr />
<h3 id="Étapes-12"><a class="header" href="#Étapes-12">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un réseau Docker</strong></p>
<ul>
<li>Créez un réseau Docker pour connecter les conteneurs :
<pre><code class="language-bash">docker network create web-stack
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer un conteneur MySQL</strong></p>
<ul>
<li>Créez un volume pour stocker les données MySQL :
<pre><code class="language-bash">docker volume create mysql-data
</code></pre>
</li>
<li>Lancez un conteneur MySQL sur le réseau :
<pre><code class="language-bash">docker run -d --name mysql-container --network web-stack -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=webapp mysql:5.7
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Lancer un conteneur Nginx</strong></p>
<ul>
<li>Créez un fichier HTML statique dans un volume :
<pre><code class="language-bash">mkdir ~/web-content
echo "&lt;h1&gt;Welcome to the Web Stack!&lt;/h1&gt;" &gt; ~/web-content/index.html
</code></pre>
</li>
<li>Lancez le conteneur Nginx avec le contenu partagé :
<pre><code class="language-bash">docker run -d --name nginx-container --network web-stack -v ~/web-content:/usr/share/nginx/html:ro -p 8080:80 nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Tester la pile</strong></p>
<ul>
<li>Accédez à <code>http://localhost:8080</code> pour vérifier que la pile fonctionne.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-12"><a class="header" href="#résultat-attendu-12">Résultat attendu</a></h3>
<p>Une pile web avec une base de données persistante et un serveur web Nginx.</p>
</details>
<details>
  <summary>CLI Troubleshooting</summary>
<h3 id="objectif-13"><a class="header" href="#objectif-13">Objectif</a></h3>
<p>Simuler des problèmes courants liés aux volumes et aux ports, puis les résoudre.</p>
<hr />
<h3 id="Étapes-13"><a class="header" href="#Étapes-13">Étapes</a></h3>
<ol>
<li>
<p><strong>Simuler une erreur de volume</strong></p>
<ul>
<li>Lancez un conteneur avec un chemin local inexistant :
<pre><code class="language-bash">docker run -d --name broken-volume -v /nonexistent:/data busybox
</code></pre>
</li>
<li>Vérifiez l'erreur :
<pre><code class="language-bash">docker logs broken-volume
</code></pre>
</li>
<li>Corrigez l'erreur en créant le chemin et en relançant le conteneur :
<pre><code class="language-bash">mkdir /nonexistent
docker run -d --name fixed-volume -v /nonexistent:/data busybox
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Simuler une erreur de port</strong></p>
<ul>
<li>Lancez un conteneur Nginx avec un port déjà utilisé (ex. : <code>80</code>) :
<pre><code class="language-bash">docker run -d --name broken-port -p 80:80 nginx
</code></pre>
</li>
<li>Identifiez l'erreur en utilisant :
<pre><code class="language-bash">docker logs broken-port
</code></pre>
</li>
<li>Relancez avec un port différent :
<pre><code class="language-bash">docker run -d --name fixed-port -p 8080:80 nginx
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Résoudre un conflit réseau</strong></p>
<ul>
<li>Essayez de connecter deux conteneurs non liés et corrigez en créant un réseau commun :
<pre><code class="language-bash">docker network create troubleshooting-net
docker network connect troubleshooting-net container1
docker network connect troubleshooting-net container2
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-13"><a class="header" href="#résultat-attendu-13">Résultat attendu</a></h3>
<p>Vous avez simulé et corrigé des erreurs liées aux volumes, aux ports et au réseau.</p>
</details>
<h2 id="quiz-1"><a class="header" href="#quiz-1"><strong>Quiz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;wrap_up&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;La commande `docker run -it` combine les flags `-i` (mode interactif) et `-t` (pseudo-terminal) pour permettre une interaction directe avec le conteneur.\n&quot;,&quot;id&quot;:&quot;470b59b5-52b7-4482-81c4-8b7d4a769fc0&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker run -it&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker start&quot;,&quot;docker exec&quot;,&quot;docker attach&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour exécuter un conteneur de manière interactive ?&quot;}},{&quot;context&quot;:&quot;La commande `docker ps` affiche uniquement les conteneurs en cours d’exécution. Avec l’option `-a`, tous les conteneurs sont affichés, peu importe leur état.\n&quot;,&quot;id&quot;:&quot;2264b4c5-1bf0-432d-a167-db2a01a00b71&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker ps -a&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande Docker liste tous les conteneurs, y compris ceux qui sont arrêtés ?&quot;}},{&quot;context&quot;:&quot;Le démon Docker (dockerd) est responsable de la gestion des conteneurs, des images, des réseaux et des volumes.\n&quot;,&quot;id&quot;:&quot;c53e7334-03f0-420f-b83a-f180ee664918&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Il gère les conteneurs et les services Docker.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Il construit des images Docker.&quot;,&quot;Il fournit une interface pour les commandes utilisateur.&quot;,&quot;Il garantit l'isolation des conteneurs sur le système hôte.&quot;],&quot;prompt&quot;:&quot;Quel est le rôle du daemon Docker ?&quot;}},{&quot;context&quot;:&quot;Le flag `-v` (ou `--volume`) est utilisé pour spécifier un volume à monter dans un conteneur.\n&quot;,&quot;id&quot;:&quot;e2d32aa2-c7f4-4fbe-8676-1acc1c96fbb4&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;-v&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel flag est utilisé pour monter un volume dans un conteneur Docker ?&quot;}},{&quot;context&quot;:&quot;Les volumes Docker sont conçus pour être indépendants des conteneurs. Ils ne sont pas supprimés automatiquement, sauf si vous le spécifiez.\n&quot;,&quot;id&quot;:&quot;b2bbc1db-e9ca-4060-97c3-9f57d2cc2077&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Le volume persiste sur le système hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Le volume est automatiquement supprimé.&quot;,&quot;Le volume est déplacé dans un répertoire de sauvegarde.&quot;,&quot;Le volume est renommé et archivé.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il avec un volume lorsqu'un conteneur associé est supprimé sans utiliser le flag `--rm` ?&quot;}},{&quot;context&quot;:&quot;La commande `docker pull` télécharge une image Docker depuis un registre, tel que Docker Hub.\n&quot;,&quot;id&quot;:&quot;52b0cd18-af50-49b1-9273-04f2876f2aaa&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker pull&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande est utilisée pour récupérer une image depuis Docker Hub ?&quot;}},{&quot;context&quot;:&quot;Contrairement aux machines virtuelles, les conteneurs utilisent directement le noyau de l'OS hôte, ce qui les rend plus légers et plus rapides.\n&quot;,&quot;id&quot;:&quot;2ebdb9af-8009-4e76-abad-44994b92788d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les conteneurs partagent le noyau du système d’exploitation hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs nécessitent leur propre noyau d’OS.&quot;,&quot;Les conteneurs sont plus lourds que les machines virtuelles.&quot;,&quot;Les conteneurs nécessitent des hyperviseurs pour fonctionner.&quot;],&quot;prompt&quot;:&quot;Quelle caractéristique distingue les conteneurs des machines virtuelles ?&quot;}},{&quot;context&quot;:&quot;La commande `docker volume inspect` fournit des détails sur un volume, comme son emplacement ou les conteneurs qui l’utilisent.\n&quot;,&quot;id&quot;:&quot;bb800d38-cc66-4155-80eb-33fe238ed8b6&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker volume inspect&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande Docker est utilisée pour inspecter les métadonnées d’un volume ?&quot;}},{&quot;context&quot;:&quot;Les bind mounts permettent d’accéder directement aux répertoires de l’hôte depuis un conteneur, ce qui est utile pour le développement.\n&quot;,&quot;id&quot;:&quot;59a177e4-f984-41cb-a680-2b4190276496&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Ils mappent directement un répertoire de l’hôte au système de fichiers du conteneur.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Ils permettent l'accès au stockage géré par Docker sur l'hôte.&quot;,&quot;Ils persistent automatiquement après plusieurs redémarrages du conteneur.&quot;,&quot;Ils ne peuvent pas être utilisés pour des mises à jour de fichiers en direct.&quot;],&quot;prompt&quot;:&quot;Comment décririez-vous au mieux les bind mounts ?&quot;}},{&quot;context&quot;:&quot;Les données sur un stockage éphémère (non persistantes) sont perdues lorsqu’un conteneur est arrêté ou supprimé.\n&quot;,&quot;id&quot;:&quot;3b166cb7-64a9-437d-8364-d2bd0e7e324d&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;perdues&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Que se passe-t-il avec les données stockées sur un stockage éphémère lorsque le conteneur est arrêté ?&quot;}},{&quot;context&quot;:&quot;La commande `docker build` crée une nouvelle image à partir d’un fichier Dockerfile et d’un contexte de construction.\n&quot;,&quot;id&quot;:&quot;49c69174-58e7-4434-b582-a2996d7eccfe&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker build&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker run&quot;,&quot;docker pull&quot;,&quot;docker image create&quot;],&quot;prompt&quot;:&quot;Laquelle de ces commandes Docker crée une nouvelle image personnalisée ?&quot;}},{&quot;context&quot;:&quot;La commande `docker logs` est utilisée pour afficher les journaux d’un conteneur, facilitant le débogage des applications.\n&quot;,&quot;id&quot;:&quot;51c9f3ad-6987-4655-ab9e-4619241be2d0&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;débogage&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel est le but principal de la commande `docker logs` ?&quot;}},{&quot;context&quot;:&quot;Les volumes sont conçus pour être utilisés en production grâce à leur gestion simplifiée, leur sécurité et leurs performances optimisées.\n&quot;,&quot;id&quot;:&quot;035e9d02-e4ea-4299-b628-876581041f11&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Lors du déploiement d’une base de données conteneurisée en production.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Lorsque vous avez besoin d’un accès direct au système de fichiers hôte pour le développement.&quot;,&quot;Lors du déploiement d’une base de données conteneurisée en production.&quot;,&quot;Lors de la gestion d’un environnement de développement local.&quot;,&quot;Lors du transfert de données entre deux conteneurs.&quot;],&quot;prompt&quot;:&quot;Dans quelle situation préféreriez-vous un volume à un bind mount ?&quot;}},{&quot;context&quot;:&quot;Docker prend en charge deux types de stockage persistant : les volumes, gérés par Docker, et les bind mounts, qui utilisent les répertoires de l’hôte.\n&quot;,&quot;id&quot;:&quot;c2a0ce39-c05a-45f9-bf1d-b45a51aea727&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;volumes, bind mounts&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Nommez les deux principaux types de stockage persistant dans Docker.&quot;}},{&quot;context&quot;:&quot;`docker system prune` est une commande puissante qui nettoie le système en supprimant tout ce qui est inutilisé, y compris les volumes anonymes.\n&quot;,&quot;id&quot;:&quot;ff642f30-d1b1-4631-9daf-217eec1e6905&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Elle supprime tous les conteneurs, images et volumes inutilisés.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Elle supprime tous les conteneurs en cours d’exécution.&quot;,&quot;Elle arrête tous les conteneurs en cours d’exécution.&quot;,&quot;Elle supprime Docker du système.&quot;],&quot;prompt&quot;:&quot;Que fait la commande `docker system prune` ?&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h3 id="concepts-avancés-de-docker"><a class="header" href="#concepts-avancés-de-docker"><strong>Concepts Avancés de Docker</strong></a></h3>
<p>Docker ne se limite pas à la création et à l’exécution de conteneurs. Une fois les bases maîtrisées, il est essentiel de comprendre les concepts avancés pour concevoir des applications complexes et sécurisées. <strong>Partie 2 : Concepts avancés de Docker</strong> approfondit ces notions clés et vous prépare à des déploiements en production et à la gestion d’applications conteneurisées à grande échelle.</p>
<hr />
<h4 id="pourquoi-ces-concepts-sont-importants-"><a class="header" href="#pourquoi-ces-concepts-sont-importants-"><strong>Pourquoi ces concepts sont importants ?</strong></a></h4>
<ol>
<li>
<p><strong>Mise en réseau (Networking in Docker)</strong><br />
Les applications modernes, notamment celles basées sur des microservices, nécessitent une communication fluide entre conteneurs et avec l’extérieur. Apprendre à configurer et gérer des réseaux Docker est essentiel pour permettre cette interaction.</p>
</li>
<li>
<p><strong>Docker Compose pour les applications multi-conteneurs</strong><br />
À mesure que les projets grandissent, gérer plusieurs conteneurs manuellement devient complexe. Docker Compose simplifie cette orchestration en permettant de définir et de gérer plusieurs services dans un seul fichier de configuration.</p>
</li>
<li>
<p><strong>Meilleures pratiques de sécurité</strong><br />
Les conteneurs isolent les applications, mais cela ne garantit pas une sécurité parfaite. Suivre les meilleures pratiques pour sécuriser les images et les conteneurs est crucial pour éviter des vulnérabilités en production.</p>
</li>
</ol>
<hr />
<h4 id="objectifs-de-cette-partie-"><a class="header" href="#objectifs-de-cette-partie-"><strong>Objectifs de cette partie :</strong></a></h4>
<ul>
<li>Développer des compétences pour connecter des conteneurs entre eux et au monde extérieur via le réseau Docker.</li>
<li>Découvrir comment orchestrer facilement plusieurs conteneurs avec Docker Compose.</li>
<li>Apprendre à sécuriser les applications conteneurisées grâce à des techniques et outils avancés.</li>
</ul>
<hr />
<h4 id="comment-ces-notions-sintègrent-elles-"><a class="header" href="#comment-ces-notions-sintègrent-elles-"><strong>Comment ces notions s’intègrent-elles ?</strong></a></h4>
<p>Ces concepts sont des étapes naturelles pour évoluer vers des environnements de production et des architectures complexes basées sur Docker. Ils préparent également le terrain pour des outils d'orchestration à grande échelle comme Kubernetes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ii1-networking-avec-docker"><a class="header" href="#ii1-networking-avec-docker"><strong>II.1 Networking avec Docker</strong></a></h1>
<hr />
<p>Le réseau est un élément fondamental dans les environnements conteneurisés, permettant aux applications de communiquer entre elles et avec le monde extérieur. Docker offre des options réseau robustes, flexibles et faciles à configurer, adaptées aux besoins variés des applications. Cette section explore les différents modes réseau de Docker, les réseaux personnalisés, et les techniques pour gérer la communication et l’isolation des conteneurs.</p>
<hr />
<h2 id="ii1a-modes-réseau-par-défaut-dans-docker"><a class="header" href="#ii1a-modes-réseau-par-défaut-dans-docker"><strong>II.1.a Modes réseau par défaut dans Docker</strong></a></h2>
<p>Docker fournit trois modes réseau par défaut, chacun ayant des usages spécifiques :</p>
<ol>
<li>
<p><strong>Bridge</strong> <em>(Mode par défaut)</em></p>
<ul>
<li>Le conteneur est connecté à un réseau virtuel géré par Docker, nommé <code>bridge</code>.</li>
<li>Idéal pour les conteneurs indépendants nécessitant un accès limité au réseau extérieur.</li>
<li>Pour exposer des ports, utilisez des mappages explicites entre le conteneur et l’hôte :
<pre><code class="language-bash">docker run -d -p 8080:80 nginx
</code></pre>
Cela connecte le port 80 du conteneur au port 8080 de l’hôte.</li>
</ul>
<p>En savoir plus : <a href="https://docs.docker.com/network/bridge/">Documentation sur le réseau bridge</a>.</p>
</li>
<li>
<p><strong>Host</strong></p>
<ul>
<li>Le conteneur partage la pile réseau de l’hôte.</li>
<li>Il n’y a pas d’isolation réseau entre l’hôte et le conteneur.</li>
<li>Utile pour des performances réseau optimales ou pour des applications nécessitant un accès direct aux interfaces réseau.
<pre><code class="language-bash">docker run --network host nginx
</code></pre>
</li>
</ul>
<p>En savoir plus : <a href="https://docs.docker.com/network/host/">Documentation sur le réseau host</a>.</p>
</li>
<li>
<p><strong>None</strong></p>
<ul>
<li>Le conteneur n’a aucun accès réseau.</li>
<li>Parfait pour des conteneurs isolés exécutant des tâches ne nécessitant pas de communication réseau :
<pre><code class="language-bash">docker run --network none busybox
</code></pre>
</li>
</ul>
<p>En savoir plus : <a href="https://docs.docker.com/network/none/">Documentation sur le réseau none</a>.</p>
</li>
</ol>
<hr />
<h2 id="ii1b-réseaux-personnalisés-dans-docker"><a class="header" href="#ii1b-réseaux-personnalisés-dans-docker"><strong>II.1.b Réseaux personnalisés dans Docker</strong></a></h2>
<p>Les réseaux personnalisés permettent un contrôle accru sur la communication inter-conteneurs et la résolution DNS. Ces réseaux sont souvent basés sur le mode bridge.</p>
<p><strong>Créer un réseau personnalisé :</strong></p>
<pre><code class="language-bash">docker network create my_custom_network
</code></pre>
<p><strong>Connecter un conteneur à un réseau personnalisé :</strong></p>
<pre><code class="language-bash">docker run --network my_custom_network --name app1 nginx
</code></pre>
<p>Dans un réseau personnalisé :</p>
<ul>
<li>Les conteneurs peuvent communiquer en utilisant leurs noms comme hostnames grâce à la résolution DNS intégrée.</li>
<li>Cela évite d’avoir à gérer manuellement les adresses IP.</li>
</ul>
<p><strong>Lister les réseaux existants :</strong></p>
<pre><code class="language-bash">docker network ls
</code></pre>
<p>En savoir plus : <a href="https://docs.docker.com/network/">Documentation sur les réseaux personnalisés</a>.</p>
<hr />
<h2 id="ii1c-exposer-des-ports"><a class="header" href="#ii1c-exposer-des-ports"><strong>II.1.c Exposer des ports</strong></a></h2>
<p>Pour permettre un accès extérieur à un conteneur, Docker utilise des mappages de ports entre le conteneur et l’hôte.</p>
<p><strong>Exemple :</strong><br />
Pour exécuter un serveur web Nginx accessible via le port 8080 de l’hôte :</p>
<pre><code class="language-bash">docker run -d -p 8080:80 nginx
</code></pre>
<p>Cela connecte :</p>
<ul>
<li>Le <strong>port 80</strong> dans le conteneur au <strong>port 8080</strong> sur l’hôte.</li>
</ul>
<p>Pour voir les mappages de ports :</p>
<pre><code class="language-bash">docker ps
</code></pre>
<p>En savoir plus : <a href="https://docs.docker.com/config/containers/container-networking/#published-ports">Documentation sur les ports Docker</a>.</p>
<hr />
<h2 id="ii1d-communication-entre-conteneurs"><a class="header" href="#ii1d-communication-entre-conteneurs"><strong>II.1.d Communication entre conteneurs</strong></a></h2>
<p>Lorsque plusieurs conteneurs appartiennent au même réseau personnalisé, ils peuvent communiquer directement en utilisant leurs noms comme hostnames.</p>
<p><strong>Exemple :</strong></p>
<ol>
<li>
<p>Créez un réseau personnalisé :</p>
<pre><code class="language-bash">docker network create my_app_network
</code></pre>
</li>
<li>
<p>Démarrez deux conteneurs dans ce réseau :</p>
<pre><code class="language-bash">docker run --network my_app_network --name app1 nginx
docker run --network my_app_network --name app2 busybox ping app1
</code></pre>
</li>
</ol>
<p>Dans cet exemple, <code>app2</code> peut pinger <code>app1</code> grâce à la résolution DNS intégrée, sans nécessiter d’adresses IP explicites.</p>
<hr />
<h2 id="ii1e-isolation-et-contrôle-du-trafic-réseau"><a class="header" href="#ii1e-isolation-et-contrôle-du-trafic-réseau"><strong>II.1.e Isolation et contrôle du trafic réseau</strong></a></h2>
<p>Pour améliorer la sécurité ou tester la connectivité, Docker permet de limiter l’accès réseau des conteneurs.</p>
<ul>
<li>
<p><strong>Isolation réseau avec le mode none :</strong><br />
Empêche complètement un conteneur d’accéder au réseau :</p>
<pre><code class="language-bash">docker run --network none busybox
</code></pre>
</li>
<li>
<p><strong>Test de la connectivité entre conteneurs :</strong><br />
Utilisez des outils comme <code>ping</code> ou <code>curl</code> pour vérifier la communication :</p>
<pre><code class="language-bash">docker exec &lt;container_id&gt; ping &lt;hostname&gt;
</code></pre>
</li>
<li>
<p><strong>Supprimer un conteneur d’un réseau :</strong></p>
<pre><code class="language-bash">docker network disconnect my_app_network &lt;container_id&gt;
</code></pre>
</li>
</ul>
<p>En savoir plus : <a href="https://docs.docker.com/network/">Documentation sur la gestion réseau</a>.</p>
<h2 id="exercices-de-mise-en-réseau"><a class="header" href="#exercices-de-mise-en-réseau"><strong>Exercices de mise en réseau</strong></a></h2>
<hr />
<h3 id="1-exploration-des-réseaux-docker-par-défaut"><a class="header" href="#1-exploration-des-réseaux-docker-par-défaut"><strong>1. Exploration des réseaux Docker par défaut</strong></a></h3>
<details>
  <summary>Exercice 1 : Réseau bridge par défaut</summary>
<h3 id="objectif-14"><a class="header" href="#objectif-14">Objectif</a></h3>
<p>Lancer un conteneur dans le réseau bridge par défaut, inspecter ses paramètres réseau et tester sa connectivité avec l’hôte.</p>
<hr />
<h3 id="Étapes-14"><a class="header" href="#Étapes-14">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer un conteneur dans le réseau bridge par défaut</strong> :</p>
<pre><code class="language-bash">docker run -d --name bridge-container busybox sleep 3600
</code></pre>
</li>
<li>
<p><strong>Inspecter les paramètres réseau</strong> :</p>
<pre><code class="language-bash">docker inspect bridge-container
</code></pre>
</li>
<li>
<p><strong>Tester la connectivité avec l’hôte</strong> :</p>
<ul>
<li>Identifiez l’adresse IP du conteneur via la commande précédente.</li>
<li>Utilisez <code>ping</code> depuis le conteneur pour tester la connectivité vers l’hôte.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-14"><a class="header" href="#résultat-attendu-14">Résultat attendu</a></h3>
<p>Le conteneur est connecté au réseau bridge par défaut et peut communiquer avec l’hôte.</p>
</details>
<details>
  <summary>Exercice 2 : Mode réseau isolé (--network none)</summary>
<h3 id="objectif-15"><a class="header" href="#objectif-15">Objectif</a></h3>
<p>Lancer un conteneur avec l’option <code>--network none</code> et analyser son isolation réseau.</p>
<hr />
<h3 id="Étapes-15"><a class="header" href="#Étapes-15">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer un conteneur avec <code>--network none</code></strong> :</p>
<pre><code class="language-bash">docker run -d --name no-network-container --network none busybox sleep 3600
</code></pre>
</li>
<li>
<p><strong>Inspecter les paramètres réseau</strong> :</p>
<pre><code class="language-bash">docker inspect no-network-container
</code></pre>
</li>
<li>
<p><strong>Tester la connectivité</strong> :</p>
<ul>
<li>Essayez de pinger une adresse externe comme <code>google.com</code> (échec attendu).</li>
<li>Essayez de pinger un autre conteneur ou l’hôte (échec attendu).</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-15"><a class="header" href="#résultat-attendu-15">Résultat attendu</a></h3>
<p>Le conteneur est complètement isolé des réseaux internes et externes.</p>
</details>
<details>
  <summary>Exercice 3 : Mode réseau hôte (--network host)</summary>
<h3 id="objectif-16"><a class="header" href="#objectif-16">Objectif</a></h3>
<p>Lancer un conteneur avec l’option <code>--network host</code> et analyser son accès aux services de l’hôte.</p>
<hr />
<h3 id="Étapes-16"><a class="header" href="#Étapes-16">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer un conteneur avec <code>--network host</code></strong> :</p>
<pre><code class="language-bash">docker run -d --name host-network-container --network host busybox sleep 3600
</code></pre>
</li>
<li>
<p><strong>Inspecter les paramètres réseau</strong> :</p>
<pre><code class="language-bash">docker inspect host-network-container
</code></pre>
</li>
<li>
<p><strong>Tester la connectivité</strong> :</p>
<ul>
<li>Testez l’accès aux services de l’hôte (par exemple SSH ou un serveur web local).</li>
<li>Comparez ce comportement avec celui du réseau bridge par défaut.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-16"><a class="header" href="#résultat-attendu-16">Résultat attendu</a></h3>
<p>Le conteneur partage la pile réseau de l’hôte, lui permettant d’accéder directement à ses services.</p>
</details>
<hr />
<h3 id="2-réseaux-docker-personnalisés"><a class="header" href="#2-réseaux-docker-personnalisés"><strong>2. Réseaux Docker personnalisés</strong></a></h3>
<details>
  <summary>Exercice 4 : Réseau bridge personnalisé</summary>
<h3 id="objectif-17"><a class="header" href="#objectif-17">Objectif</a></h3>
<p>Créer un réseau bridge personnalisé et tester la communication entre conteneurs.</p>
<hr />
<h3 id="Étapes-17"><a class="header" href="#Étapes-17">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un réseau bridge personnalisé</strong> :</p>
<pre><code class="language-bash">docker network create custom-bridge
</code></pre>
</li>
<li>
<p><strong>Lancer deux conteneurs sur le réseau personnalisé</strong> :</p>
<pre><code class="language-bash">docker run -d --name container1 --network custom-bridge busybox sleep 3600
docker run -d --name container2 --network custom-bridge busybox sleep 3600
</code></pre>
</li>
<li>
<p><strong>Tester la communication</strong> :</p>
<ul>
<li>Utilisez <code>ping</code> depuis <code>container1</code> pour tester la communication avec <code>container2</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-17"><a class="header" href="#résultat-attendu-17">Résultat attendu</a></h3>
<p>Les conteneurs peuvent communiquer en utilisant leurs adresses IP ou leurs noms dans le réseau personnalisé.</p>
</details>
<details>
  <summary>Exercice 5 : Accès par nom de conteneur</summary>
<h3 id="objectif-18"><a class="header" href="#objectif-18">Objectif</a></h3>
<p>Donner des noms aux conteneurs dans un réseau personnalisé et les accéder via leurs noms.</p>
<hr />
<h3 id="Étapes-18"><a class="header" href="#Étapes-18">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer deux conteneurs avec des noms sur le réseau personnalisé</strong> :</p>
<pre><code class="language-bash">docker run -d --name named-container1 --network custom-bridge busybox sleep 3600
docker run -d --name named-container2 --network custom-bridge busybox sleep 3600
</code></pre>
</li>
<li>
<p><strong>Tester l’accès par nom</strong> :</p>
<ul>
<li>Depuis <code>named-container1</code>, pinger <code>named-container2</code> en utilisant son nom :
<pre><code class="language-bash">ping named-container2
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-18"><a class="header" href="#résultat-attendu-18">Résultat attendu</a></h3>
<p>Les conteneurs peuvent résoudre leurs noms pour communiquer dans le réseau.</p>
</details>
<details>
  <summary>Exercice 6 : Ajouter et retirer dynamiquement un conteneur</summary>
<h3 id="objectif-19"><a class="header" href="#objectif-19">Objectif</a></h3>
<p>Retirer dynamiquement un conteneur d’un réseau personnalisé, puis le réajouter.</p>
<hr />
<h3 id="Étapes-19"><a class="header" href="#Étapes-19">Étapes</a></h3>
<ol>
<li>
<p><strong>Retirer un conteneur du réseau</strong> :</p>
<pre><code class="language-bash">docker network disconnect custom-bridge container1
</code></pre>
</li>
<li>
<p><strong>Vérifier la déconnexion</strong> :</p>
<ul>
<li>Depuis <code>container2</code>, essayez de pinger <code>container1</code> (échec attendu).</li>
</ul>
</li>
<li>
<p><strong>Réajouter le conteneur au réseau</strong> :</p>
<pre><code class="language-bash">docker network connect custom-bridge container1
</code></pre>
</li>
<li>
<p><strong>Vérifier la reconnexion</strong> :</p>
<ul>
<li>Depuis <code>container2</code>, pinger <code>container1</code> à nouveau.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-19"><a class="header" href="#résultat-attendu-19">Résultat attendu</a></h3>
<p>Le conteneur peut être réintégré dynamiquement et reprendre la communication.</p>
</details>
<hr />
<h3 id="3-exposition-des-ports"><a class="header" href="#3-exposition-des-ports"><strong>3. Exposition des ports</strong></a></h3>
<details>
  <summary>Exercice 7 : Exposer des ports</summary>
<h3 id="objectif-20"><a class="header" href="#objectif-20">Objectif</a></h3>
<p>Exposer un port de conteneur à l’hôte pour un accès externe.</p>
<hr />
<h3 id="Étapes-20"><a class="header" href="#Étapes-20">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer un conteneur web</strong> :</p>
<pre><code class="language-bash">docker run -d --name nginx-container -p 8080:80 nginx
</code></pre>
</li>
<li>
<p><strong>Tester le service</strong> :</p>
<ul>
<li>Ouvrez un navigateur et accédez à <code>http://localhost:8080</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-20"><a class="header" href="#résultat-attendu-20">Résultat attendu</a></h3>
<p>La page par défaut de Nginx est accessible via le navigateur.</p>
</details>
<details>
  <summary>Exercice 8 : Mappage de ports</summary>
<h3 id="objectif-21"><a class="header" href="#objectif-21">Objectif</a></h3>
<p>Lancer deux conteneurs avec le même port interne mais des ports externes différents.</p>
<hr />
<h3 id="Étapes-21"><a class="header" href="#Étapes-21">Étapes</a></h3>
<ol>
<li>
<p><strong>Lancer le premier conteneur</strong> :</p>
<pre><code class="language-bash">docker run -d --name nginx1 -p 8081:80 nginx
</code></pre>
</li>
<li>
<p><strong>Lancer le second conteneur</strong> :</p>
<pre><code class="language-bash">docker run -d --name nginx2 -p 8082:80 nginx
</code></pre>
</li>
<li>
<p><strong>Tester les deux services</strong> :</p>
<ul>
<li>Accédez à <code>http://localhost:8081</code> et <code>http://localhost:8082</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-21"><a class="header" href="#résultat-attendu-21">Résultat attendu</a></h3>
<p>Les deux conteneurs fonctionnent simultanément avec des services accessibles sur des ports externes différents.</p>
</details>
<hr />
<h3 id="4-simulation-dun-réseau-réel"><a class="header" href="#4-simulation-dun-réseau-réel"><strong>4. Simulation d’un réseau réel</strong></a></h3>
<details>
  <summary>Exercice 9 : Réseau multi-conteneurs</summary>
<h3 id="objectif-22"><a class="header" href="#objectif-22">Objectif</a></h3>
<p>Créer un réseau personnalisé avec un service backend (MySQL) et un conteneur frontend (Nginx) et vérifier leur communication.</p>
<hr />
<h3 id="Étapes-22"><a class="header" href="#Étapes-22">Étapes</a></h3>
<ol>
<li>
<p><strong>Créer un réseau personnalisé</strong> :</p>
<pre><code class="language-bash">docker network create real-world-net
</code></pre>
</li>
<li>
<p><strong>Lancer un conteneur MySQL</strong> :</p>
<pre><code class="language-bash">docker run -d --name mysql-container --network real-world-net -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=testdb mysql:5.7
</code></pre>
</li>
<li>
<p><strong>Lancer un conteneur Nginx</strong> :</p>
<pre><code class="language-bash">docker run -d --name nginx-container --network real-world-net -p 8080:80 nginx
</code></pre>
</li>
<li>
<p><strong>Tester la communication</strong> :</p>
<ul>
<li>Vérifiez que le conteneur Nginx peut accéder à la base de données MySQL via son nom <code>mysql-container</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="résultat-attendu-22"><a class="header" href="#résultat-attendu-22">Résultat attendu</a></h3>
<p>Les deux conteneurs communiquent avec succès sur le réseau personnalisé.</p>
</details>
<h2 id="quiz-2"><a class="header" href="#quiz-2"><strong>Quiz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;networking&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Le mode réseau `None` désactive complètement la connectivité réseau pour un conteneur, offrant une isolation totale.\n&quot;,&quot;id&quot;:&quot;44499283-5bbd-4dc8-9125-d079777d90a5&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;None&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Bridge&quot;,&quot;Host&quot;,&quot;Overlay&quot;],&quot;prompt&quot;:&quot;Quel mode réseau Docker offre une isolation réseau complète ?&quot;}},{&quot;context&quot;:&quot;Le mode réseau `bridge` est utilisé par défaut, permettant aux conteneurs de communiquer avec l’hôte et entre eux via un pont réseau.\n&quot;,&quot;id&quot;:&quot;1f3b6fe9-dd15-44f9-a504-8f6fd7a0c926&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;bridge&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel est le mode réseau par défaut pour les conteneurs autonomes Docker ?&quot;}},{&quot;context&quot;:&quot;Un réseau Docker personnalisé permet aux conteneurs de se découvrir et de communiquer entre eux grâce à des noms DNS.\n&quot;,&quot;id&quot;:&quot;f26566fa-9913-431e-bac9-55ebf900c718&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Permettre la communication entre conteneurs via DNS.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Limiter l'accès réseau aux ressources externes.&quot;,&quot;Exécuter des conteneurs sans accès à Internet.&quot;,&quot;Exposer les ports des conteneurs à l'hôte.&quot;],&quot;prompt&quot;:&quot;Quel est le but d’un réseau Docker personnalisé ?&quot;}},{&quot;context&quot;:&quot;La commande `docker network disconnect` supprime la connexion d’un conteneur à un réseau sans arrêter le conteneur.\n&quot;,&quot;id&quot;:&quot;dfe4c1cb-77bf-4783-ab9e-d2871cd179d8&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker network disconnect&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quelle commande permet de déconnecter un conteneur d’un réseau Docker ?&quot;}},{&quot;context&quot;:&quot;La commande `docker network create` permet de définir un réseau personnalisé avec des options spécifiques comme le driver ou le sous-réseau.\n&quot;,&quot;id&quot;:&quot;8ff76ee4-feb6-412a-813c-d9e5be484ba7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker network create&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker create network&quot;,&quot;docker net init&quot;,&quot;docker init --network&quot;],&quot;prompt&quot;:&quot;Quelle commande permet de créer un réseau Docker personnalisé ?&quot;}},{&quot;context&quot;:&quot;La commande `docker inspect` fournit des détails complets sur un conteneur, y compris ses configurations réseau.\n&quot;,&quot;id&quot;:&quot;8e76669b-8515-427a-ade7-01b153cd58ed&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker inspect&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker network inspect&quot;,&quot;docker net status&quot;,&quot;docker ps&quot;],&quot;prompt&quot;:&quot;Quelle commande inspecte la configuration réseau d’un conteneur ?&quot;}},{&quot;context&quot;:&quot;Le flag `--network` permet de spécifier le réseau auquel le conteneur sera connecté lors de son démarrage.\n&quot;,&quot;id&quot;:&quot;39ace6f6-0dd3-4598-b0fa-a9287dd9501f&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;--network&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel flag est utilisé dans la commande `docker run` pour spécifier un réseau ?&quot;}},{&quot;context&quot;:&quot;Docker n'autorise pas deux conteneurs à exposer le même port sur l’hôte sans configuration explicite des ports externes.\n&quot;,&quot;id&quot;:&quot;3483eda4-3b44-4900-a373-4d928d2f0512&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Docker affichera une erreur pour ports en conflit.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les deux conteneurs fonctionneront sans problème.&quot;,&quot;Docker attribuera automatiquement un port externe unique à chaque conteneur.&quot;,&quot;Les conteneurs partageront dynamiquement le port.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il si vous exécutez deux conteneurs avec le même port exposé sur l’hôte sans spécifier de ports externes ?&quot;}},{&quot;context&quot;:&quot;Le driver `bridge` est utilisé par défaut pour les réseaux personnalisés, offrant une isolation et une connectivité de base.\n&quot;,&quot;id&quot;:&quot;51bc3ffe-ee7f-4516-85db-1140eea90388&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;bridge&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Quel est le driver par défaut utilisé lors de la création d’un réseau personnalisé ?&quot;}},{&quot;context&quot;:&quot;Dans les réseaux personnalisés, Docker utilise un serveur DNS intégré pour permettre aux conteneurs de se découvrir via leurs noms.\n&quot;,&quot;id&quot;:&quot;160ce730-11a4-408e-9996-1bf92b868a76&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;DNS&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Qu’est-ce que Docker utilise pour la découverte de services dans les réseaux personnalisés ?&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="ii2-docker-compose-pour-des-applications-multi-container"><a class="header" href="#ii2-docker-compose-pour-des-applications-multi-container"><strong>II.2 Docker Compose pour des Applications Multi-Container</strong></a></h1>
<hr />
<p>Les applications modernes impliquent souvent plusieurs services qui doivent fonctionner ensemble, comme un serveur web, une base de données, et un cache. <strong>Docker Compose</strong> simplifie la gestion de ces applications multi-conteneurs en permettant de les définir, configurer, et exécuter via un fichier unique (<code>docker-compose.yml</code>). Cette section explore les concepts essentiels de Docker Compose, de la configuration des services à leur mise à l'échelle et leur débogage.</p>
<hr />
<h2 id="ii2a-introduction-à-docker-compose"><a class="header" href="#ii2a-introduction-à-docker-compose"><strong>II.2.a Introduction à Docker Compose</strong></a></h2>
<h3 id="quest-ce-que-docker-compose-"><a class="header" href="#quest-ce-que-docker-compose-"><strong>Qu’est-ce que Docker Compose ?</strong></a></h3>
<p>Docker Compose est un outil qui permet de définir et de gérer des applications conteneurisées composées de plusieurs services dans un fichier YAML. Il est particulièrement utile pour :</p>
<ul>
<li>Décrire les dépendances d’une application dans un fichier <code>docker-compose.yml</code>.</li>
<li>Lancer ou arrêter tous les services associés avec une seule commande.</li>
<li>Simplifier la gestion des réseaux, volumes, et configurations pour des applications complexes.</li>
</ul>
<h3 id="structure-clé-dun-fichier-docker-composeyml"><a class="header" href="#structure-clé-dun-fichier-docker-composeyml"><strong>Structure clé d’un fichier docker-compose.yml</strong></a></h3>
<p>Un fichier <code>docker-compose.yml</code> est structuré autour des éléments suivants :</p>
<ol>
<li><strong>Version :</strong> Définit la version du fichier Compose.</li>
<li><strong>Services :</strong> Liste les conteneurs qui composent l’application, avec leurs configurations respectives.</li>
<li><strong>Réseaux :</strong> Définit comment les conteneurs communiquent entre eux.</li>
<li><strong>Volumes :</strong> Permet de gérer les données persistantes.</li>
</ol>
<p><strong>Exemple minimaliste :</strong></p>
<pre><code class="language-yaml">version: "3.9"
services:
  web:
    image: nginx
    ports:
      - "8080:80"
  database:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: example
</code></pre>
<p>Dans cet exemple :</p>
<ul>
<li><code>web</code> exécute un serveur Nginx accessible sur le port 8080.</li>
<li><code>database</code> exécute une base MySQL avec une variable d’environnement.</li>
</ul>
<p>Pour plus de détails : <a href="https://docs.docker.com/compose/">Documentation officielle Docker Compose</a>.</p>
<hr />
<h2 id="ii2b-définir-et-exécuter-des-services"><a class="header" href="#ii2b-définir-et-exécuter-des-services"><strong>II.2.b Définir et exécuter des services</strong></a></h2>
<h4 id="créer-plusieurs-services-dans-un-seul-fichier"><a class="header" href="#créer-plusieurs-services-dans-un-seul-fichier"><strong>Créer plusieurs services dans un seul fichier</strong></a></h4>
<p>Docker Compose permet de définir plusieurs services et leurs dépendances dans un fichier YAML.</p>
<p><strong>Exemple : Application avec un backend et une base de données</strong></p>
<pre><code class="language-yaml">version: "3.9"
services:
  backend:
    image: python:3.9
    volumes:
      - "./app:/usr/src/app"
    working_dir: /usr/src/app
    command: python app.py
  database:
    image: postgres
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
</code></pre>
<h3 id="lancer-et-arrêter-les-services-avec-docker-compose"><a class="header" href="#lancer-et-arrêter-les-services-avec-docker-compose"><strong>Lancer et arrêter les services avec Docker Compose</strong></a></h3>
<ul>
<li>
<p><strong>Lancer les services :</strong></p>
<pre><code class="language-bash">docker compose up
</code></pre>
</li>
<li>
<p><strong>Arrêter les services :</strong></p>
<pre><code class="language-bash">docker compose down
</code></pre>
</li>
</ul>
<p>Compose gère automatiquement la création des conteneurs, des réseaux et des volumes nécessaires.</p>
<hr />
<h2 id="ii2c-configuration-des-services"><a class="header" href="#ii2c-configuration-des-services"><strong>II.2.c Configuration des services</strong></a></h2>
<h3 id="variables-denvironnement"><a class="header" href="#variables-denvironnement"><strong>Variables d’environnement</strong></a></h3>
<p>Les variables d’environnement permettent de passer des configurations dynamiques aux services.</p>
<p><strong>Exemple avec un fichier <code>.env</code> :</strong>
<code>.env</code> :</p>
<pre><code>MYSQL_USER=root
MYSQL_PASSWORD=example
</code></pre>
<p><code>docker-compose.yml</code> :</p>
<pre><code class="language-yaml">version: "3.9"
services:
  database:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
</code></pre>
<p>Compose charge automatiquement les variables d’un fichier <code>.env</code> s’il est présent.</p>
<hr />
<h3 id="mapping-des-ports-et-gestion-des-volumes"><a class="header" href="#mapping-des-ports-et-gestion-des-volumes"><strong>Mapping des ports et gestion des volumes</strong></a></h3>
<ul>
<li>
<p><strong>Ports :</strong> Connectent les ports de l’hôte à ceux du conteneur.<br />
Exemple :</p>
<pre><code class="language-yaml">ports:
  - "8080:80"
</code></pre>
</li>
<li>
<p><strong>Volumes :</strong> Gèrent les données persistantes.<br />
Exemple :</p>
<pre><code class="language-yaml">volumes:
  - "./data:/var/lib/mysql"
</code></pre>
</li>
</ul>
<hr />
<h3 id="gérer-les-dépendances-entre-services"><a class="header" href="#gérer-les-dépendances-entre-services"><strong>Gérer les dépendances entre services</strong></a></h3>
<p>Vous pouvez définir l’ordre de démarrage des services à l’aide de <code>depends_on</code> :</p>
<pre><code class="language-yaml">version: "3.9"
services:
  web:
    image: nginx
    depends_on:
      - database
  database:
    image: mysql
</code></pre>
<p>Dans cet exemple, Docker Compose s’assure que le service <code>database</code> démarre avant <code>web</code>.</p>
<hr />
<h2 id="ii2d-scalabilité-des-services"><a class="header" href="#ii2d-scalabilité-des-services"><strong>II.2.d Scalabilité des services</strong></a></h2>
<h3 id="mise-à-léchelle-horizontale"><a class="header" href="#mise-à-léchelle-horizontale"><strong>Mise à l’échelle horizontale</strong></a></h3>
<p>Docker Compose permet de scaler un service pour exécuter plusieurs instances. Cela est particulièrement utile pour les services stateless comme les serveurs web.</p>
<p><strong>Exemple : Scaler un service</strong></p>
<pre><code class="language-bash">docker compose up --scale web=3
</code></pre>
<p>Cela démarre 3 instances du service <code>web</code>.</p>
<hr />
<h3 id="test-de-léquilibrage-de-charge"><a class="header" href="#test-de-léquilibrage-de-charge"><strong>Test de l’équilibrage de charge</strong></a></h3>
<p>Avec plusieurs instances d’un service, Compose utilise des réseaux Docker pour équilibrer automatiquement les connexions entrantes. Vous pouvez tester ce comportement en envoyant des requêtes répétées à un service scaled.</p>
<hr />
<h2 id="ii2e-logs-et-débogage-avec-docker-compose"><a class="header" href="#ii2e-logs-et-débogage-avec-docker-compose"><strong>II.2.e Logs et débogage avec Docker Compose</strong></a></h2>
<ul>
<li>
<p><strong>Afficher les logs d’un service spécifique :</strong></p>
<pre><code class="language-bash">docker compose logs &lt;service_name&gt;
</code></pre>
<p>Exemple :</p>
<pre><code class="language-bash">docker compose logs web
</code></pre>
</li>
<li>
<p><strong>Déboguer les erreurs dans le fichier docker-compose.yml :</strong></p>
<ul>
<li>Vérifiez les erreurs de syntaxe avec :
<pre><code class="language-bash">docker compose config
</code></pre>
</li>
<li>Assurez-vous que toutes les variables d’environnement sont définies correctement.</li>
</ul>
</li>
</ul>
<h2 id="exercices-3"><a class="header" href="#exercices-3"><strong>Exercices</strong></a></h2>
<hr />
<h3 id="1-creating-a-basic-docker-composeyml-file"><a class="header" href="#1-creating-a-basic-docker-composeyml-file"><strong>1. Creating a Basic <code>docker-compose.yml</code> File</strong></a></h3>
<details>
  <summary>Exercise 1: Define a Web App and Database</summary>
<h3 id="goal"><a class="header" href="#goal">Goal</a></h3>
<p>Create a <code>docker-compose.yml</code> file for a web app (e.g., Flask) and a database (e.g., MySQL) and test connectivity between the containers.</p>
<hr />
<h3 id="steps"><a class="header" href="#steps">Steps</a></h3>
<ol>
<li>
<p><strong>Create the Compose file</strong>:</p>
<ul>
<li>Define the following services in <code>docker-compose.yml</code>:
<pre><code class="language-yaml">version: "3.8"
services:
  web:
    image: python:3.9
    command: &gt;
      sh -c "pip install flask &amp;&amp; python -m flask run --host=0.0.0.0"
    ports:
      - "5000:5000"
    depends_on:
      - db
  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: testdb
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Start the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Test connectivity</strong>:</p>
<ul>
<li>Connect to the <code>web</code> container and check if it can access the <code>db</code> service using its hostname <code>db</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result"><a class="header" href="#expected-result">Expected Result</a></h3>
<p>The web app connects successfully to the MySQL database using the hostname <code>db</code>.</p>
</details>
<details>
  <summary>Exercise 2: Add Port Mapping</summary>
<h3 id="goal-1"><a class="header" href="#goal-1">Goal</a></h3>
<p>Add port mapping to the web app and verify external access.</p>
<hr />
<h3 id="steps-1"><a class="header" href="#steps-1">Steps</a></h3>
<ol>
<li>
<p><strong>Modify <code>docker-compose.yml</code></strong>:</p>
<ul>
<li>Ensure the web app’s service includes:
<pre><code class="language-yaml">ports:
  - "5000:5000"
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Restart the Compose stack</strong>:</p>
<pre><code class="language-bash">docker-compose down
docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Verify external access</strong>:</p>
<ul>
<li>Open your browser and navigate to <code>http://localhost:5000</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-1"><a class="header" href="#expected-result-1">Expected Result</a></h3>
<p>The web app is accessible externally via the host browser.</p>
</details>
<details>
  <summary>Exercise 3: Add Environment Variables</summary>
<h3 id="goal-2"><a class="header" href="#goal-2">Goal</a></h3>
<p>Configure the database connection in the web app using environment variables.</p>
<hr />
<h3 id="steps-2"><a class="header" href="#steps-2">Steps</a></h3>
<ol>
<li>
<p><strong>Update <code>docker-compose.yml</code></strong>:</p>
<ul>
<li>Add environment variables to the <code>web</code> service:
<pre><code class="language-yaml">environment:
  DB_HOST: db
  DB_NAME: testdb
  DB_USER: root
  DB_PASSWORD: root
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Modify the web app to use these variables</strong>:</p>
<ul>
<li>Update the Flask app to read database credentials from environment variables using Python’s <code>os.environ</code>.</li>
</ul>
</li>
<li>
<p><strong>Restart the Compose stack</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Verify the connection</strong>:</p>
<ul>
<li>Test that the web app successfully connects to the database using the environment variables.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-2"><a class="header" href="#expected-result-2">Expected Result</a></h3>
<p>The web app connects to the database using the configured environment variables.</p>
</details>
<hr />
<h3 id="2-managing-multi-container-applications"><a class="header" href="#2-managing-multi-container-applications"><strong>2. Managing Multi-Container Applications</strong></a></h3>
<details>
  <summary>Exercise 4: Start and Stop Services</summary>
<h3 id="goal-3"><a class="header" href="#goal-3">Goal</a></h3>
<p>Learn to start and stop a multi-container setup using Docker Compose.</p>
<hr />
<h3 id="steps-3"><a class="header" href="#steps-3">Steps</a></h3>
<ol>
<li>
<p><strong>Start the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Stop the services and clean up resources</strong>:</p>
<pre><code class="language-bash">docker-compose down
</code></pre>
</li>
</ol>
<hr />
<h3 id="expected-result-3"><a class="header" href="#expected-result-3">Expected Result</a></h3>
<p>The multi-container setup starts and stops cleanly with no leftover resources.</p>
</details>
<details>
  <summary>Exercise 5: Restart Specific Services</summary>
<h3 id="goal-4"><a class="header" href="#goal-4">Goal</a></h3>
<p>Restart a specific service using Docker Compose.</p>
<hr />
<h3 id="steps-4"><a class="header" href="#steps-4">Steps</a></h3>
<ol>
<li>
<p><strong>Start the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Restart the database service</strong>:</p>
<pre><code class="language-bash">docker-compose restart db
</code></pre>
</li>
<li>
<p><strong>Observe the behavior</strong>:</p>
<ul>
<li>Check logs for the restarted service to confirm its behavior.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-4"><a class="header" href="#expected-result-4">Expected Result</a></h3>
<p>Only the specified service restarts, while others continue running.</p>
</details>
<hr />
<h3 id="3-scaling-services"><a class="header" href="#3-scaling-services"><strong>3. Scaling Services</strong></a></h3>
<details>
  <summary>Exercise 6: Scale a Stateless Service</summary>
<h3 id="goal-5"><a class="header" href="#goal-5">Goal</a></h3>
<p>Scale a stateless web application to multiple instances using Docker Compose.</p>
<hr />
<h3 id="steps-5"><a class="header" href="#steps-5">Steps</a></h3>
<ol>
<li>
<p><strong>Update the Compose file</strong>:</p>
<ul>
<li>Use an nginx image for the web service.</li>
</ul>
</li>
<li>
<p><strong>Scale the web service</strong>:</p>
<pre><code class="language-bash">docker-compose up -d --scale web=3
</code></pre>
</li>
<li>
<p><strong>Verify the scaling</strong>:</p>
<ul>
<li>Use <code>docker-compose ps</code> to see the scaled instances.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-5"><a class="header" href="#expected-result-5">Expected Result</a></h3>
<p>Three instances of the web service are running.</p>
</details>
<details>
  <summary>Exercise 7: Test Scaled Services</summary>
<h3 id="goal-6"><a class="header" href="#goal-6">Goal</a></h3>
<p>Test the behavior of scaled services by sending multiple requests.</p>
<hr />
<h3 id="steps-6"><a class="header" href="#steps-6">Steps</a></h3>
<ol>
<li>
<p><strong>Send multiple requests</strong>:</p>
<pre><code class="language-bash">for i in {1..10}; do curl http://localhost:5000; done
</code></pre>
</li>
<li>
<p><strong>Observe load balancing</strong>:</p>
<ul>
<li>Note if the requests are distributed across different instances (requires a load balancer).</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-6"><a class="header" href="#expected-result-6">Expected Result</a></h3>
<p>Requests are distributed across multiple instances.</p>
</details>
<hr />
<h3 id="4-advanced-configuration"><a class="header" href="#4-advanced-configuration"><strong>4. Advanced Configuration</strong></a></h3>
<details>
  <summary>Exercise 8: Shared Volume</summary>
<h3 id="goal-7"><a class="header" href="#goal-7">Goal</a></h3>
<p>Define a shared volume in the Compose file and test data persistence.</p>
<hr />
<h3 id="steps-7"><a class="header" href="#steps-7">Steps</a></h3>
<ol>
<li>
<p><strong>Update the Compose file</strong>:</p>
<ul>
<li>Add a shared volume for the services:
<pre><code class="language-yaml">volumes:
  shared-data:
services:
  web:
    ...
    volumes:
      - shared-data:/app/data
  db:
    ...
    volumes:
      - shared-data:/var/lib/mysql
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Restart the services</strong>:</p>
<pre><code class="language-bash">docker-compose down
docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Test persistence</strong>:</p>
<ul>
<li>Add files or data and restart the services to verify persistence.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-7"><a class="header" href="#expected-result-7">Expected Result</a></h3>
<p>Data persists across service restarts.</p>
</details>
<details>
  <summary>Exercise 9: Service Dependencies</summary>
<h3 id="goal-8"><a class="header" href="#goal-8">Goal</a></h3>
<p>Set dependencies between services using the <code>depends_on</code> property.</p>
<hr />
<h3 id="steps-8"><a class="header" href="#steps-8">Steps</a></h3>
<ol>
<li>
<p><strong>Update <code>docker-compose.yml</code></strong>:</p>
<ul>
<li>Add <code>depends_on</code> to ensure the database starts before the web app:
<pre><code class="language-yaml">web:
  ...
  depends_on:
    - db
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Restart the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Verify behavior</strong>:</p>
<ul>
<li>Confirm that the web app only starts after the database.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="expected-result-8"><a class="header" href="#expected-result-8">Expected Result</a></h3>
<p>Services respect the specified startup order.</p>
</details>
<hr />
<h3 id="5-logs-and-debugging"><a class="header" href="#5-logs-and-debugging"><strong>5. Logs and Debugging</strong></a></h3>
<details>
  <summary>Exercise 10: View Service Logs</summary>
<h3 id="goal-9"><a class="header" href="#goal-9">Goal</a></h3>
<p>Use <code>docker-compose logs</code> to view logs for individual services.</p>
<hr />
<h3 id="steps-9"><a class="header" href="#steps-9">Steps</a></h3>
<ol>
<li>
<p><strong>Start the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>View logs for a specific service</strong>:</p>
<pre><code class="language-bash">docker-compose logs web
</code></pre>
</li>
</ol>
<hr />
<h3 id="expected-result-9"><a class="header" href="#expected-result-9">Expected Result</a></h3>
<p>Logs for the web service are displayed.</p>
</details>
<details>
  <summary>Exercise 11: Troubleshooting Syntax Errors</summary>
<h3 id="goal-10"><a class="header" href="#goal-10">Goal</a></h3>
<p>Identify and fix syntax errors in a <code>docker-compose.yml</code> file.</p>
<hr />
<h3 id="steps-10"><a class="header" href="#steps-10">Steps</a></h3>
<ol>
<li>
<p><strong>Introduce an error</strong>:</p>
<ul>
<li>Modify the Compose file with a syntax error (e.g., remove a colon).</li>
</ul>
</li>
<li>
<p><strong>Try starting the services</strong>:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
<li>
<p><strong>Analyze the error</strong>:</p>
<ul>
<li>Read the error message and locate the issue.</li>
</ul>
</li>
<li>
<p><strong>Fix the error</strong> and retry:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
</li>
</ol>
<hr />
<h3 id="expected-result-10"><a class="header" href="#expected-result-10">Expected Result</a></h3>
<p>The syntax error is identified and resolved.</p>
</details>
<h2 id="quiz-3"><a class="header" href="#quiz-3"><strong>Quiz</strong></a></h2>
<div class="quiz-placeholder" data-quiz-name="&quot;compose&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Docker Compose permet de configurer et gérer plusieurs conteneurs qui forment une application à l'aide d'un fichier YAML.\n&quot;,&quot;id&quot;:&quot;567fa239-fe33-4fdf-89cd-5b214bacbeb8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Gérer et orchestrer des applications multi-conteneurs.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Créer des images Docker.&quot;,&quot;Optimiser les performances des conteneurs.&quot;,&quot;Résoudre les problèmes réseau entre conteneurs.&quot;],&quot;prompt&quot;:&quot;Quel est l'objectif principal de Docker Compose ?&quot;}},{&quot;context&quot;:&quot;Le fichier `docker-compose.yml` est le fichier standard utilisé par Docker Compose pour configurer des services, des réseaux et des volumes.\n&quot;,&quot;id&quot;:&quot;ae4e536e-63cb-460f-8cd9-e9a112f602b5&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker-compose.yml&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker-compose.config&quot;,&quot;docker.json&quot;,&quot;docker-compose.yaml&quot;],&quot;prompt&quot;:&quot;Quel fichier est utilisé pour configurer une application multi-conteneurs ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose up` démarre tous les services définis dans le fichier `docker-compose.yml`.\n&quot;,&quot;id&quot;:&quot;467a6be2-a964-499e-8fe0-c8997ab8028a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose up&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose start&quot;,&quot;docker compose init&quot;,&quot;docker compose create&quot;],&quot;prompt&quot;:&quot;Quelle commande démarre une application multi-conteneurs définie par Docker Compose ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose down` arrête tous les services, supprime les conteneurs, réseaux et volumes créés par Docker Compose.\n&quot;,&quot;id&quot;:&quot;c639b6f3-71d0-4508-905a-a7438c4772ce&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose down&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose stop&quot;,&quot;docker compose kill&quot;,&quot;docker compose down --remove-all&quot;],&quot;prompt&quot;:&quot;Quelle commande arrête et supprime les services Docker Compose ainsi que leurs réseaux associés ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose up --scale &lt;nom-service&gt;=&lt;nombre&gt;` permet d'augmenter ou de réduire le nombre d'instances d'un service.\n&quot;,&quot;id&quot;:&quot;889b1fea-ad21-4cb9-9671-6a9e235f8b9f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose up --scale &lt;nom-service&gt;=&lt;nombre&gt;&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose scale&quot;,&quot;docker compose resize&quot;,&quot;docker compose expand&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour mettre à l'échelle un service défini dans un fichier Compose ?&quot;}},{&quot;context&quot;:&quot;La section `environment` permet de définir des variables d'environnement accessibles dans un conteneur.\n&quot;,&quot;id&quot;:&quot;cb5412b3-0ac8-438c-bf48-3304c710b1d8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;environment&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;env&quot;,&quot;config&quot;,&quot;variables&quot;],&quot;prompt&quot;:&quot;Quelle section du fichier Compose est utilisée pour définir des variables d'environnement ?&quot;}},{&quot;context&quot;:&quot;La propriété `depends_on` détermine l'ordre dans lequel les services sont démarrés, mais elle ne garantit pas qu'un service soit prêt avant d'en lancer un autre.\n&quot;,&quot;id&quot;:&quot;3837d605-4742-4f92-851d-28e4dea8dcc3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Spécifie l’ordre de démarrage des services.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Configure un service pour attendre qu’un autre soit en bonne santé avant de démarrer.&quot;,&quot;Crée des liens réseau entre les services.&quot;,&quot;Redémarre automatiquement les services dépendants en cas d’échec.&quot;],&quot;prompt&quot;:&quot;Que fait la propriété `depends_on` dans un fichier `docker-compose.yml` ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose logs &lt;nom-service&gt;` affiche les journaux du service spécifié. Ajoutez `--follow` pour un affichage en temps réel.\n&quot;,&quot;id&quot;:&quot;09bb67f9-efda-45d2-84fd-3467d276f6ce&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose logs &lt;nom-service&gt;&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose logs --all&quot;,&quot;docker compose logs &lt;nom-service&gt; --follow&quot;,&quot;docker compose logs --tail&quot;],&quot;prompt&quot;:&quot;Comment afficher les journaux d’un service spécifique géré avec Docker Compose ?&quot;}},{&quot;context&quot;:&quot;La propriété `ports` permet de définir le mapping entre un port interne au conteneur et un port externe sur l’hôte.\n&quot;,&quot;id&quot;:&quot;aa7f0d22-a5f0-4fbb-a687-69353165ea5e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;ports&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;expose&quot;,&quot;ports&quot;,&quot;publish&quot;],&quot;prompt&quot;:&quot;Quelle propriété dans un fichier Compose est utilisée pour mapper un port conteneur à un port hôte ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose config` valide et affiche la configuration résultante du fichier `docker-compose.yml`.\n&quot;,&quot;id&quot;:&quot;f3e6abbe-a0f6-4319-8c7c-19dfb9facfb2&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose config&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose verify&quot;,&quot;docker compose check&quot;,&quot;docker compose inspect&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour vérifier la configuration d’un fichier Compose ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose stop` arrête tous les conteneurs définis sans les supprimer, permettant de les redémarrer rapidement.\n&quot;,&quot;id&quot;:&quot;027e544d-29cd-4d05-b099-c30cc050aca9&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Arrête les conteneurs sans les supprimer.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Arrête et supprime tous les conteneurs.&quot;,&quot;Redémarre tous les conteneurs arrêtés.&quot;,&quot;Supprime les réseaux associés aux services.&quot;],&quot;prompt&quot;:&quot;Que fait la commande `docker compose stop` ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose ps` affiche une liste des conteneurs gérés par Docker Compose ainsi que leur état.\n&quot;,&quot;id&quot;:&quot;52d3454d-56b7-42c9-a5c5-17334c11c7f3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose ps&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose ps --all&quot;,&quot;docker compose inspect&quot;,&quot;docker compose status&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour afficher l'état des services dans Docker Compose ?&quot;}},{&quot;context&quot;:&quot;Lorsque vous exécutez `docker compose up`, Docker Compose vérifie si les conteneurs existent déjà et les utilise sans les recréer.\n&quot;,&quot;id&quot;:&quot;143e7a23-1f31-41fc-b13b-d3dda2b695b7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les conteneurs en cours d'exécution sont utilisés tels quels.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs en cours d'exécution sont arrêtés et recréés.&quot;,&quot;De nouveaux conteneurs sont créés sans arrêter les anciens.&quot;,&quot;La commande ne fait rien car les conteneurs sont déjà en cours d'exécution.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il lorsque vous exécutez `docker compose up` sur une application déjà en cours d'exécution ?&quot;}},{&quot;context&quot;:&quot;La section `volumes` permet de définir et d'attacher des volumes pour la persistance des données dans les services.\n&quot;,&quot;id&quot;:&quot;3231a39f-84eb-42b4-812c-0a69baccc0d7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;volumes&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;binds&quot;,&quot;mounts&quot;,&quot;storage&quot;],&quot;prompt&quot;:&quot;Quelle section est utilisée pour monter un volume dans un service Docker Compose ?&quot;}},{&quot;context&quot;:&quot;Docker Compose utilise le driver `bridge` par défaut pour connecter les conteneurs d'une application.\n&quot;,&quot;id&quot;:&quot;b88a9537-0c21-43cf-9887-66baedc01789&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;bridge&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;host&quot;,&quot;bridge&quot;,&quot;overlay&quot;],&quot;prompt&quot;:&quot;Quel driver réseau est utilisé par défaut dans Docker Compose ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose network ls` liste les réseaux définis pour une application Docker Compose.\n&quot;,&quot;id&quot;:&quot;9f457b3b-f49d-4dda-8e5f-1b13d6aa4146&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose network ls&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose inspect network&quot;,&quot;docker compose net-info&quot;,&quot;docker compose network status&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour afficher les informations réseau des services ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose up --force-recreate` recrée uniquement les conteneurs affectés par des modifications.\n&quot;,&quot;id&quot;:&quot;f890d59a-4e43-49ec-91a4-73f9c90638e2&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose up --force-recreate&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose restart&quot;,&quot;docker compose reload&quot;,&quot;docker compose recreate&quot;],&quot;prompt&quot;:&quot;Quelle commande Docker Compose est utilisée pour recréer uniquement des conteneurs modifiés ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose build` compile les images définies dans la section `build` du fichier `docker-compose.yml`.\n&quot;,&quot;id&quot;:&quot;fee59a64-184d-40e1-b8d6-66e8539d5efd&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Elle construit les images définies dans le fichier Compose.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Elle télécharge des images Docker.&quot;,&quot;Elle démarre tous les services d’une application.&quot;,&quot;Elle crée des réseaux pour l'application.&quot;],&quot;prompt&quot;:&quot;Que fait la commande `docker compose build` ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose down --volumes` supprime non seulement les conteneurs et réseaux, mais aussi les volumes associés à une application Docker Compose.\n&quot;,&quot;id&quot;:&quot;3241b53f-a343-4a06-9f07-6f9996abef15&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose down --volumes&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose clean&quot;,&quot;docker compose prune&quot;,&quot;docker compose remove --all&quot;],&quot;prompt&quot;:&quot;Quelle commande est utilisée pour supprimer tous les volumes, conteneurs et réseaux inutilisés dans une application Docker Compose ?&quot;}},{&quot;context&quot;:&quot;La propriété `build` est utilisée dans un fichier Compose pour spécifier un contexte ou un Dockerfile permettant de construire une image personnalisée.\n&quot;,&quot;id&quot;:&quot;560a4290-15c9-4328-ad54-1581ba935fa1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Elle indique le chemin ou contexte pour construire une image Docker.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Elle spécifie une image Docker pré-construite.&quot;,&quot;Elle configure les réseaux à utiliser pour le service.&quot;,&quot;Elle définit les volumes pour stocker les données.&quot;],&quot;prompt&quot;:&quot;Que fait la propriété `build` dans un fichier `docker-compose.yml` ?&quot;}},{&quot;context&quot;:&quot;La commande `docker compose version` affiche la version actuellement installée de Docker Compose.\n&quot;,&quot;id&quot;:&quot;ffd0e128-5020-4101-9f70-d249f0b99447&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;docker compose version&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;docker compose check&quot;,&quot;docker compose version&quot;,&quot;docker compose info&quot;],&quot;prompt&quot;:&quot;Quelle commande permet de vérifier si Docker Compose est installé et connaître sa version ?&quot;}},{&quot;context&quot;:&quot;`docker compose restart` redémarre le conteneur d'un service sans en modifier la configuration ou recréer l'image.\n&quot;,&quot;id&quot;:&quot;713cf681-c52c-4a1c-ba97-dd1035504f94&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Elle redémarre le service sans le recréer.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Elle supprime et recrée le conteneur du service.&quot;,&quot;Elle redémarre le service sans le recréer.&quot;,&quot;Elle reconstruit l’image associée au service.&quot;],&quot;prompt&quot;:&quot;Que fait la commande `docker compose restart &lt;service&gt;` ?&quot;}},{&quot;context&quot;:&quot;Deux services ne peuvent pas exposer les mêmes ports sur l’hôte sans configuration explicite. Cela génère une erreur.\n&quot;,&quot;id&quot;:&quot;ed781dd7-7718-411c-8652-e8754f0acf51&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Un conflit se produira et l’application ne démarrera pas.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs partageront les ports.&quot;,&quot;Un conflit se produira et l’application ne démarrera pas.&quot;,&quot;Docker attribuera des ports dynamiques.&quot;],&quot;prompt&quot;:&quot;Que se passe-t-il si deux services dans un fichier `docker-compose.yml` ont des ports identiques exposés ?&quot;}},{&quot;context&quot;:&quot;Docker Compose réutilise les volumes existants pour éviter de perdre les données persistantes stockées dans les conteneurs.\n&quot;,&quot;id&quot;:&quot;810d9d87-efb3-4e19-b566-f052b5a1e9c4&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les volumes existants sont réutilisés.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les volumes sont recréés à chaque fois.&quot;,&quot;Les volumes existants sont réutilisés.&quot;,&quot;Les données dans les volumes sont remplacées.&quot;],&quot;prompt&quot;:&quot;Comment Docker Compose gère-t-il les volumes si vous relancez une application sans les supprimer ?&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="exercices-4"><a class="header" href="#exercices-4">Exercices</a></h1>
<h2 id="notions-fondamentales-de-docker"><a class="header" href="#notions-fondamentales-de-docker">Notions fondamentales de Docker</a></h2>
<ul>
<li><a href="exercises/./ms_builds.html">Multistage Builds</a></li>
<li><a href="exercises/./nginx_server_setup.html">Nginx Server Setup</a></li>
<li><a href="exercises/./nginx_reverse_proxy.html">Nginx Reverse Proxy</a></li>
</ul>
<h2 id="introduction-à-kubernetes"><a class="header" href="#introduction-à-kubernetes">Introduction à Kubernetes</a></h2>
<ul>
<li><a href="exercises/./hello-minikube.html">Hello Minikube</a></li>
<li><a href="exercises/./first-deployment.html">First Deployment</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercice"><a class="header" href="#exercice">Exercice</a></h1>
<p><strong>Contenerization using multistages builds</strong></p>
<p>Here is a sampe C++ program:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main(void){
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return (0);
}
</code></pre>
<p>Here is the sequence of instructions that you should follow :</p>
<details>
<summary>Part 1: Project files retrieval</summary>
<ol>
<li>Run a container interactively using the base image alpine and <strong>bind</strong> a volume called <code>project_files</code> to the folder <code>/project</code> on your container.</li>
<li>Create the <code>hello_word.cpp</code> file <strong>within</strong> the container in the <code>/project</code> directory and commit the result as a new image called <code>project_files</code></li>
</ol>
</details>
<details>
<summary>Part 2: Project building</summary>
<p>At this point in the exercise you should have a new base image containing only alpine and the <code>hello_world.cpp</code> file in the <code>/project</code> folder.</p>
<ol start="3">
<li>Run another container interactively based on the image  <code>project_files</code></li>
<li>Install the tools needed in order to build the sample c++ program.</li>
<li>Build the sample program and move the executable to <code>/project/bin</code>, creating the directory if needed</li>
<li>Commit the result as a new layer, calling it : <code>executable</code></li>
</ol>
</details>
<details>
<summary>Part 3: Writting the Dockerfile</summary>
<p>At this point, you should be able to run : <code>docker run executable /project/bin/hello_world</code> and everything should be working</p>
<ol start="7">
<li>Now that you know how to do this from the command line, this step is pretty straightforward, you should put all the previous steps but in your Dockerfile. It has to start with the instruction <code>FROM project_files</code></li>
</ol>
</details>
<details>
<summary>Part 4: Multistage Build</summary>
<p>Running <code>docker build -t dockerfile_executable . &amp;&amp; docker run dockerfile_executable</code> should print <code>Hello World!</code> to <code>stdout</code></p>
<ol start="8">
<li>Split the build into multiple stages, the final image should contain only the executable.</li>
</ol>
</details>
<details>
<summary>Part 5: Comparison between both types of build</summary>
<p>Here is an example of what you may see when running <code>docker image history multistage_image</code> for the image generated during the multistages build</p>
<pre><code class="language-bash">IMAGE          CREATED       CREATED BY                            SIZE      COMMENT
df5a49f5c822   2 hours ago   ENTRYPOINT ["./hello_world"]          0B        buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   COPY /test/hello_world . # buildkit   72.9kB    buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   WORKDIR /RUN                          0B        buildkit.dockerfile.v0
</code></pre>
<p>Find a way to compare the size of the two generated images and explain briefly why splitting builds into multiple stages affects the size of the resulting image</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-setting-up-an-nginx-server-with-dynamic-content"><a class="header" href="#exercise-setting-up-an-nginx-server-with-dynamic-content"><strong>Exercise: Setting Up an Nginx Server with Dynamic Content</strong></a></h1>
<h2 id="scenario"><a class="header" href="#scenario"><strong>Scenario:</strong></a></h2>
<p>You are tasked with deploying a Dockerized Nginx server to host a static website. The server must:</p>
<ol>
<li>Serve files stored in a host directory (bind mount).</li>
<li>Be accessible via a custom Docker network.</li>
<li>Use a custom configuration for the server.</li>
</ol>
<p>You will write a Dockerfile to build the Nginx image and manually create the necessary volumes and networks.</p>
<hr />
<h2 id="part-1-project-setup"><a class="header" href="#part-1-project-setup"><strong>Part 1: Project Setup</strong></a></h2>
<details>
<summary>Tasks</summary>
<ol>
<li>
<p><strong>Create the following project structure:</strong></p>
<pre><code>nginx-exercise/
├─- server_conf
  └── nginx.conf
├── site_files
   └── index.html
└── Dockerfile
</code></pre>
</li>
<li>
<p><strong>Write <code>index.html</code>:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Welcome to Nginx&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello from Nginx!&lt;/h1&gt;
    &lt;p&gt;This content is served dynamically from a bind mount.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p><strong>Write <code>nginx.conf</code>:</strong></p>
<pre><code class="language-nginx">server {
    listen 80;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}
</code></pre>
</li>
</ol>
</details>
<hr />
<h2 id="part-2-writing-the-dockerfile"><a class="header" href="#part-2-writing-the-dockerfile"><strong>Part 2: Writing the Dockerfile</strong></a></h2>
<details>
<summary>Tasks</summary>
<ol>
<li><strong>Write a <code>Dockerfile</code>:</strong>
<ul>
<li>Use the <code>nginx:alpine</code> base image.</li>
<li>Copy the custom <code>nginx.conf</code> into the container's <code>/etc/nginx/conf.d/</code> directory.</li>
<li>Expose port <code>80</code> for the server.</li>
</ul>
</li>
</ol>
<details>
<summary>First Hint</summary>
<p>If stuck, you can run <code>docker image history nginx:alpine</code> in order to understand the different layers of the image</p>
</details>
<details>
<summary>Second Hint</summary>
<p>If you don't specify any CMD nor ENTRYPOINT in your Dockerfile, it is the first one set that is used.</p>
</details>
<ol start="2">
<li><strong>Build the Docker image:</strong>
The docker image should be named <code>nginx-exercise-image</code></li>
</ol>
</details>
<hr />
<h2 id="part-3-creating-and-using-volumes"><a class="header" href="#part-3-creating-and-using-volumes"><strong>Part 3: Creating and Using Volumes</strong></a></h2>
<details>
<summary>Tasks</summary>
<ol>
<li>
<p><strong>Create a bind mount volume:</strong></p>
<ul>
<li>Use the <code>nginx-exercise/site_files</code> directory as a bind mount to serve dynamic content.</li>
<li>Run the container mounting the directory on the correct location in the container.</li>
</ul>
</li>
<li>
<p><strong>Test the server:</strong></p>
<ul>
<li>Visit <code>http://localhost:8080</code> in your browser and confirm that the content from <code>index.html</code> is displayed. Everything should work great at this stage. If not, think about what you need to add to the command you used to make it work.</li>
</ul>
</li>
<li>
<p><strong>Challenge:</strong></p>
<ul>
<li>Modify <code>index.html</code> on the host machine and reload the webpage. Observe how the changes are reflected dynamically.</li>
</ul>
</li>
</ol>
</details>
<hr />
<h2 id="part-4-networking"><a class="header" href="#part-4-networking"><strong>Part 4: Networking</strong></a></h2>
<details>
<summary>Tasks</summary>
<ol>
<li>
<p><strong>Create a custom Docker network:</strong></p>
<ul>
<li>create a docker network named <code>nginx-net</code></li>
</ul>
</li>
<li>
<p><strong>Run the container on the custom network:</strong></p>
<ul>
<li>Stop the container.</li>
<li>Start it again  the <code>nginx-net</code> network.</li>
</ul>
</li>
<li>
<p><strong>Inspect the network:</strong></p>
<ul>
<li>Verify the container is connected to the network:
<pre><code class="language-bash">docker network inspect nginx-net
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Challenge:</strong></p>
<ul>
<li>Run another container on the same network (e.g., <code>alpine</code>), install <code>curl</code>, and test the Nginx server:</li>
</ul>
</li>
</ol>
</details>
<hr />
<h2 id="part-5-data-persistence-with-a-volume"><a class="header" href="#part-5-data-persistence-with-a-volume"><strong>Part 5: Data Persistence with a volume</strong></a></h2>
<details>
<summary>Tasks</summary>
<ol>
<li>
<p><strong>Create a <code>site_save</code> volume</strong></p>
</li>
<li>
<p><strong>Stop the alpine container</strong></p>
</li>
<li>
<p><strong>Mount the volume on the container and connect it back to the network</strong></p>
<ul>
<li>The volume has to be named <code>site-volume</code></li>
<li>The volume has to be mounted on the location: <code>/site/backup</code> in the container</li>
</ul>
</li>
<li>
<p><strong>Retrieve the site index page</strong></p>
<ul>
<li>Run another curl request from the container but this time redirect the output to <code>/site/backup/index.html</code></li>
</ul>
</li>
<li>
<p><strong>Challenge:</strong></p>
<ul>
<li>Rerun the container but this time using the <code>site-volume</code> has a source for the site files instead of the <code>site_files</code> folder</li>
</ul>
</li>
</ol>
</details>
<details>
<summary>
<h2 id="part-6-using-compose"><a class="header" href="#part-6-using-compose"> <b>Part 6: Using compose</b> </a></h2>
</summary>
<p>This part is pretty straightforward, you have to use docker compose to automate the deployment of your server. Everything should be up and running when launching <code>docker compose up --build</code> from the terminal.</p>
<p>Beware, there are special instructions for this section :</p>
<ul>
<li>Your <code>nginx</code> docker image <strong>must</strong> be named <code>nginx</code></li>
<li>You have to put the site files in a volume named <code>site_files</code>, which <strong>has to</strong> be declared in the <code>compose.yaml</code> file</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-setting-up-an-nginx-reverse-proxy-with-a-backend-service"><a class="header" href="#exercise-setting-up-an-nginx-reverse-proxy-with-a-backend-service"><strong>Exercise: Setting Up an Nginx Reverse Proxy with a Backend Service</strong></a></h1>
<h2 id="scenario-1"><a class="header" href="#scenario-1"><strong>Scenario:</strong></a></h2>
<p>You are tasked with deploying a Dockerized setup where an Nginx server acts as a <strong>reverse proxy</strong>, routing requests to a backend Flask service. Both services must communicate over a custom Docker network.</p>
<p>This setup will:</p>
<ol>
<li>Use a <strong>custom bridge network</strong> to enable communication between the services.</li>
<li>Emphasize network configuration and communication troubleshooting.</li>
<li>Avoid databases and focus purely on inter-service communication.</li>
</ol>
<details>
<summary>
<h2 id="part-1-writing-the-backend-service"><a class="header" href="#part-1-writing-the-backend-service"> <b>Part 1: Writing the Backend Service</b> </a></h2>
</summary>
<ol>
<li>
<p><strong>Create the project structure for the backend service:</strong></p>
<pre><code>backend/
├── app.py
├── requirements.txt
└── Dockerfile
</code></pre>
</li>
<li>
<p><strong>Write <code>app.py</code>:</strong></p>
<pre><code class="language-python"> from flask import Flask

 app = Flask(__name__)

 @app.route("/")
 def hello_world():
     return "&lt;p&gt;Hello, World!&lt;/p&gt;"
</code></pre>
</li>
</ol>
<blockquote>
<p>💡 You will have to run the app with the command <code>flask run --host="0.0.0.0"</code></p>
</blockquote>
<ol start="3">
<li>
<p><strong>Write <code>requirements.txt</code>:</strong></p>
<pre><code class="language-plaintext">Flask
</code></pre>
</li>
<li>
<p><strong>Write the <code>Dockerfile</code>:</strong></p>
<ul>
<li>The resulting image should copy the application and its dependencies to the container and run the app listening on <code>127.0.0.1:5000</code></li>
</ul>
</li>
<li>
<p><strong>Test the backend locally:</strong></p>
<ul>
<li>Run the container with the good arguments so that you can access your backend by visiting <code>http://localhost:5000</code> in your favorite web browser.</li>
</ul>
</li>
</ol>
</details>
<details>
<summary>
<h2 id="part-2-writing-the-nginx-reverse-proxy"><a class="header" href="#part-2-writing-the-nginx-reverse-proxy"> <b>Part 2: Writing the Nginx Reverse Proxy</b> </a></h2>
</summary>
<ol>
<li>
<p><strong>Create the project structure for the Nginx service:</strong></p>
<pre><code>nginx/
├── nginx.conf
└── Dockerfile
</code></pre>
</li>
<li>
<p><strong>Write <code>nginx.conf</code>:</strong></p>
<pre><code class="language-nginx"> server {
     listen 80;

     location / {
         proxy_pass http://flask-container:5000;
     }
 }
</code></pre>
</li>
<li>
<p><strong>Write the <code>Dockerfile</code>:</strong></p>
<ul>
<li>The resulting image has to be called <code>nginx-proxy</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>💡 This time you have to replace the <code>default.conf</code> file's contents
in the <code>/etc/nginx/conf.d</code> directory with the contents of the <code>nginx.conf</code>
file above</p>
</blockquote>
<p><strong>Note:</strong> At this point, Nginx cannot connect to the backend because they are not yet on the same network. Thus, running a container should result in <code>nginx</code> exiting due to an <em>emerg</em> because it can't find the server it is supposed to send requests to.</p>
</details>
<details>
<summary>
<h2 id="part-3-setting-up-the-custom-network"><a class="header" href="#part-3-setting-up-the-custom-network"> <b>Part 3: Setting Up the Custom Network</b> </a></h2>
</summary>
<ol>
<li>
<p><strong>Create a custom network:</strong></p>
<ul>
<li>This network should be called <code>app-network</code></li>
</ul>
</li>
<li>
<p><strong>Run the backend container on the custom network:</strong></p>
<ul>
<li>The backend container has to be called <code>flask-container</code> <strong>on the network</strong>.</li>
</ul>
</li>
</ol>
<blockquote>
<p>💡 If you're stuck at this stage, visit the <a href="https://docs.docker.com/reference/cli/docker/container/run/#network">network</a> option of the <code>docker container run</code> command.</p>
</blockquote>
<ol start="3">
<li>
<p><strong>Run the Nginx container on the same network:</strong></p>
</li>
<li>
<p><strong>Test communication:</strong></p>
<ul>
<li>Visit <code>http://localhost:8080</code> in your browser. You should see the response <code>"Hello from the Flask backend!"</code> from the backend service, routed through Nginx.</li>
</ul>
</li>
<li>
<p><strong>Challenge:</strong></p>
<ul>
<li>Use an <code>alpine</code> container to manually test communication. At the end,
you should have 3 containers connected to the same network and should be able to run a <code>curl</code> command to retrieve the contents from the site but only communicating with the <code>nginx</code> container.</li>
</ul>
</li>
</ol>
</details>
<details>
<summary>
<h2 id="part-4-dependancies-between-containers"><a class="header" href="#part-4-dependancies-between-containers"> <b>Part 4: Dependancies between containers</b> </a></h2>
</summary>
<ol>
<li><strong>Stop one container and observe what happens</strong>
Try visiting <code>http://localhost:8080</code>. What error do you see?</li>
</ol>
<blockquote>
<p>Remember to gracefully stop the backend container</p>
</blockquote>
<ol start="2">
<li>
<p><strong>Restart the backend container and ensure Nginx reconnects</strong>
Verify the response is back online.</p>
</li>
<li>
<p><strong>Add a healthcheck to the nginx docker image</strong>
In your <a href="https://docs.docker.com/reference/dockerfile/#healthcheck">healthcheck</a> you should ensure that if the back end container goes down.
The nginx container reports an unhealthy state.</p>
</li>
<li>
<p><strong>Repeat the steps above</strong>
This time, you should see that when you disconnect the container, the nginx container should be reported as unhealthy after a short while.</p>
</li>
</ol>
</details>
<details>
<summary>
<h2 id="part-5-using-compose"><a class="header" href="#part-5-using-compose"> <b>Part 5: Using compose</b> </a></h2>
</summary>
<p>This part is pretty straightforward, you have to use docker compose to automate the deployment of your server. Everything should be up and running when launching <code>docker compose up --build</code> from the terminal.</p>
<p>Beware, there are special instructions for this section :</p>
<ul>
<li>Your <code>nginx</code> docker image <strong>must</strong> be named <code>nginx</code></li>
<li>Your <code>flask</code> docker image <strong>must</strong> be named <code>flask</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-minikube-tutorial"><a class="header" href="#hello-minikube-tutorial">Hello Minikube Tutorial</a></h1>
<p>This guide demonstrates how to deploy a simple application on Minikube and monitor its performance using built-in Kubernetes tools.</p>
<hr />
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Minikube and Kubectl installed.</li>
<li>Ensure Minikube is running: <code>minikube start</code>.</li>
</ul>
<hr />
<h2 id="step-1-deploy-and-expose-an-application"><a class="header" href="#step-1-deploy-and-expose-an-application">Step 1: Deploy and Expose an Application</a></h2>
<p>Deploy an application and expose it as a service:</p>
<pre><code class="language-bash">kubectl create deployment hello-minikube --image=nginx
kubectl expose deployment hello-minikube --type=NodePort --port=80
</code></pre>
<p>Verify resources:</p>
<pre><code class="language-bash">kubectl get deployments
kubectl get services
</code></pre>
<hr />
<h2 id="step-2-access-the-application"><a class="header" href="#step-2-access-the-application">Step 2: Access the Application</a></h2>
<p>Get the service URL:</p>
<pre><code class="language-bash">minikube service hello-minikube --url
</code></pre>
<p>Access it in your browser to verify it's working.</p>
<hr />
<h2 id="step-3-monitor-the-application"><a class="header" href="#step-3-monitor-the-application">Step 3: Monitor the Application</a></h2>
<h3 id="1-view-logs"><a class="header" href="#1-view-logs">1. View Logs</a></h3>
<p>Inspect logs for the application's pods:</p>
<pre><code class="language-bash">kubectl logs -l app=hello-minikube
</code></pre>
<h3 id="2-describe-resources"><a class="header" href="#2-describe-resources">2. Describe Resources</a></h3>
<p>Get detailed information about the deployment and pods:</p>
<ul>
<li>
<p><strong>Deployment:</strong></p>
<pre><code class="language-bash">kubectl describe deployment hello-minikube
</code></pre>
</li>
<li>
<p><strong>Pods:</strong></p>
<pre><code class="language-bash">kubectl describe pod &lt;pod-name&gt;
</code></pre>
</li>
</ul>
<h3 id="3-check-resource-usage-with-kubectl-top"><a class="header" href="#3-check-resource-usage-with-kubectl-top">3. Check Resource Usage with <code>kubectl top</code></a></h3>
<p>Ensure your cluster has metrics-server installed. If not, install it:</p>
<pre><code class="language-bash">minikube addons enable metrics-server
</code></pre>
<p>Then, check resource usage:</p>
<ul>
<li>
<p><strong>Pods:</strong></p>
<pre><code class="language-bash">kubectl top pod
</code></pre>
</li>
<li>
<p><strong>Nodes:</strong></p>
<pre><code class="language-bash">kubectl top nodes
</code></pre>
</li>
</ul>
<h3 id="4-access-the-kubernetes-dashboard"><a class="header" href="#4-access-the-kubernetes-dashboard">4. Access the Kubernetes Dashboard</a></h3>
<p>Enable and access the Kubernetes Dashboard for a graphical interface:</p>
<pre><code class="language-bash">minikube dashboard
</code></pre>
<p>This provides an overview of resource usage, workloads, and logs.</p>
<hr />
<h2 id="step-4-clean-up-resources"><a class="header" href="#step-4-clean-up-resources">Step 4: Clean Up Resources</a></h2>
<p>Once you're done, clean up:</p>
<ol>
<li>
<p><strong>Delete Resources:</strong></p>
<pre><code class="language-bash">kubectl delete service hello-minikube
kubectl delete deployment hello-minikube
</code></pre>
</li>
<li>
<p><strong>Stop Minikube:</strong></p>
<pre><code class="language-bash">minikube stop
</code></pre>
</li>
<li>
<p><strong>(Optional) Delete Minikube Cluster:</strong></p>
<pre><code class="language-bash">minikube delete
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-deploy-your-first-flask-app-with-kubernetes"><a class="header" href="#exercise-deploy-your-first-flask-app-with-kubernetes">Exercise: Deploy Your First Flask App with Kubernetes</a></h1>
<p><strong>Objective:</strong> Deploy a simple Flask web application on Kubernetes and make it accessible on port 8080 of your host machine.</p>
<hr />
<h2 id="setup-and-default-docker-compose-file"><a class="header" href="#setup-and-default-docker-compose-file"><strong>Setup and Default Docker-Compose File</strong></a></h2>
<p>You are provided a <code>docker-compose.yml</code> file for a simple Flask app:</p>
<pre><code class="language-yaml">version: '3.9'
services:
    app:
        image: myapp
        pull_policy: build
        build: ./myapp
        container_name: app_container
        ports:
          - "8080:80"
</code></pre>
<h3 id="flask-application-myappapppy"><a class="header" href="#flask-application-myappapppy">Flask Application (<code>myapp/app.py</code>)</a></h3>
<p>Here is the Python script for the Flask app:</p>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Kubernetes!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<h3 id="dockerfile-myappdockerfile"><a class="header" href="#dockerfile-myappdockerfile">Dockerfile (<code>myapp/Dockerfile</code>)</a></h3>
<p>Here is the Dockerfile for building the Flask app:</p>
<pre><code class="language-dockerfile"># Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory
WORKDIR /app

# Copy the current directory contents into the container
COPY . /app

# Install the required packages
RUN pip install flask

# Make port 80 available to the world outside the container
EXPOSE 80

# Define environment variable
ENV FLASK_APP=app.py

# Run the application
CMD ["python", "app.py"]
</code></pre>
<hr />
<h2 id="your-task-deploy-the-flask-app-to-kubernetes"><a class="header" href="#your-task-deploy-the-flask-app-to-kubernetes"><strong>Your Task: Deploy the Flask App to Kubernetes</strong></a></h2>
<h3 id="step-1-create-kubernetes-deployment-and-service-manifests"><a class="header" href="#step-1-create-kubernetes-deployment-and-service-manifests">Step 1: Create Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> and <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> Manifests</a></h3>
<ol>
<li>
<p>Create a <code>deployment.yaml</code> file for the app deployment:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-app
        image: myapp:latest
        ports:
        - containerPort: 80
</code></pre>
</li>
<li>
<p>Create a <code>service.yaml</code> file to expose the deployment:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  selector:
    app: flask-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: NodePort
</code></pre>
</li>
</ol>
<hr />
<h4 id="step-2-build-and-push-the-docker-image"><a class="header" href="#step-2-build-and-push-the-docker-image">Step 2: Build and Push the Docker Image</a></h4>
<ol>
<li>
<p>Build the Docker image:</p>
<pre><code class="language-bash">docker build -t myapp:latest ./myapp
</code></pre>
</li>
<li>
<p>Load the image into your local Kubernetes cluster (e.g., Minikube or Docker Desktop):</p>
<pre><code class="language-bash"># For Minikube
minikube image load myapp:latest
</code></pre>
</li>
</ol>
<hr />
<h4 id="step-3-apply-the-kubernetes-manifests"><a class="header" href="#step-3-apply-the-kubernetes-manifests">Step 3: Apply the Kubernetes Manifests</a></h4>
<ol>
<li>
<p>Apply the deployment manifest:</p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml
</code></pre>
</li>
<li>
<p>Apply the service manifest:</p>
<pre><code class="language-bash">kubectl apply -f service.yaml
</code></pre>
</li>
</ol>
<hr />
<h4 id="step-4-access-your-application"><a class="header" href="#step-4-access-your-application">Step 4: Access Your Application</a></h4>
<ol>
<li>
<p>Get the NodePort assigned by Kubernetes:</p>
<pre><code class="language-bash">kubectl get service flask-service
</code></pre>
<p>Look for the <code>NodePort</code> in the output.</p>
</li>
<li>
<p>Access the application in your browser:</p>
<pre><code>http://&lt;your-cluster-ip&gt;:&lt;nodeport&gt;
</code></pre>
<p>If you're using Minikube, get the cluster IP:</p>
<pre><code class="language-bash">minikube ip
</code></pre>
<p>Combine the Minikube IP and the NodePort to access the app.</p>
</li>
</ol>
<h2 id="explanation-of-kubernetes-deployment-files"><a class="header" href="#explanation-of-kubernetes-deployment-files"><strong>Explanation of Kubernetes Deployment Files</strong></a></h2>
<p>The <code>deployment.yaml</code> and <code>service.yaml</code> files are the Kubernetes equivalents of the <code>docker-compose.yaml</code> file. They define how the application should be deployed and exposed in the Kubernetes cluster. Let's break them down.</p>
<hr />
<h3 id="1-docker-compose-vs-kubernetes-deployment"><a class="header" href="#1-docker-compose-vs-kubernetes-deployment"><strong>1. Docker-Compose vs. Kubernetes Deployment</strong></a></h3>
<h4 id="docker-compose-composeyaml"><a class="header" href="#docker-compose-composeyaml">Docker-Compose (<code>compose.yaml</code>):</a></h4>
<pre><code class="language-yaml">version: '3.9'
services:
    app:
        image: myapp
        pull_policy: build
        build: ./myapp
        container_name: app_container
        ports:
          - "8080:80"
</code></pre>
<ul>
<li><strong><code>services</code></strong>: Defines a single service (<code>app</code>) to be run.</li>
<li><strong><code>image</code></strong>: Specifies the Docker image (<code>myapp</code>) to use for the service.</li>
<li><strong><code>build</code></strong>: Specifies the context for building the Docker image.</li>
<li><strong><code>ports</code></strong>: Maps the container's internal port (80) to the host's port (8080).</li>
</ul>
<p>In Kubernetes, similar functionality is split across <strong>Deployment</strong> (defining the application) and <strong>Service</strong> (exposing it to the network).</p>
<hr />
<h3 id="2-kubernetes-deployment-file"><a class="header" href="#2-kubernetes-deployment-file"><strong>2. Kubernetes Deployment File</strong></a></h3>
<h4 id="deployment-deploymentyaml"><a class="header" href="#deployment-deploymentyaml">Deployment (<code>deployment.yaml</code>):</a></h4>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-app
        image: myapp:latest
        ports:
        - containerPort: 80
</code></pre>
<p><strong>Key Sections Explained:</strong></p>
<ol>
<li><strong><code>apiVersion</code></strong>: Specifies the API version of the resource (here, <code>apps/v1</code> for Deployments).</li>
<li><strong><code>kind</code></strong>: Indicates the type of resource (a <code>Deployment</code> in this case).</li>
<li><strong><code>metadata</code></strong>: Includes metadata like the name of the deployment (<code>flask-app</code>).</li>
<li><strong><code>spec</code></strong>: Contains the desired state of the Deployment:
<ul>
<li><strong><code>replicas</code></strong>: Number of instances (pods) to run (equivalent to scaling in Compose).</li>
<li><strong><code>selector</code></strong>: Identifies pods managed by the Deployment using labels.</li>
<li><strong><code>template</code></strong>:
<ul>
<li><strong><code>metadata</code></strong>: Labels assigned to the pods created by this template.</li>
<li><strong><code>spec</code></strong>:
<ul>
<li><strong><code>containers</code></strong>: Defines the container for the app:
<ul>
<li><strong><code>name</code></strong>: A name for the container.</li>
<li><strong><code>image</code></strong>: Docker image to use (like the <code>image</code> key in Compose).</li>
<li><strong><code>ports</code></strong>: Internal ports exposed by the container (like Compose's <code>ports</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Correspondence to Docker-Compose:</strong></p>
<ul>
<li><strong><code>image</code></strong>: Matches <code>image: myapp</code>.</li>
<li><strong><code>ports.containerPort</code></strong>: Matches the container's internal port (80).</li>
<li><strong>Scaling</strong>: The <code>replicas: 2</code> allows scaling, similar to defining multiple replicas in Compose's <code>deploy</code> section.</li>
</ul>
<hr />
<h3 id="3-kubernetes-service-file"><a class="header" href="#3-kubernetes-service-file"><strong>3. Kubernetes Service File</strong></a></h3>
<h4 id="service-serviceyaml"><a class="header" href="#service-serviceyaml">Service (<code>service.yaml</code>):</a></h4>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  selector:
    app: flask-app
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 80
  type: NodePort
</code></pre>
<p><strong>Key Sections Explained:</strong></p>
<ol>
<li><strong><code>apiVersion</code></strong>: Specifies the API version of the resource (here, <code>v1</code> for Services).</li>
<li><strong><code>kind</code></strong>: Indicates the type of resource (a <code>Service</code> in this case).</li>
<li><strong><code>metadata</code></strong>: Includes metadata like the name of the service (<code>flask-service</code>).</li>
<li><strong><code>spec</code></strong>: Contains the configuration of the Service:
<ul>
<li><strong><code>selector</code></strong>: Links the service to the pods labeled with <code>app: flask-app</code> (defined in <code>deployment.yaml</code>).</li>
<li><strong><code>ports</code></strong>: Defines the mapping between the service port and the target container port:
<ul>
<li><strong><code>port</code></strong>: Port exposed by the Service (8080).</li>
<li><strong><code>targetPort</code></strong>: Port on the container (80).</li>
</ul>
</li>
<li><strong><code>type</code></strong>: Specifies how the service is exposed. <code>NodePort</code> exposes it on a random high port on all nodes.</li>
</ul>
</li>
</ol>
<p><strong>Correspondence to Docker-Compose:</strong></p>
<ul>
<li><strong><code>ports</code></strong>: The <code>NodePort</code> service type maps container port 80 to a port accessible on the host. In Compose, this is equivalent to <code>"8080:80"</code>.</li>
<li><strong><code>selector</code></strong>: Ensures the Service targets only the pods associated with the Deployment.</li>
</ul>
<hr />
<h3 id="mapping-between-compose-and-kubernetes"><a class="header" href="#mapping-between-compose-and-kubernetes"><strong>Mapping Between Compose and Kubernetes</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Compose Feature</strong></th><th><strong>Kubernetes Deployment</strong></th><th><strong>Kubernetes Service</strong></th></tr></thead><tbody>
<tr><td><code>services.app.image</code></td><td><code>spec.template.spec.containers.image</code></td><td>Not needed in the Service.</td></tr>
<tr><td><code>ports</code></td><td><code>spec.template.spec.containers.ports</code></td><td><code>spec.ports</code> for host-to-pod mapping</td></tr>
<tr><td><code>container_name</code></td><td>Not directly used; pods get generated names.</td><td>Not applicable.</td></tr>
<tr><td><code>build</code></td><td>Image must already be built; <code>docker build</code> step required beforehand.</td><td>Not applicable.</td></tr>
<tr><td>Scaling (<code>replicas</code>)</td><td><code>spec.replicas</code> in Deployment.</td><td>Not applicable.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="summary"><a class="header" href="#summary"><strong>Summary</strong></a></h3>
<ul>
<li><strong>Deployment</strong>: Defines the application container (like <code>services</code> in Compose).</li>
<li><strong>Service</strong>: Exposes the application to the outside world (like <code>ports</code> in Compose).</li>
<li>The <code>docker-compose.yml</code> is simpler but limited to single-host setups, whereas Kubernetes provides flexibility and scalability for production-grade deployments.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-implement-persistent-storage-with-kubernetes"><a class="header" href="#tutorial-implement-persistent-storage-with-kubernetes"><strong>Tutorial: Implement Persistent Storage with Kubernetes</strong></a></h1>
<p><strong>Objective:</strong><br />
Deploy a Flask application using Kubernetes with a focus on persistent storage. The app will log messages to a file stored in a Persistent Volume (PV), ensuring logs persist even if the container restarts.</p>
<hr />
<h2 id="starting-point-docker-compose-file"><a class="header" href="#starting-point-docker-compose-file"><strong>Starting Point: Docker Compose File</strong></a></h2>
<p>You are provided the following <code>docker-compose.yaml</code> file:</p>
<pre><code class="language-yaml">version: '3.9'
services:
  app:
    image: myapp
    pull_policy: build
    build: ./myapp
    container_name: app_container
    volumes:
      - ./logs:/data
    ports:
      - "8080:80"
</code></pre>
<p>This Docker Compose file:</p>
<ul>
<li>Defines a Flask app (<code>myapp</code>) container.</li>
<li>Mounts a <code>logs</code> directory from the host to the container's <code>/data</code> directory for persistent storage.</li>
<li>Exposes the app on port <code>8080</code> of the host machine.</li>
</ul>
<hr />
<h2 id="step-by-step-kubernetes-implementation"><a class="header" href="#step-by-step-kubernetes-implementation"><strong>Step-by-Step Kubernetes Implementation</strong></a></h2>
<p>You will recreate this setup in Kubernetes by defining a Deployment, Service, Persistent Volume (PV), and Persistent Volume Claim (PVC).</p>
<hr />
<h3 id="1-flask-application-code"><a class="header" href="#1-flask-application-code"><strong>1. Flask Application Code</strong></a></h3>
<p>Here’s the Flask app that logs messages to a file in the persistent volume:</p>
<p><strong>File: <code>myapp/app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask, request

app = Flask(__name__)

LOG_FILE = "/data/logs.txt"

@app.route("/")
def home():
    return "Welcome to the Flask app with Persistent Storage!"

@app.route("/write", methods=["POST"])
def write_log():
    message = request.json.get("message", "No message provided")
    with open(LOG_FILE, "a") as log:
        log.write(message + "\n")
    return f"Logged: {message}", 200

@app.route("/read", methods=["GET"])
def read_log():
    try:
        with open(LOG_FILE, "r") as log:
            return "&lt;pre&gt;" + log.read() + "&lt;/pre&gt;", 200
    except FileNotFoundError:
        return "No logs found!", 404

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<hr />
<h3 id="2-dockerfile"><a class="header" href="#2-dockerfile"><strong>2. Dockerfile</strong></a></h3>
<p>Build the Flask app using this Dockerfile:</p>
<p><strong>File: <code>myapp/Dockerfile</code></strong></p>
<pre><code class="language-dockerfile"># Use a lightweight Python image
FROM python:3.9-slim

WORKDIR /app

COPY . /app

RUN pip install flask

EXPOSE 80

CMD ["python", "app.py"]
</code></pre>
<hr />
<h3 id="3-kubernetes-manifests"><a class="header" href="#3-kubernetes-manifests"><strong>3. Kubernetes Manifests</strong></a></h3>
<p><strong>a) Persistent Volume and Claim</strong></p>
<p>Create a Persistent Volume (PV) and Persistent Volume Claim (PVC) to store logs:</p>
<p><strong>File: <code>pv.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: flask-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /tmp/flask-logs
</code></pre>
<p><strong>File: <code>pvc.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: flask-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
</code></pre>
<hr />
<p><strong>b) Deployment</strong></p>
<p>Define the Deployment to mount the PVC as a volume:</p>
<p><strong>File: <code>deployment.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-app
        image: myapp:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: /data
          name: log-volume
      volumes:
      - name: log-volume
        persistentVolumeClaim:
          claimName: flask-pvc
</code></pre>
<hr />
<p><strong>c) Service</strong></p>
<p>Expose the Flask app with a Kubernetes Service:</p>
<p><strong>File: <code>service.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  selector:
    app: flask-app
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 80
  type: NodePort
</code></pre>
<hr />
<h3 id="deployment-steps"><a class="header" href="#deployment-steps"><strong>Deployment Steps</strong></a></h3>
<ol>
<li>
<p><strong>Build and Load the Docker Image:</strong></p>
<pre><code class="language-bash">docker build -t myapp:latest ./myapp
minikube image load myapp:latest  # For Minikube
</code></pre>
</li>
<li>
<p><strong>Apply the PV and PVC:</strong></p>
<pre><code class="language-bash">kubectl apply -f pv.yaml
kubectl apply -f pvc.yaml
</code></pre>
</li>
<li>
<p><strong>Deploy the Application:</strong></p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
</code></pre>
</li>
<li>
<p><strong>Access the Application:</strong></p>
<ul>
<li>Get the NodePort of the Service:
<pre><code class="language-bash">kubectl get service flask-service
</code></pre>
</li>
<li>Access the app at <code>http://&lt;minikube-ip&gt;:&lt;node-port&gt;</code>, or <code>localhost</code> if you're using Docker Desktop.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="testing"><a class="header" href="#testing"><strong>Testing</strong></a></h2>
<ol>
<li>
<p><strong>Write Logs:</strong>
Use the <code>/write</code> endpoint to log messages:</p>
<pre><code class="language-bash">curl -X POST http://&lt;service-ip&gt;:&lt;node-port&gt;/write \
     -H "Content-Type: application/json" \
     -d '{"message": "Hello, Persistent Storage!"}'
</code></pre>
</li>
<li>
<p><strong>Read Logs:</strong>
Access the <code>/read</code> endpoint to view the logs:</p>
<pre><code class="language-bash">curl http://&lt;service-ip&gt;:&lt;node-port&gt;/read
</code></pre>
</li>
<li>
<p><strong>Verify Logs on the Host:</strong>
If using <code>hostPath</code>, check the logs directly on the Kubernetes node:</p>
<pre><code class="language-bash">cat /tmp/flask-logs/logs.txt
</code></pre>
</li>
</ol>
<hr />
<h2 id="deliverables"><a class="header" href="#deliverables"><strong>Deliverables</strong></a></h2>
<p>By completing this exercise, you will:</p>
<ol>
<li>Deploy a Flask application using Kubernetes.</li>
<li>Configure persistent storage with a Persistent Volume (PV) and Persistent Volume Claim (PVC).</li>
<li>Write logs to a file in the persistent volume and access them via an API and directly on the host.</li>
</ol>
<h2 id="what-are-persistent-volumes-pv-and-persistent-volume-claims-pvc"><a class="header" href="#what-are-persistent-volumes-pv-and-persistent-volume-claims-pvc"><strong>What are Persistent Volumes (PV) and Persistent Volume Claims (PVC)?</strong></a></h2>
<p>Persistent Volumes (PV) and Persistent Volume Claims (PVC) are Kubernetes resources used to manage <strong>persistent storage</strong> for applications. They allow data to persist even if a pod is deleted, rescheduled, or restarted.</p>
<hr />
<h3 id="persistent-volume-pv"><a class="header" href="#persistent-volume-pv"><strong>Persistent Volume (PV)</strong></a></h3>
<h4 id="what-is-a-persistent-volume"><a class="header" href="#what-is-a-persistent-volume">What is a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volume</a>?</a></h4>
<p>A Persistent Volume (PV) is a <strong>cluster-wide storage resource</strong> that provides storage for pods. It is an abstraction of physical storage (e.g., disk, network file system, cloud storage). The PV is managed by the cluster administrator and remains independent of individual pods.</p>
<ul>
<li><strong>Key Features of PV</strong>:
<ul>
<li>Abstracts storage from the underlying implementation (local disk, NFS, cloud storage).</li>
<li>Managed by the Kubernetes storage subsystem.</li>
<li>Can have different access modes to define how the volume is shared between pods.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="components-of-a-pv-manifest"><a class="header" href="#components-of-a-pv-manifest"><strong>Components of a PV Manifest</strong></a></h3>
<p>Here's a breakdown of the <code>pv.yaml</code> file from our example:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: flask-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /tmp/flask-logs
</code></pre>
<p><strong>1. <code>apiVersion</code> and <code>kind</code>:</strong></p>
<ul>
<li><strong><code>apiVersion: v1</code></strong>: Specifies the version of the Kubernetes API used.</li>
<li><strong><code>kind: PersistentVolume</code></strong>: Indicates that this is a Persistent Volume resource.</li>
</ul>
<p><strong>2. <code>metadata</code>:</strong></p>
<ul>
<li><strong><code>name</code></strong>: A unique name for the Persistent Volume (<code>flask-pv</code>).</li>
</ul>
<p><strong>3. <code>spec</code>:</strong></p>
<ul>
<li><strong><code>capacity</code></strong>: Specifies the storage capacity of the volume. In this case, the volume has <code>1Gi</code> (1 GiB) of storage.</li>
<li><strong><code>accessModes</code></strong>:
<ul>
<li>Defines how the volume can be accessed by pods. Common values:
<ul>
<li><strong><code>ReadWriteOnce (RWO)</code></strong>: Only one pod can mount the volume in read-write mode at a time.</li>
<li><strong><code>ReadOnlyMany (ROX)</code></strong>: Multiple pods can mount the volume in read-only mode.</li>
<li><strong><code>ReadWriteMany (RWX)</code></strong>: Multiple pods can mount the volume in read-write mode.</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>hostPath</code></strong>: Specifies the storage backend for the PV. In this case, the <code>hostPath</code> points to a directory on the host (<code>/tmp/flask-logs</code>). Other options include NFS, AWS EBS, GCP Disks, etc.</li>
</ul>
<hr />
<h3 id="persistent-volume-claim-pvc"><a class="header" href="#persistent-volume-claim-pvc"><strong>Persistent Volume Claim (PVC)</strong></a></h3>
<h4 id="what-is-a-persistent-volume-claim"><a class="header" href="#what-is-a-persistent-volume-claim">What is a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volume Claim</a>?</a></h4>
<p>A Persistent Volume Claim (PVC) is a <strong>request for storage by a pod</strong>. It is similar to a "claim ticket" that requests storage from available Persistent Volumes. A PVC defines how much storage is required and the access mode. Once bound to a PV, the PVC gives pods access to the underlying storage.</p>
<ul>
<li><strong>Key Features of PVC</strong>:
<ul>
<li>Decouples pod specifications from storage details.</li>
<li>Dynamically or statically binds to a PV based on matching requirements (capacity, access modes).</li>
<li>Ensures a pod always gets the requested storage, regardless of scheduling.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="components-of-a-pvc-manifest"><a class="header" href="#components-of-a-pvc-manifest"><strong>Components of a PVC Manifest</strong></a></h3>
<p>Here's a breakdown of the <code>pvc.yaml</code> file from our example:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: flask-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
</code></pre>
<p><strong>1. <code>apiVersion</code> and <code>kind</code>:</strong></p>
<ul>
<li><strong><code>apiVersion: v1</code></strong>: Specifies the version of the Kubernetes API used.</li>
<li><strong><code>kind: PersistentVolumeClaim</code></strong>: Indicates that this is a Persistent Volume Claim resource.</li>
</ul>
<p><strong>2. <code>metadata</code>:</strong></p>
<ul>
<li><strong><code>name</code></strong>: A unique name for the Persistent Volume Claim (<code>flask-pvc</code>).</li>
</ul>
<p><strong>3. <code>spec</code>:</strong></p>
<ul>
<li><strong><code>accessModes</code></strong>:
<ul>
<li>Matches the access modes of the PV. In this case, <code>ReadWriteOnce</code> allows one pod to mount the volume in read-write mode.</li>
</ul>
</li>
<li><strong><code>resources</code></strong>:
<ul>
<li><strong><code>requests</code></strong>:
<ul>
<li>Specifies the amount of storage the pod requires (<code>500Mi</code> in this case).</li>
</ul>
</li>
</ul>
</li>
<li>The PVC will bind to any PV that meets its requirements for capacity and access modes.</li>
</ul>
<hr />
<h3 id="how-pv-and-pvc-work-together"><a class="header" href="#how-pv-and-pvc-work-together"><strong>How PV and PVC Work Together</strong></a></h3>
<ol>
<li>
<p><strong>PV Creation</strong>:</p>
<ul>
<li>The cluster administrator creates Persistent Volumes to represent storage resources.</li>
</ul>
</li>
<li>
<p><strong>PVC Creation</strong>:</p>
<ul>
<li>A developer creates a Persistent Volume Claim to request storage. The PVC specifies the required storage size and access mode.</li>
</ul>
</li>
<li>
<p><strong>Binding</strong>:</p>
<ul>
<li>Kubernetes automatically finds a matching PV for the PVC based on the <code>accessModes</code> and <code>storage</code> requirements. If no matching PV is available, the PVC remains unbound until one becomes available.</li>
</ul>
</li>
<li>
<p><strong>Pod Access</strong>:</p>
<ul>
<li>Pods use the PVC to access the bound PV. The PVC is mounted as a volume in the pod's container.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="binding-workflow"><a class="header" href="#binding-workflow"><strong>Binding Workflow</strong></a></h3>
<ol>
<li>Administrator creates a PV (<code>flask-pv</code>) with <code>1Gi</code> capacity and <code>ReadWriteOnce</code> access mode.</li>
<li>Developer creates a PVC (<code>flask-pvc</code>) requesting <code>500Mi</code> and <code>ReadWriteOnce</code>.</li>
<li>Kubernetes matches the PVC with the PV because:
<ul>
<li>The requested storage (<code>500Mi</code>) is less than or equal to the PV's capacity (<code>1Gi</code>).</li>
<li>The access modes (<code>ReadWriteOnce</code>) match.</li>
</ul>
</li>
<li>The PVC binds to the PV, and the pod can now use the storage.</li>
</ol>
<hr />
<h3 id="why-use-pvcs"><a class="header" href="#why-use-pvcs"><strong>Why Use PVCs?</strong></a></h3>
<ul>
<li><strong>Separation of Concerns</strong>:
<ul>
<li>Developers don’t need to know storage details (e.g., NFS paths, cloud disks). They just request storage.</li>
<li>Administrators manage storage and PV provisioning.</li>
</ul>
</li>
<li><strong>Dynamic Storage Provisioning</strong>:
<ul>
<li>In some environments (e.g., AWS, GCP), PVCs can dynamically provision storage (e.g., create a new EBS volume).</li>
</ul>
</li>
<li><strong>Portability</strong>:
<ul>
<li>Applications can move across clusters without needing to know storage specifics.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="using-pv-and-pvc-in-pods"><a class="header" href="#using-pv-and-pvc-in-pods"><strong>Using PV and PVC in Pods</strong></a></h3>
<p>In our example, the Deployment mounts the PVC using the following configuration:</p>
<pre><code class="language-yaml">spec:
  volumes:
  - name: log-volume
    persistentVolumeClaim:
      claimName: flask-pvc
  containers:
  - name: flask-app
    volumeMounts:
    - mountPath: /data
      name: log-volume
</code></pre>
<ul>
<li><strong><code>volumes</code></strong>:
<ul>
<li>References the <code>flask-pvc</code> PVC. The PVC provides the storage from the bound PV.</li>
</ul>
</li>
<li><strong><code>volumeMounts</code></strong>:
<ul>
<li>Mounts the volume (<code>log-volume</code>) into the container at <code>/data</code>. This means all files written to <code>/data</code> in the container are stored in the PV.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="key-takeaways"><a class="header" href="#key-takeaways"><strong>Key Takeaways</strong></a></h3>
<ul>
<li><strong>PV</strong>:
<ul>
<li>Represents the physical storage resource.</li>
<li>Created and managed by the cluster administrator.</li>
</ul>
</li>
<li><strong>PVC</strong>:
<ul>
<li>A developer’s request for storage.</li>
<li>Automatically binds to a matching PV.</li>
</ul>
</li>
<li><strong>Together</strong>:
<ul>
<li>PVC decouples storage provisioning from application deployment, simplifying storage management.</li>
<li>PV ensures data persistence beyond the lifecycle of pods.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-container-networking-in-kubernetes"><a class="header" href="#tutorial-container-networking-in-kubernetes"><strong>Tutorial: Container Networking in Kubernetes</strong></a></h1>
<p><strong>Objective</strong>:<br />
Learn how to create and configure a network in Kubernetes to connect three containers (services) such that they can communicate with each other.</p>
<hr />
<h3 id="scenario-2"><a class="header" href="#scenario-2"><strong>Scenario</strong></a></h3>
<p>We will deploy three services in Kubernetes:</p>
<ol>
<li><strong>Backend Service</strong>: A Python Flask app that provides a "Hello, Kubernetes!" message at <code>/</code>.</li>
<li><strong>Processor Service</strong>: Another Python Flask app that fetches the backend service's message and processes it.</li>
<li><strong>Frontend Service</strong>: A Python Flask app that fetches and displays the processed message from the processor service.</li>
</ol>
<p>The three services will communicate internally using Kubernetes networking and <strong>ClusterIP Services</strong>.</p>
<hr />
<h2 id="step-1-backend-service"><a class="header" href="#step-1-backend-service"><strong>Step 1: Backend Service</strong></a></h2>
<p><strong>1. Backend App Code</strong></p>
<p><strong>File: <code>backend/app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route("/")
def backend():
    return "Hello, Kubernetes!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
</code></pre>
<p><strong>2. Dockerfile</strong></p>
<p><strong>File: <code>backend/Dockerfile</code></strong></p>
<pre><code class="language-dockerfile">FROM python:3.9-slim

WORKDIR /app
COPY . /app

RUN pip install flask

EXPOSE 5000

CMD ["python", "app.py"]
</code></pre>
<p><strong>3. Deployment and Service</strong></p>
<p><strong>File: <code>backend-deployment.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: backend:latest
        ports:
        - containerPort: 5000
</code></pre>
<p><strong>File: <code>backend-service.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 5000
    targetPort: 5000
  type: ClusterIP
</code></pre>
<hr />
<h2 id="step-2-processor-service"><a class="header" href="#step-2-processor-service"><strong>Step 2: Processor Service</strong></a></h2>
<p><strong>1. Processor App Code</strong></p>
<p><strong>File: <code>processor/app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask
import requests

app = Flask(__name__)

BACKEND_URL = "http://backend-service:5000/"

@app.route("/")
def processor():
    try:
        response = requests.get(BACKEND_URL)
        return f"Processed Message: {response.text.upper()}"
    except Exception as e:
        return f"Error connecting to Backend: {str(e)}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
</code></pre>
<p><strong>2. Dockerfile</strong></p>
<p><strong>File: <code>processor/Dockerfile</code></strong></p>
<pre><code class="language-dockerfile">FROM python:3.9-slim

WORKDIR /app
COPY . /app

RUN pip install flask requests

EXPOSE 5000

CMD ["python", "app.py"]
</code></pre>
<p><strong>3. Deployment and Service</strong></p>
<p><strong>File: <code>processor-deployment.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: processor
spec:
  replicas: 1
  selector:
    matchLabels:
      app: processor
  template:
    metadata:
      labels:
        app: processor
    spec:
      containers:
      - name: processor
        image: processor:latest
        ports:
        - containerPort: 5000
</code></pre>
<p><strong>File: <code>processor-service.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: processor-service
spec:
  selector:
    app: processor
  ports:
  - protocol: TCP
    port: 5000
    targetPort: 5000
  type: ClusterIP
</code></pre>
<hr />
<h2 id="step-3-frontend-service"><a class="header" href="#step-3-frontend-service"><strong>Step 3: Frontend Service</strong></a></h2>
<p><strong>1. Frontend App Code</strong></p>
<p><strong>File: <code>frontend/app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask
import requests

app = Flask(__name__)

PROCESSOR_URL = "http://processor-service:5000/"

@app.route("/")
def frontend():
    try:
        response = requests.get(PROCESSOR_URL)
        return f"Frontend Display: {response.text}"
    except Exception as e:
        return f"Error connecting to Processor: {str(e)}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
</code></pre>
<p><strong>2. Dockerfile</strong></p>
<p><strong>File: <code>frontend/Dockerfile</code></strong></p>
<pre><code class="language-dockerfile">FROM python:3.9-slim

WORKDIR /app
COPY . /app

RUN pip install flask requests

EXPOSE 5000

CMD ["python", "app.py"]
</code></pre>
<p><strong>3. Deployment and Service</strong></p>
<p><strong>File: <code>frontend-deployment.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: frontend:latest
        ports:
        - containerPort: 5000
</code></pre>
<p><strong>File: <code>frontend-service.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 5000
  type: NodePort
</code></pre>
<hr />
<h2 id="step-4-build-deploy-and-test"><a class="header" href="#step-4-build-deploy-and-test"><strong>Step 4: Build, Deploy, and Test</strong></a></h2>
<ol>
<li>
<p><strong>Build the Docker Images</strong>:</p>
<pre><code class="language-bash">docker build -t backend:latest ./backend
docker build -t processor:latest ./processor
docker build -t frontend:latest ./frontend
</code></pre>
</li>
<li>
<p><strong>Load the Docker Images into Minikube</strong>:</p>
<pre><code class="language-bash">minikube image load backend:latest
minikube image load processor:latest
minikube image load frontend:latest
</code></pre>
</li>
<li>
<p><strong>Apply the Kubernetes Manifests</strong>:</p>
<pre><code class="language-bash">kubectl apply -f backend-deployment.yaml
kubectl apply -f backend-service.yaml
kubectl apply -f processor-deployment.yaml
kubectl apply -f processor-service.yaml
kubectl apply -f frontend-deployment.yaml
kubectl apply -f frontend-service.yaml
</code></pre>
</li>
<li>
<p><strong>Test the Setup</strong>:</p>
<ul>
<li>Get the <code>NodePort</code> of the <code>frontend-service</code>:
<pre><code class="language-bash">kubectl get service frontend-service
</code></pre>
</li>
<li>Access the frontend service in your browser:
<pre><code>http://&lt;minikube-ip&gt;:&lt;node-port&gt;
</code></pre>
</li>
<li>The frontend should display the processed message from the backend.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="what-you-learned"><a class="header" href="#what-you-learned"><strong>What You Learned</strong></a></h2>
<ol>
<li>
<p><strong>ClusterIP Services</strong>:</p>
<ul>
<li>Internal services to facilitate communication between pods.</li>
</ul>
</li>
<li>
<p><strong>Service Discovery</strong>:</p>
<ul>
<li>Using DNS names (<code>backend-service</code>, <code>processor-service</code>) to allow pods to discover and communicate with each other.</li>
</ul>
</li>
<li>
<p><strong>Pod-to-Pod Networking</strong>:</p>
<ul>
<li>Seamless networking enabled by Kubernetes' flat networking model.</li>
</ul>
</li>
<li>
<p><strong>NodePort Service</strong>:</p>
<ul>
<li>Exposing the frontend service to allow external access.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-scaling-and-rolling-updates-in-kubernetes"><a class="header" href="#exercise-scaling-and-rolling-updates-in-kubernetes"><strong>Exercise: Scaling and Rolling Updates in Kubernetes</strong></a></h1>
<p>In this exercise, you will deploy a scalable Flask web application on Kubernetes. You will:</p>
<ol>
<li>Implement manual and automatic scaling.</li>
<li>Perform a rolling update to demonstrate zero-downtime deployment.</li>
<li>Test your application under load using a load-testing tool.</li>
</ol>
<hr />
<h2 id="provided-files"><a class="header" href="#provided-files"><strong>Provided Files</strong></a></h2>
<h3 id="1-application-code"><a class="header" href="#1-application-code"><strong>1. Application Code</strong></a></h3>
<p><strong>File: <code>app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask, request
import os

app = Flask(__name__)
counter = 0

@app.route("/")
def home():
    global counter
    counter += 1
    hostname = os.environ.get("HOSTNAME", "unknown")
    return f"Hello from {hostname}! I've handled {counter} requests.\n"

@app.route("/cpu")
def cpu_intensive():
    # Simulate CPU load
    x = 0
    for i in range(10000000):
        x += i
    return "CPU load generated!\n"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<hr />
<h2 id="step-1-containerize-the-application"><a class="header" href="#step-1-containerize-the-application"><strong>Step 1: Containerize the Application</strong></a></h2>
<p><strong>Task</strong>:</p>
<ul>
<li>Write a <code>Dockerfile</code> to containerize the <code>app.py</code> application.</li>
<li>Use a lightweight Python base image (e.g., <code>python:3.9-slim</code>).</li>
<li>Build the Docker image and push it to a registry or use it locally.</li>
</ul>
<p><strong>Example Dockerfile</strong>:</p>
<pre><code class="language-dockerfile">FROM python:3.9-slim

WORKDIR /app
COPY app.py /app

RUN pip install flask

EXPOSE 80

CMD ["python", "app.py"]
</code></pre>
<p><strong>Commands</strong>:</p>
<ol>
<li>Build the Docker image:
<pre><code class="language-bash">docker build -t flask-app:v1 .
</code></pre>
</li>
<li>Push the image to a container registry (if using one):
<pre><code class="language-bash">docker tag flask-app:v1 &lt;your-registry&gt;/flask-app:v1
docker push &lt;your-registry&gt;/flask-app:v1
</code></pre>
</li>
</ol>
<hr />
<h2 id="step-2-deploy-the-application-to-kubernetes"><a class="header" href="#step-2-deploy-the-application-to-kubernetes"><strong>Step 2: Deploy the Application to Kubernetes</strong></a></h2>
<h3 id="1-deployment"><a class="header" href="#1-deployment"><strong>1. Deployment</strong></a></h3>
<p>Write a <code>deployment.yaml</code> file to deploy the application with:</p>
<ul>
<li>Initial replicas set to <code>1</code>.</li>
<li>Pod labels for service discovery.</li>
<li>Image tag <code>v1</code>.</li>
</ul>
<p><strong>Example <code>deployment.yaml</code></strong>:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-container
        image: flask-app:v1
        ports:
        - containerPort: 80
</code></pre>
<hr />
<h3 id="2-service"><a class="header" href="#2-service"><strong>2. Service</strong></a></h3>
<p>Write a <code>service.yaml</code> file to expose the application via <code>NodePort</code>:</p>
<ul>
<li>Use port <code>80</code> internally.</li>
<li>Map it to a high port (e.g., <code>30000-32767</code>) for external access.</li>
</ul>
<p><strong>Example <code>service.yaml</code></strong>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  selector:
    app: flask-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    nodePort: 30080
  type: NodePort
</code></pre>
<p><strong>Commands</strong>:</p>
<ol>
<li>Deploy the app and service:
<pre><code class="language-bash">kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
</code></pre>
</li>
<li>Get the NodePort:
<pre><code class="language-bash">kubectl get service flask-service
</code></pre>
Access the app at:
<pre><code>http://&lt;node-ip&gt;:30080
</code></pre>
</li>
</ol>
<hr />
<h2 id="step-3-scaling-the-application"><a class="header" href="#step-3-scaling-the-application"><strong>Step 3: Scaling the Application</strong></a></h2>
<h3 id="manual-scaling"><a class="header" href="#manual-scaling"><strong>Manual Scaling</strong></a></h3>
<ol>
<li>Scale the deployment to 5 replicas:
<pre><code class="language-bash">kubectl scale deployment flask-app --replicas=5
</code></pre>
</li>
<li>Verify the scaling:
<pre><code class="language-bash">kubectl get pods
</code></pre>
</li>
<li>Test load balancing:
<ul>
<li>Send multiple requests to the app:
<pre><code class="language-bash">curl http://&lt;node-ip&gt;:30080
</code></pre>
</li>
<li>Observe responses from different pods (<code>Hello from &lt;hostname&gt;</code>).</li>
</ul>
</li>
</ol>
<hr />
<h3 id="horizontal-pod-autoscaler-hpa"><a class="header" href="#horizontal-pod-autoscaler-hpa"><strong>Horizontal Pod Autoscaler (HPA)</strong></a></h3>
<ol>
<li>Enable Metrics Server (if using Minikube):
<pre><code class="language-bash">minikube addons enable metrics-server
</code></pre>
</li>
<li>Create an HPA to scale pods based on CPU usage:
<pre><code class="language-bash">kubectl autoscale deployment flask-app --cpu-percent=50 --min=1 --max=10
</code></pre>
</li>
<li>Simulate CPU load by hitting the <code>/cpu</code> route:
<pre><code class="language-bash">ab -n 1000 -c 50 http://&lt;node-ip&gt;:30080/cpu
</code></pre>
</li>
<li>Observe pod scaling:
<pre><code class="language-bash">kubectl get hpa
kubectl get pods
</code></pre>
</li>
</ol>
<hr />
<h2 id="step-4-rolling-updates"><a class="header" href="#step-4-rolling-updates"><strong>Step 4: Rolling Updates</strong></a></h2>
<ol>
<li>Modify <code>app.py</code> to change the message in the <code>/</code> route:
<pre><code class="language-python">return f"Hello from {hostname}! This is version 2 of the app. I've handled {counter} requests.\n"
</code></pre>
</li>
<li>Build and tag the new image as <code>v2</code>:
<pre><code class="language-bash">docker build -t flask-app:v2 .
docker tag flask-app:v2 &lt;your-registry&gt;/flask-app:v2
docker push &lt;your-registry&gt;/flask-app:v2
</code></pre>
</li>
<li>Update the deployment to use <code>v2</code>:
<pre><code class="language-bash">kubectl set image deployment/flask-app flask-container=flask-app:v2
</code></pre>
</li>
<li>Verify the rolling update:
<pre><code class="language-bash">kubectl rollout status deployment flask-app
</code></pre>
</li>
</ol>
<p>Test the app during the update:</p>
<ul>
<li>Old and new versions should coexist until the update is complete.</li>
</ul>
<hr />
<h2 id="step-5-load-testing"><a class="header" href="#step-5-load-testing"><strong>Step 5: Load Testing</strong></a></h2>
<p>Install and use <code>Apache Benchmark (ab)</code> to simulate high traffic:</p>
<ol>
<li>Install Apache Benchmark:
<pre><code class="language-bash">sudo apt-get install apache2-utils
</code></pre>
</li>
<li>Run the load test:
<pre><code class="language-bash">ab -n 1000 -c 100 http://&lt;node-ip&gt;:30080/
</code></pre>
</li>
<li>Observe:
<ul>
<li>How Kubernetes balances traffic across replicas.</li>
<li>Pod scaling behavior if HPA is enabled.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="expected-deliverables"><a class="header" href="#expected-deliverables"><strong>Expected Deliverables</strong></a></h2>
<ol>
<li><code>Dockerfile</code> and Docker images (<code>v1</code> and <code>v2</code>).</li>
<li>Kubernetes manifests (<code>deployment.yaml</code>, <code>service.yaml</code>).</li>
<li>Successful demonstration of:
<ul>
<li>Manual and automatic scaling.</li>
<li>Load balancing across pods.</li>
<li>Rolling update with zero downtime.</li>
<li>Load testing results showing app scalability.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-exercise-deploy-a-simple-app"><a class="header" href="#kubernetes-exercise-deploy-a-simple-app"><strong>Kubernetes Exercise: Deploy a Simple App</strong></a></h1>
<p><strong>Objective:</strong><br />
Dockerize a basic Python Flask application and deploy it using Kubernetes. The goal is to expose the app on port <strong>8080</strong> of the host machine, mapping it from port <strong>80</strong> in the container.</p>
<hr />
<h3 id="app-source-code"><a class="header" href="#app-source-code"><strong>App Source Code</strong></a></h3>
<p>Provide the following Python Flask application source code to the students:</p>
<p><strong>File: <code>app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello, Kubernetes!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<hr />
<h3 id="task-description"><a class="header" href="#task-description"><strong>Task Description</strong></a></h3>
<p>You have to :</p>
<ol>
<li>
<p><strong>Dockerize the Application</strong>:</p>
<ul>
<li>Write a <code>Dockerfile</code> to containerize the <code>app.py</code> application.</li>
<li>Build the Docker image locally.</li>
</ul>
</li>
<li>
<p><strong>Deploy the Application to Kubernetes</strong>:</p>
<ul>
<li>Create Kubernetes manifests to:
<ul>
<li>Define a Deployment that runs the containerized app.</li>
<li>Expose the app with a Kubernetes <strong>NodePort Service</strong>, mapping:
<ul>
<li><strong>Port 80</strong> in the container to <strong>port 8080</strong> on the host.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Test the Deployment</strong>:</p>
<ul>
<li>Verify that the application is accessible on <code>http://&lt;host-ip&gt;:8080</code> using a web browser or <code>curl</code>.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="deliverables-1"><a class="header" href="#deliverables-1"><strong>Deliverables</strong></a></h3>
<ul>
<li>A <code>Dockerfile</code> that correctly builds the container.</li>
<li>Kubernetes manifests:
<ul>
<li>A <code>deployment.yaml</code> file for the application.</li>
<li>A <code>service.yaml</code> file to expose the app.</li>
</ul>
</li>
<li>A running app accessible at <code>http://&lt;host-ip&gt;:8080</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-deploy-a-containerized-app-with-persistent-storage"><a class="header" href="#exercise-deploy-a-containerized-app-with-persistent-storage"><strong>Exercise: Deploy a Containerized App with Persistent Storage</strong></a></h1>
<p><strong>Objective</strong>:<br />
Deploy a containerized application using Kubernetes, and configure a volume to persist the application’s data.</p>
<hr />
<h2 id="scenario-3"><a class="header" href="#scenario-3"><strong>Scenario</strong></a></h2>
<p>You will deploy a Python Flask application that writes messages to a log file. The logs must be stored in a persistent volume to ensure data survives pod restarts. You must configure the persistent volume and volume claim in Kubernetes to achieve this.</p>
<hr />
<h2 id="provided-files-1"><a class="header" href="#provided-files-1"><strong>Provided Files</strong></a></h2>
<h3 id="1-flask-application-code-1"><a class="header" href="#1-flask-application-code-1"><strong>1. Flask Application Code</strong></a></h3>
<p><strong>File: <code>app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask, request, jsonify

app = Flask(__name__)

LOG_FILE = "/data/logs.txt"  # Path to the log file in the volume

@app.route("/")
def home():
    return "Welcome to the Flask App with Persistent Storage!"

@app.route("/write", methods=["POST"])
def write_log():
    try:
        message = request.json.get("message", "No message provided")
        with open(LOG_FILE, "a") as log_file:
            log_file.write(message + "\n")
        return jsonify({"status": "success", "message": f"Logged: {message}"})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/read", methods=["GET"])
def read_logs():
    try:
        with open(LOG_FILE, "r") as log_file:
            logs = log_file.readlines()
        return jsonify({"status": "success", "logs": logs})
    except FileNotFoundError:
        return jsonify({"status": "error", "message": "Log file not found"}), 404

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<hr />
<h2 id="instructions"><a class="header" href="#instructions"><strong>Instructions</strong></a></h2>
<h3 id="1-build-a-docker-image"><a class="header" href="#1-build-a-docker-image"><strong>1. Build a Docker Image</strong></a></h3>
<p>You must:</p>
<ul>
<li>Create a <code>Dockerfile</code> to containerize the <code>app.py</code> application.</li>
<li>Use a lightweight Python image (e.g., <code>python:3.9-slim</code>) as the base.</li>
<li>Ensure the container exposes port <strong>80</strong>.</li>
<li>Include the necessary Python dependencies (<code>flask</code>).</li>
</ul>
<h3 id="2-deploy-the-app-to-kubernetes"><a class="header" href="#2-deploy-the-app-to-kubernetes"><strong>2. Deploy the App to Kubernetes</strong></a></h3>
<p>You must:</p>
<ol>
<li>
<p>Create Kubernetes manifests to:</p>
<ul>
<li>Define a Deployment to run the containerized app.</li>
<li>Configure a Persistent Volume (PV) and Persistent Volume Claim (PVC) to store the app's logs in <code>/data/logs.txt</code>.</li>
<li>Mount the PVC in the container at <code>/data</code>.</li>
<li>Expose the app via a Service using a NodePort.</li>
</ul>
</li>
<li>
<p>Test the Application:</p>
<ul>
<li>Use the <code>/write</code> endpoint to send log messages:
<pre><code class="language-bash">curl -X POST http://&lt;host-ip&gt;:&lt;node-port&gt;/write -H "Content-Type: application/json" -d '{"message": "Hello, Persistent Storage!"}'
</code></pre>
</li>
<li>Retrieve the logs using the <code>/read</code> endpoint:
<pre><code class="language-bash">curl http://&lt;host-ip&gt;:&lt;node-port&gt;/read
</code></pre>
</li>
</ul>
</li>
</ol>
<hr />
<h2 id="expected-deliverables-1"><a class="header" href="#expected-deliverables-1"><strong>Expected Deliverables</strong></a></h2>
<ol>
<li>A <code>Dockerfile</code> that correctly builds the application container.</li>
<li>Kubernetes manifests for:
<ul>
<li>Deployment</li>
<li>Persistent Volume and Persistent Volume Claim</li>
<li>Service (NodePort)</li>
</ul>
</li>
<li>A running app accessible at <code>http://&lt;host-ip&gt;:&lt;node-port&gt;</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-connecting-containers-on-a-kubernetes-network"><a class="header" href="#exercise-connecting-containers-on-a-kubernetes-network"><strong>Exercise: Connecting Containers on a Kubernetes Network</strong></a></h1>
<p>Below is the source code for the two applications, <strong>API Service</strong> and <strong>Frontend Service</strong>, along with instructions for the exercise.</p>
<hr />
<h2 id="1-api-service-code"><a class="header" href="#1-api-service-code"><strong>1. API Service Code</strong></a></h2>
<p><strong>File: <code>api.py</code></strong></p>
<pre><code class="language-python">from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api")
def api():
    return jsonify({"message": "Hello from API Service!"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
</code></pre>
<hr />
<h2 id="2-frontend-service-code"><a class="header" href="#2-frontend-service-code"><strong>2. Frontend Service Code</strong></a></h2>
<p><strong>File: <code>frontend.py</code></strong></p>
<pre><code class="language-python">from flask import Flask
import requests

app = Flask(__name__)

API_SERVICE_URL = "http://api-service:5000/api"

@app.route("/")
def home():
    try:
        response = requests.get(API_SERVICE_URL)
        data = response.json()
        message = data.get("message", "No message received.")
        return f"&lt;h1&gt;Frontend Service&lt;/h1&gt;&lt;p&gt;Message from API: {message}&lt;/p&gt;"
    except Exception as e:
        return f"&lt;h1&gt;Error&lt;/h1&gt;&lt;p&gt;Unable to connect to API Service: {str(e)}&lt;/p&gt;"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5001)
</code></pre>
<hr />
<h2 id="task-instructions"><a class="header" href="#task-instructions"><strong>Task Instructions</strong></a></h2>
<h3 id="step-1-containerize-both-applications"><a class="header" href="#step-1-containerize-both-applications"><strong>Step 1: Containerize Both Applications</strong></a></h3>
<ol>
<li>Write Dockerfiles for both the API and Frontend services:
<ul>
<li>Use a lightweight Python image (e.g., <code>python:3.9-slim</code>).</li>
<li>Install the required dependencies (<code>flask</code> for both, <code>requests</code> for the frontend).</li>
<li>Set the correct working directory and copy the app code.</li>
</ul>
</li>
</ol>
<h3 id="step-2-create-kubernetes-manifests"><a class="header" href="#step-2-create-kubernetes-manifests"><strong>Step 2: Create Kubernetes Manifests</strong></a></h3>
<ol>
<li>
<p><strong>API Service</strong>:</p>
<ul>
<li>A Deployment to run the API service container.</li>
<li>A ClusterIP Service to expose the API service internally within the cluster.</li>
</ul>
</li>
<li>
<p><strong>Frontend Service</strong>:</p>
<ul>
<li>A Deployment to run the Frontend service container.</li>
<li>A NodePort Service to expose the Frontend service externally.</li>
</ul>
</li>
</ol>
<h3 id="step-3-connect-the-services"><a class="header" href="#step-3-connect-the-services"><strong>Step 3: Connect the Services</strong></a></h3>
<ul>
<li>Ensure the Frontend service communicates with the API service using the DNS name of the API service (<code>http://api-service:5000/api</code>).</li>
</ul>
<h3 id="step-4-test-the-setup"><a class="header" href="#step-4-test-the-setup"><strong>Step 4: Test the Setup</strong></a></h3>
<ul>
<li>Access the Frontend service via the NodePort and verify it displays the message fetched from the API service.</li>
</ul>
<hr />
<h2 id="deliverables-2"><a class="header" href="#deliverables-2"><strong>Deliverables</strong></a></h2>
<ol>
<li><code>Dockerfile</code> for both services.</li>
<li>Kubernetes manifests for:
<ul>
<li>API service (Deployment and Service).</li>
<li>Frontend service (Deployment and Service).</li>
</ul>
</li>
<li>A working application accessible via the Frontend service NodePort.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
