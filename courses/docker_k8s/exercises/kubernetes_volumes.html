<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes Volumes - Docker-K8s</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../course/part1/intro.html"><strong aria-hidden="true">1.</strong> Introduction à Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../course/part1/contenerisation.html"><strong aria-hidden="true">1.1.</strong> Histoire de la conteneurisation</a></li><li class="chapter-item expanded "><a href="../course/part1/docker_basics.html"><strong aria-hidden="true">1.2.</strong> Bases de Docker</a></li><li class="chapter-item expanded "><a href="../course/part1/images_and_containers.html"><strong aria-hidden="true">1.3.</strong> Images et containers</a></li><li class="chapter-item expanded "><a href="../course/part1/volumes.html"><strong aria-hidden="true">1.4.</strong> Volumes et persistence des données</a></li><li class="chapter-item expanded "><a href="../course/part1/wrap_up.html"><strong aria-hidden="true">1.5.</strong> Résumé</a></li></ol></li><li class="chapter-item expanded "><a href="../course/part2/intro.html"><strong aria-hidden="true">2.</strong> Concepts Avancés de Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../course/part2/networking.html"><strong aria-hidden="true">2.1.</strong> Mise en Réseau avec Docker</a></li><li class="chapter-item expanded "><a href="../course/part2/compose.html"><strong aria-hidden="true">2.2.</strong> Docker Compose</a></li></ol></li><li class="chapter-item expanded "><a href="../exercises/index.html"><strong aria-hidden="true">3.</strong> Exercices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exercises/ms_builds.html"><strong aria-hidden="true">3.1.</strong> Multistage Builds</a></li><li class="chapter-item expanded "><a href="../exercises/nginx_server_setup.html"><strong aria-hidden="true">3.2.</strong> Nginx Server Setup</a></li><li class="chapter-item expanded "><a href="../exercises/nginx_reverse_proxy.html"><strong aria-hidden="true">3.3.</strong> Nginx Reverse Proxy</a></li></ol></li><li class="chapter-item expanded "><a href="../exercises/hello-minikube.html"><strong aria-hidden="true">4.</strong> Kubernetes Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exercises/first-deployment.html"><strong aria-hidden="true">4.1.</strong> First Deployment</a></li><li class="chapter-item expanded "><a href="../exercises/kubernetes_volumes.html" class="active"><strong aria-hidden="true">4.2.</strong> Kubernetes Volumes</a></li><li class="chapter-item expanded "><a href="../exercises/kubernetes-networking.html"><strong aria-hidden="true">4.3.</strong> Kubernetes Networking</a></li><li class="chapter-item expanded "><a href="../exercises/scaling.html"><strong aria-hidden="true">4.4.</strong> Application Scaling</a></li></ol></li><li class="chapter-item expanded "><a href="../exercises/first-deployment-non-guided.html"><strong aria-hidden="true">5.</strong> Kubernetes Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exercises/kubernetes-volumes-non-guided.html"><strong aria-hidden="true">5.1.</strong> Kubernetes Volumes Exercise</a></li><li class="chapter-item expanded "><a href="../exercises/kubernetes-networking-non-guided.html"><strong aria-hidden="true">5.2.</strong> Kubernetes Networking Exercise</a></li></ol></li><li class="chapter-item expanded "><a href="../assessments/index.html"><strong aria-hidden="true">6.</strong> Assessments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../assessments/docker_project.html"><strong aria-hidden="true">6.1.</strong> Docker Project</a></li><li class="chapter-item expanded "><a href="../assessments/final-project.html"><strong aria-hidden="true">6.2.</strong> Final Project</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docker-K8s</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tutorial-implement-persistent-storage-with-kubernetes"><a class="header" href="#tutorial-implement-persistent-storage-with-kubernetes"><strong>Tutorial: Implement Persistent Storage with Kubernetes</strong></a></h1>
<p><strong>Objective:</strong><br />
Deploy a Flask application using Kubernetes with a focus on persistent storage. The app will log messages to a file stored in a Persistent Volume (PV), ensuring logs persist even if the container restarts.</p>
<hr />
<h2 id="starting-point-docker-compose-file"><a class="header" href="#starting-point-docker-compose-file"><strong>Starting Point: Docker Compose File</strong></a></h2>
<p>You are provided the following <code>docker-compose.yaml</code> file:</p>
<pre><code class="language-yaml">version: '3.9'
services:
  app:
    image: myapp
    pull_policy: build
    build: ./myapp
    container_name: app_container
    volumes:
      - ./logs:/data
    ports:
      - "8080:80"
</code></pre>
<p>This Docker Compose file:</p>
<ul>
<li>Defines a Flask app (<code>myapp</code>) container.</li>
<li>Mounts a <code>logs</code> directory from the host to the container's <code>/data</code> directory for persistent storage.</li>
<li>Exposes the app on port <code>8080</code> of the host machine.</li>
</ul>
<hr />
<h2 id="step-by-step-kubernetes-implementation"><a class="header" href="#step-by-step-kubernetes-implementation"><strong>Step-by-Step Kubernetes Implementation</strong></a></h2>
<p>You will recreate this setup in Kubernetes by defining a Deployment, Service, Persistent Volume (PV), and Persistent Volume Claim (PVC).</p>
<hr />
<h3 id="1-flask-application-code"><a class="header" href="#1-flask-application-code"><strong>1. Flask Application Code</strong></a></h3>
<p>Here’s the Flask app that logs messages to a file in the persistent volume:</p>
<p><strong>File: <code>myapp/app.py</code></strong></p>
<pre><code class="language-python">from flask import Flask, request

app = Flask(__name__)

LOG_FILE = "/data/logs.txt"

@app.route("/")
def home():
    return "Welcome to the Flask app with Persistent Storage!"

@app.route("/write", methods=["POST"])
def write_log():
    message = request.json.get("message", "No message provided")
    with open(LOG_FILE, "a") as log:
        log.write(message + "\n")
    return f"Logged: {message}", 200

@app.route("/read", methods=["GET"])
def read_log():
    try:
        with open(LOG_FILE, "r") as log:
            return "&lt;pre&gt;" + log.read() + "&lt;/pre&gt;", 200
    except FileNotFoundError:
        return "No logs found!", 404

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
</code></pre>
<hr />
<h3 id="2-dockerfile"><a class="header" href="#2-dockerfile"><strong>2. Dockerfile</strong></a></h3>
<p>Build the Flask app using this Dockerfile:</p>
<p><strong>File: <code>myapp/Dockerfile</code></strong></p>
<pre><code class="language-dockerfile"># Use a lightweight Python image
FROM python:3.9-slim

WORKDIR /app

COPY . /app

RUN pip install flask

EXPOSE 80

CMD ["python", "app.py"]
</code></pre>
<hr />
<h3 id="3-kubernetes-manifests"><a class="header" href="#3-kubernetes-manifests"><strong>3. Kubernetes Manifests</strong></a></h3>
<p><strong>a) Persistent Volume and Claim</strong></p>
<p>Create a Persistent Volume (PV) and Persistent Volume Claim (PVC) to store logs:</p>
<p><strong>File: <code>pv.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: flask-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /tmp/flask-logs
</code></pre>
<p><strong>File: <code>pvc.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: flask-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
</code></pre>
<hr />
<p><strong>b) Deployment</strong></p>
<p>Define the Deployment to mount the PVC as a volume:</p>
<p><strong>File: <code>deployment.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-app
        image: myapp:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: /data
          name: log-volume
      volumes:
      - name: log-volume
        persistentVolumeClaim:
          claimName: flask-pvc
</code></pre>
<hr />
<p><strong>c) Service</strong></p>
<p>Expose the Flask app with a Kubernetes Service:</p>
<p><strong>File: <code>service.yaml</code></strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  selector:
    app: flask-app
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 80
  type: NodePort
</code></pre>
<hr />
<h3 id="deployment-steps"><a class="header" href="#deployment-steps"><strong>Deployment Steps</strong></a></h3>
<ol>
<li>
<p><strong>Build and Load the Docker Image:</strong></p>
<pre><code class="language-bash">docker build -t myapp:latest ./myapp
minikube image load myapp:latest  # For Minikube
</code></pre>
</li>
<li>
<p><strong>Apply the PV and PVC:</strong></p>
<pre><code class="language-bash">kubectl apply -f pv.yaml
kubectl apply -f pvc.yaml
</code></pre>
</li>
<li>
<p><strong>Deploy the Application:</strong></p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
</code></pre>
</li>
<li>
<p><strong>Access the Application:</strong></p>
<ul>
<li>Get the NodePort of the Service:
<pre><code class="language-bash">kubectl get service flask-service
</code></pre>
</li>
<li>Access the app at <code>http://&lt;minikube-ip&gt;:&lt;node-port&gt;</code>, or <code>localhost</code> if you're using Docker Desktop.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="testing"><a class="header" href="#testing"><strong>Testing</strong></a></h2>
<ol>
<li>
<p><strong>Write Logs:</strong>
Use the <code>/write</code> endpoint to log messages:</p>
<pre><code class="language-bash">curl -X POST http://&lt;service-ip&gt;:&lt;node-port&gt;/write \
     -H "Content-Type: application/json" \
     -d '{"message": "Hello, Persistent Storage!"}'
</code></pre>
</li>
<li>
<p><strong>Read Logs:</strong>
Access the <code>/read</code> endpoint to view the logs:</p>
<pre><code class="language-bash">curl http://&lt;service-ip&gt;:&lt;node-port&gt;/read
</code></pre>
</li>
<li>
<p><strong>Verify Logs on the Host:</strong>
If using <code>hostPath</code>, check the logs directly on the Kubernetes node:</p>
<pre><code class="language-bash">cat /tmp/flask-logs/logs.txt
</code></pre>
</li>
</ol>
<hr />
<h2 id="deliverables"><a class="header" href="#deliverables"><strong>Deliverables</strong></a></h2>
<p>By completing this exercise, you will:</p>
<ol>
<li>Deploy a Flask application using Kubernetes.</li>
<li>Configure persistent storage with a Persistent Volume (PV) and Persistent Volume Claim (PVC).</li>
<li>Write logs to a file in the persistent volume and access them via an API and directly on the host.</li>
</ol>
<h2 id="what-are-persistent-volumes-pv-and-persistent-volume-claims-pvc"><a class="header" href="#what-are-persistent-volumes-pv-and-persistent-volume-claims-pvc"><strong>What are Persistent Volumes (PV) and Persistent Volume Claims (PVC)?</strong></a></h2>
<p>Persistent Volumes (PV) and Persistent Volume Claims (PVC) are Kubernetes resources used to manage <strong>persistent storage</strong> for applications. They allow data to persist even if a pod is deleted, rescheduled, or restarted.</p>
<hr />
<h3 id="persistent-volume-pv"><a class="header" href="#persistent-volume-pv"><strong>Persistent Volume (PV)</strong></a></h3>
<h4 id="what-is-a-persistent-volume"><a class="header" href="#what-is-a-persistent-volume">What is a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volume</a>?</a></h4>
<p>A Persistent Volume (PV) is a <strong>cluster-wide storage resource</strong> that provides storage for pods. It is an abstraction of physical storage (e.g., disk, network file system, cloud storage). The PV is managed by the cluster administrator and remains independent of individual pods.</p>
<ul>
<li><strong>Key Features of PV</strong>:
<ul>
<li>Abstracts storage from the underlying implementation (local disk, NFS, cloud storage).</li>
<li>Managed by the Kubernetes storage subsystem.</li>
<li>Can have different access modes to define how the volume is shared between pods.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="components-of-a-pv-manifest"><a class="header" href="#components-of-a-pv-manifest"><strong>Components of a PV Manifest</strong></a></h3>
<p>Here's a breakdown of the <code>pv.yaml</code> file from our example:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: flask-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /tmp/flask-logs
</code></pre>
<p><strong>1. <code>apiVersion</code> and <code>kind</code>:</strong></p>
<ul>
<li><strong><code>apiVersion: v1</code></strong>: Specifies the version of the Kubernetes API used.</li>
<li><strong><code>kind: PersistentVolume</code></strong>: Indicates that this is a Persistent Volume resource.</li>
</ul>
<p><strong>2. <code>metadata</code>:</strong></p>
<ul>
<li><strong><code>name</code></strong>: A unique name for the Persistent Volume (<code>flask-pv</code>).</li>
</ul>
<p><strong>3. <code>spec</code>:</strong></p>
<ul>
<li><strong><code>capacity</code></strong>: Specifies the storage capacity of the volume. In this case, the volume has <code>1Gi</code> (1 GiB) of storage.</li>
<li><strong><code>accessModes</code></strong>:
<ul>
<li>Defines how the volume can be accessed by pods. Common values:
<ul>
<li><strong><code>ReadWriteOnce (RWO)</code></strong>: Only one pod can mount the volume in read-write mode at a time.</li>
<li><strong><code>ReadOnlyMany (ROX)</code></strong>: Multiple pods can mount the volume in read-only mode.</li>
<li><strong><code>ReadWriteMany (RWX)</code></strong>: Multiple pods can mount the volume in read-write mode.</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>hostPath</code></strong>: Specifies the storage backend for the PV. In this case, the <code>hostPath</code> points to a directory on the host (<code>/tmp/flask-logs</code>). Other options include NFS, AWS EBS, GCP Disks, etc.</li>
</ul>
<hr />
<h3 id="persistent-volume-claim-pvc"><a class="header" href="#persistent-volume-claim-pvc"><strong>Persistent Volume Claim (PVC)</strong></a></h3>
<h4 id="what-is-a-persistent-volume-claim"><a class="header" href="#what-is-a-persistent-volume-claim">What is a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volume Claim</a>?</a></h4>
<p>A Persistent Volume Claim (PVC) is a <strong>request for storage by a pod</strong>. It is similar to a "claim ticket" that requests storage from available Persistent Volumes. A PVC defines how much storage is required and the access mode. Once bound to a PV, the PVC gives pods access to the underlying storage.</p>
<ul>
<li><strong>Key Features of PVC</strong>:
<ul>
<li>Decouples pod specifications from storage details.</li>
<li>Dynamically or statically binds to a PV based on matching requirements (capacity, access modes).</li>
<li>Ensures a pod always gets the requested storage, regardless of scheduling.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="components-of-a-pvc-manifest"><a class="header" href="#components-of-a-pvc-manifest"><strong>Components of a PVC Manifest</strong></a></h3>
<p>Here's a breakdown of the <code>pvc.yaml</code> file from our example:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: flask-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
</code></pre>
<p><strong>1. <code>apiVersion</code> and <code>kind</code>:</strong></p>
<ul>
<li><strong><code>apiVersion: v1</code></strong>: Specifies the version of the Kubernetes API used.</li>
<li><strong><code>kind: PersistentVolumeClaim</code></strong>: Indicates that this is a Persistent Volume Claim resource.</li>
</ul>
<p><strong>2. <code>metadata</code>:</strong></p>
<ul>
<li><strong><code>name</code></strong>: A unique name for the Persistent Volume Claim (<code>flask-pvc</code>).</li>
</ul>
<p><strong>3. <code>spec</code>:</strong></p>
<ul>
<li><strong><code>accessModes</code></strong>:
<ul>
<li>Matches the access modes of the PV. In this case, <code>ReadWriteOnce</code> allows one pod to mount the volume in read-write mode.</li>
</ul>
</li>
<li><strong><code>resources</code></strong>:
<ul>
<li><strong><code>requests</code></strong>:
<ul>
<li>Specifies the amount of storage the pod requires (<code>500Mi</code> in this case).</li>
</ul>
</li>
</ul>
</li>
<li>The PVC will bind to any PV that meets its requirements for capacity and access modes.</li>
</ul>
<hr />
<h3 id="how-pv-and-pvc-work-together"><a class="header" href="#how-pv-and-pvc-work-together"><strong>How PV and PVC Work Together</strong></a></h3>
<ol>
<li>
<p><strong>PV Creation</strong>:</p>
<ul>
<li>The cluster administrator creates Persistent Volumes to represent storage resources.</li>
</ul>
</li>
<li>
<p><strong>PVC Creation</strong>:</p>
<ul>
<li>A developer creates a Persistent Volume Claim to request storage. The PVC specifies the required storage size and access mode.</li>
</ul>
</li>
<li>
<p><strong>Binding</strong>:</p>
<ul>
<li>Kubernetes automatically finds a matching PV for the PVC based on the <code>accessModes</code> and <code>storage</code> requirements. If no matching PV is available, the PVC remains unbound until one becomes available.</li>
</ul>
</li>
<li>
<p><strong>Pod Access</strong>:</p>
<ul>
<li>Pods use the PVC to access the bound PV. The PVC is mounted as a volume in the pod's container.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="binding-workflow"><a class="header" href="#binding-workflow"><strong>Binding Workflow</strong></a></h3>
<ol>
<li>Administrator creates a PV (<code>flask-pv</code>) with <code>1Gi</code> capacity and <code>ReadWriteOnce</code> access mode.</li>
<li>Developer creates a PVC (<code>flask-pvc</code>) requesting <code>500Mi</code> and <code>ReadWriteOnce</code>.</li>
<li>Kubernetes matches the PVC with the PV because:
<ul>
<li>The requested storage (<code>500Mi</code>) is less than or equal to the PV's capacity (<code>1Gi</code>).</li>
<li>The access modes (<code>ReadWriteOnce</code>) match.</li>
</ul>
</li>
<li>The PVC binds to the PV, and the pod can now use the storage.</li>
</ol>
<hr />
<h3 id="why-use-pvcs"><a class="header" href="#why-use-pvcs"><strong>Why Use PVCs?</strong></a></h3>
<ul>
<li><strong>Separation of Concerns</strong>:
<ul>
<li>Developers don’t need to know storage details (e.g., NFS paths, cloud disks). They just request storage.</li>
<li>Administrators manage storage and PV provisioning.</li>
</ul>
</li>
<li><strong>Dynamic Storage Provisioning</strong>:
<ul>
<li>In some environments (e.g., AWS, GCP), PVCs can dynamically provision storage (e.g., create a new EBS volume).</li>
</ul>
</li>
<li><strong>Portability</strong>:
<ul>
<li>Applications can move across clusters without needing to know storage specifics.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="using-pv-and-pvc-in-pods"><a class="header" href="#using-pv-and-pvc-in-pods"><strong>Using PV and PVC in Pods</strong></a></h3>
<p>In our example, the Deployment mounts the PVC using the following configuration:</p>
<pre><code class="language-yaml">spec:
  volumes:
  - name: log-volume
    persistentVolumeClaim:
      claimName: flask-pvc
  containers:
  - name: flask-app
    volumeMounts:
    - mountPath: /data
      name: log-volume
</code></pre>
<ul>
<li><strong><code>volumes</code></strong>:
<ul>
<li>References the <code>flask-pvc</code> PVC. The PVC provides the storage from the bound PV.</li>
</ul>
</li>
<li><strong><code>volumeMounts</code></strong>:
<ul>
<li>Mounts the volume (<code>log-volume</code>) into the container at <code>/data</code>. This means all files written to <code>/data</code> in the container are stored in the PV.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="key-takeaways"><a class="header" href="#key-takeaways"><strong>Key Takeaways</strong></a></h3>
<ul>
<li><strong>PV</strong>:
<ul>
<li>Represents the physical storage resource.</li>
<li>Created and managed by the cluster administrator.</li>
</ul>
</li>
<li><strong>PVC</strong>:
<ul>
<li>A developer’s request for storage.</li>
<li>Automatically binds to a matching PV.</li>
</ul>
</li>
<li><strong>Together</strong>:
<ul>
<li>PVC decouples storage provisioning from application deployment, simplifying storage management.</li>
<li>PV ensures data persistence beyond the lifecycle of pods.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../exercises/first-deployment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../exercises/kubernetes-networking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../exercises/first-deployment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../exercises/kubernetes-networking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
