<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker-K8s</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course/part1/intro.html"><strong aria-hidden="true">1.</strong> Introduction Ã  Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course/part1/contenerisation.html"><strong aria-hidden="true">1.1.</strong> Histoire de la conteneurisation</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/docker/first_image.html"><strong aria-hidden="true">2.</strong> Premiere image node</a></li><li class="chapter-item expanded "><a href="exercises/docker/first_bind_mount.html"><strong aria-hidden="true">3.</strong> Premier serveur nginx</a></li><li class="chapter-item expanded "><a href="exercises/docker/image_by_hand.html"><strong aria-hidden="true">4.</strong> Image a la main</a></li><li class="chapter-item expanded "><a href="exercises/docker/flask_app.html"><strong aria-hidden="true">5.</strong> Flask Application</a></li><li class="chapter-item expanded "><a href="exercises/docker/first_app.html"><strong aria-hidden="true">6.</strong> Premier Network</a></li><li class="chapter-item expanded "><a href="exercises/docker/mp3_download.html"><strong aria-hidden="true">7.</strong> Telechargement de mp3 sur youtube</a></li><li class="chapter-item expanded "><a href="exercises/docker/unknown_language.html"><strong aria-hidden="true">8.</strong> Dockerisation d'un langage inconnu</a></li><li class="chapter-item expanded "><a href="exercises/docker/ms_builds.html"><strong aria-hidden="true">9.</strong> Builds Multistage</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docker-K8s</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="partie-1--introduction-Ã -la-conteneurisation-et-Ã -docker"><a class="header" href="#partie-1--introduction-Ã -la-conteneurisation-et-Ã -docker"><strong>Partie 1 : Introduction Ã  la Conteneurisation et Ã  Docker</strong></a></h1>
<h2 id="introduction"><a class="header" href="#introduction"><strong>Introduction</strong></a></h2>
<p>Au cours des derniÃ¨res dÃ©cennies, l'infrastructure informatique a connu une Ã©volution spectaculaire, passant de serveurs physiques imposants Ã  des technologies modernes telles que les conteneurs. Cette transition a transformÃ© la maniÃ¨re dont les entreprises dÃ©veloppent, testent, dÃ©ploient et gÃ¨rent leurs applications.</p>
<p>La conteneurisation est devenue une piÃ¨ce maÃ®tresse dans l'Ã©cosystÃ¨me du cloud et des environnements modernes. Elle rÃ©pond aux dÃ©fis de flexibilitÃ©, de scalabilitÃ© et d'efficacitÃ© posÃ©s par les approches traditionnelles. Contrairement aux machines virtuelles, les conteneurs sont lÃ©gers, portables et permettent de sâassurer que les applications fonctionnent de maniÃ¨re cohÃ©rente, quel que soit lâenvironnement dans lequel elles sont exÃ©cutÃ©es.</p>
<p>Docker, lâoutil le plus populaire de conteneurisation, a dÃ©mocratisÃ© cette technologie. Il offre une interface simple et intuitive pour crÃ©er, partager et gÃ©rer des conteneurs. Mais avant dâapprofondir les aspects pratiques de Docker, il est essentiel de comprendre les concepts fondamentaux de la conteneurisation : son origine, ses caractÃ©ristiques, ses avantages, et ses cas dâusage.</p>
<p>Dans cette premiÃ¨re partie, nous explorerons :</p>
<p>LâÃ©volution des infrastructures informatiques, en retraÃ§ant le chemin des serveurs physiques aux conteneurs.
Les caractÃ©ristiques clÃ©s des conteneurs, notamment leur lÃ©gÃ¨retÃ©, leur portabilitÃ© et leur capacitÃ© dâisolation.
Les avantages stratÃ©giques de la conteneurisation, tels que lâefficacitÃ© des ressources, la scalabilitÃ© rapide, et la consistance des environnements.
Les cas dâusage courants, qui illustreront pourquoi cette technologie est devenue incontournable pour des architectures modernes comme les microservices ou les pipelines CI/CD.</p>
<p>Enrichie de dÃ©monstrations pratiques et de quiz interactifs, cette partie vous donnera les bases nÃ©cessaires pour comprendre pourquoi la conteneurisation est une rÃ©volution pour lâinformatique dâentreprise et pour les dÃ©veloppeurs. Ã la fin de cette section, vous aurez une vision claire de ce que la conteneurisation peut apporter Ã  vos projets, ainsi qu'une bonne comprÃ©hension des concepts fondamentaux pour passer Ã  lâutilisation de Docker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i1-quest-ce-que-la-conteneurisation-"><a class="header" href="#i1-quest-ce-que-la-conteneurisation-"><strong>I.1 Qu'est-ce que la Conteneurisation ?</strong></a></h1>
<h2 id="i1a-Ãvolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><a class="header" href="#i1a-Ãvolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><strong>I.1.a Ãvolution des infrastructures : des serveurs physiques aux conteneurs</strong></a></h2>
<p>L'Ã©volution de l'infrastructure informatique est fondamentale pour comprendre pourquoi et comment les conteneurs ont transformÃ© l'informatique moderne.</p>
<ol>
<li>
<p><strong>Serveurs physiques</strong><br />
Ã l'origine, chaque application fonctionnait sur un serveur physique dÃ©diÃ©. Cette configuration impliquait souvent un surdimensionnement des ressources pour gÃ©rer les charges maximales, conduisant Ã  un gaspillage considÃ©rable.<br />
<em>Exemple : Imaginez un serveur dÃ©diÃ© uniquement Ã  une application de gestion de fichiers, mais nâutilisÃ© qu'Ã  30 % de sa capacitÃ© la majoritÃ© du temps.</em></p>
</li>
<li>
<p><strong>Machines virtuelles (VMs)</strong><br />
Lâintroduction des <strong>hyperviseurs</strong> (par exemple, VMware, Hyper-V) a permis de partitionner un serveur physique en plusieurs machines virtuelles, chacune exÃ©cutant son propre systÃ¨me d'exploitation. Bien que cette technologie ait optimisÃ© lâutilisation des ressources, elle nÃ©cessitait encore une copie complÃ¨te du systÃ¨me dâexploitation par VM, augmentant la consommation en mÃ©moire et en stockage.<br />
â Pour approfondir : <a href="https://www.redhat.com/fr/topics/containers/containers-vs-vms">Red Hat â VMs vs Containers</a>.</p>
</li>
<li>
<p><strong>Conteneurs</strong><br />
Contrairement aux VMs, les conteneurs partagent le noyau du systÃ¨me dâexploitation avec leur hÃ´te. Cela les rend lÃ©gers, rapides Ã  dÃ©marrer, et facilement portables. Par exemple, un conteneur peut contenir uniquement une application et ses dÃ©pendances, sans inclure un systÃ¨me d'exploitation complet.<br />
â En savoir plus : <a href="https://docs.docker.com/get-started/overview/">Documentation Docker â Qu'est-ce qu'un conteneur ?</a>.</p>
</li>
</ol>
<p><img src="course/part1/../../img/part1/Container_Evolution.svg" alt="History of contenerization" /></p>
<hr />
<h2 id="i1b-caractÃ©ristiques-clÃ©s-des-conteneurs"><a class="header" href="#i1b-caractÃ©ristiques-clÃ©s-des-conteneurs"><strong>I.1.b CaractÃ©ristiques clÃ©s des conteneurs</strong></a></h2>
<ul>
<li><strong>LÃ©gÃ¨retÃ© :</strong> Les conteneurs utilisent moins de ressources qu'une VM, car ils ne nÃ©cessitent pas un systÃ¨me d'exploitation complet.</li>
<li><strong>PortabilitÃ© :</strong> Une fois crÃ©Ã©, un conteneur peut Ãªtre exÃ©cutÃ© de maniÃ¨re identique sur un ordinateur local, un serveur on-premise ou dans un environnement cloud.</li>
<li><strong>Isolation :</strong> GrÃ¢ce aux technologies de namespaces et cgroups, chaque conteneur est isolÃ© du reste du systÃ¨me, Ã©vitant ainsi des conflits entre applications.<br />
â DÃ©couvrez les bases des namespaces et cgroups dans la <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">documentation Linux</a>.</li>
</ul>
<hr />
<h2 id="i1c-les-avantages-de-la-conteneurisation"><a class="header" href="#i1c-les-avantages-de-la-conteneurisation"><strong>I.1.c Les avantages de la conteneurisation</strong></a></h2>
<ul>
<li><strong>EfficacitÃ© des ressources :</strong> Contrairement aux VMs, les conteneurs partagent le noyau avec lâhÃ´te, ce qui rÃ©duit considÃ©rablement lâutilisation de la mÃ©moire et des CPU.</li>
<li><strong>ScalabilitÃ© rapide :</strong> Les conteneurs peuvent Ãªtre crÃ©Ã©s, dupliquÃ©s, ou supprimÃ©s en quelques secondes, ce qui les rend idÃ©aux pour gÃ©rer des charges variables.</li>
<li><strong>Consistance des environnements :</strong> Avec les conteneurs, "Ã§a marche sur ma machine" devient un problÃ¨me du passÃ©, car chaque conteneur inclut tout ce dont l'application a besoin pour fonctionner.</li>
</ul>
<hr />
<h2 id="i1d-cas-dusage-courants-des-conteneurs"><a class="header" href="#i1d-cas-dusage-courants-des-conteneurs"><strong>I.1.d Cas dâusage courants des conteneurs</strong></a></h2>
<ul>
<li><strong>Microservices :</strong> Permettent de diviser une application complexe en composants plus petits et indÃ©pendants.</li>
<li><strong>CI/CD :</strong> IntÃ©gration et dÃ©ploiement continus grÃ¢ce Ã  des environnements identiques pour le dÃ©veloppement, les tests et la production.</li>
<li><strong>Tests :</strong> Facilite la crÃ©ation rapide d'environnements jetables pour tester de nouvelles fonctionnalitÃ©s.<br />
â Cas pratique : <a href="https://netflixtechblog.com/">Netflix et les conteneurs</a>: dÃ©couvrez comment Netflix utilise les conteneurs pour le streaming mondial.</li>
</ul>
<hr />
<h2 id="exercices-pratiques"><a class="header" href="#exercices-pratiques"><strong>Exercices pratiques</strong></a></h2>
<h4 id="exercice-1--comparaison-entre-vms-et-conteneurs"><a class="header" href="#exercice-1--comparaison-entre-vms-et-conteneurs"><strong>Exercice 1 : Comparaison entre VMs et conteneurs</strong></a></h4>
<ol>
<li>TÃ©lÃ©chargez <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> et <a href="https://www.virtualbox.org/">VirtualBox</a>.</li>
<li>DÃ©marrez une machine virtuelle avec VirtualBox et installez un serveur web simple comme Apache. Notez les ressources consommÃ©es (RAM et CPU).</li>
<li>DÃ©marrez un conteneur avec Docker (exemple : <code>docker run -d -p 8080:80 nginx</code>) et observez les ressources consommÃ©es.</li>
<li>Comparez le temps de dÃ©marrage, la mÃ©moire et le CPU utilisÃ©s entre les deux configurations.</li>
</ol>
<h4 id="exercice-2--visualisation-des-namespaces-et-cgroups"><a class="header" href="#exercice-2--visualisation-des-namespaces-et-cgroups"><strong>Exercice 2 : Visualisation des namespaces et cgroups</strong></a></h4>
<ol>
<li>Lancez un conteneur avec Docker :
<pre><code class="language-bash">docker run -it --name test-container ubuntu /bin/bash
</code></pre>
</li>
<li>Depuis lâhÃ´te, observez les namespaces associÃ©s au conteneur en exÃ©cutant :
<pre><code class="language-bash">lsns
</code></pre>
</li>
<li>Affichez les cgroups actifs pour le conteneur avec :
<pre><code class="language-bash">cat /sys/fs/cgroup/&lt;group_path&gt;/tasks
</code></pre>
</li>
<li>RÃ©sumez vos observations : que voyez-vous en termes dâisolation ?</li>
</ol>
<h2 id="quizz-dintroduction"><a class="header" href="#quizz-dintroduction"><strong>Quizz d'introduction</strong></a></h2>
<p>Vous pouvez maintenant tester votre comprÃ©hension des notions de base de Docker avec le quizz suivant :</p>
<div class="quiz-placeholder" data-quiz-name="&quot;intro_quizz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Les conteneurs sont lÃ©gers car ils n'ont pas besoin d'une instance sÃ©parÃ©e de systÃ¨me d'exploitation. Ils partagent le noyau de l'hÃ´te.\n&quot;,&quot;id&quot;:&quot;f9d735c0-50dc-483f-8c10-822a08289b52&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Oui, les conteneurs partagent le noyau du systÃ¨me dâexploitation de lâhÃ´te.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Non, les conteneurs possÃ¨dent leur propre noyau.&quot;,&quot;Seulement s'ils fonctionnent sur Linux.&quot;],&quot;prompt&quot;:&quot;Les conteneurs partagent-ils le noyau du systÃ¨me dâexploitation de lâhÃ´te ?&quot;}},{&quot;context&quot;:&quot;Les machines virtuelles utilisent un hyperviseur pour Ã©muler un systÃ¨me d'exploitation complet, tandis que les conteneurs s'appuient sur le systÃ¨me de l'hÃ´te, ce qui les rend plus lÃ©gers et rapides.\n&quot;,&quot;id&quot;:&quot;35c26965-2496-4582-9387-0c35b4e88683&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les conteneurs partagent le noyau du systÃ¨me dâexploitation de lâhÃ´te, tandis que les machines virtuelles Ã©mulent un systÃ¨me complet.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs sont plus lourds que les machines virtuelles.&quot;,&quot;Les machines virtuelles n'ont pas besoin de systÃ¨me d'exploitation.&quot;,&quot;Les conteneurs nÃ©cessitent un hyperviseur supplÃ©mentaire pour fonctionner.&quot;],&quot;prompt&quot;:&quot;Quelle est la principale diffÃ©rence entre les conteneurs et les machines virtuelles ?&quot;}},{&quot;context&quot;:&quot;Un conteneur encapsule tout ce dont une application a besoin pour fonctionner : son code, ses dÃ©pendances, et ses configurations, garantissant une cohÃ©rence totale entre les environnements.\n&quot;,&quot;id&quot;:&quot;55e1ea81-626a-4249-87d2-61dbb395a33a&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;application, dÃ©pendances&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est une unitÃ© lÃ©gÃ¨re et portable d'___ et de ses ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont idÃ©aux pour des scÃ©narios nÃ©cessitant une scalabilitÃ©, une portabilitÃ© et une cohÃ©rence, comme les microservices ou les pipelines CI/CD.\n&quot;,&quot;id&quot;:&quot;ec577900-6ec8-4305-946f-3d0850e74b8e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Une architecture basÃ©e sur les microservices.&quot;,&quot;Des pipelines d'intÃ©gration et de dÃ©ploiement continus (CI/CD).&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;ExÃ©cution d'une seule application sur un matÃ©riel dÃ©diÃ©.&quot;,&quot;DÃ©ploiement dâune application monolithique sans mises Ã  jour frÃ©quentes.&quot;,&quot;Traitement par lots sur des serveurs bare-metal.&quot;],&quot;prompt&quot;:&quot;Quels scÃ©narios bÃ©nÃ©ficient le plus de la conteneurisation ? (Choisissez deux)&quot;}},{&quot;context&quot;:&quot;Les serveurs physiques exÃ©cutent directement les applications sur le matÃ©riel. Les VMs Ã©mulent des environnements OS complets. Les conteneurs partagent le noyau de lâhÃ´te.\n&quot;,&quot;id&quot;:&quot;f532170e-dd96-46a6-91c0-e7bdd59dfc1c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Serveurs physiques : Application unique, non virtualisÃ©e.&quot;,&quot;Machines virtuelles : Lourd, Ã©mulation complÃ¨te d'OS.&quot;,&quot;Conteneurs : LÃ©ger, partage le noyau de l'hÃ´te.&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Conteneurs : Lourds, Ã©mulation complÃ¨te d'OS.&quot;,&quot;Serveurs physiques : Partage des ressources, processus isolÃ©s.&quot;,&quot;Machines virtuelles : Partagent le noyau de l'hÃ´te.&quot;],&quot;prompt&quot;:&quot;Associez les technologies suivantes Ã  leurs caractÃ©ristiques : serveurs physiques, machines virtuelles, conteneurs.&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'assurer une isolation au sein des conteneurs, sÃ©parant les processus et ressources de l'hÃ´te et des autres conteneurs.\n&quot;,&quot;id&quot;:&quot;6c07415e-b848-499f-8bc1-806143d72bd1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Isoler les processus, systÃ¨mes de fichiers et interfaces rÃ©seau.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;ContrÃ´ler la quantitÃ© de ressources (CPU, RAM) quâun conteneur peut utiliser.&quot;,&quot;GÃ©rer les dÃ©pendances logicielles Ã  lâintÃ©rieur dâun conteneur.&quot;],&quot;prompt&quot;:&quot;Dans une architecture conteneurisÃ©e, quel est le rÃ´le des namespaces ?&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'isoler les processus, les systÃ¨mes de fichiers, et les interfaces rÃ©seau des conteneurs, garantissant une sÃ©paration totale entre les conteneurs et l'hÃ´te.\n&quot;,&quot;id&quot;:&quot;cfb52846-c478-4a66-a918-28241abf55ee&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;processus, systÃ¨mes de fichiers, interfaces rÃ©seau&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Dans une architecture conteneurisÃ©e, les namespaces servent Ã  isoler ___, ___ et ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont conÃ§us pour Ãªtre plus lÃ©gers et dÃ©marrer plus rapidement que les machines virtuelles, car ils n'ont pas besoin d'inclure un systÃ¨me d'exploitation complet.\n&quot;,&quot;id&quot;:&quot;56d269f9-466c-4526-ad36-b7fd5c06b5ba&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;lÃ©ger, rapidement&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est plus ___ et dÃ©marre plus ___ qu'une machine virtuelle.&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="tp--dockeriser-un-backend-simple-nodejs"><a class="header" href="#tp--dockeriser-un-backend-simple-nodejs">TP â Dockeriser un backend simple (Node.js)</a></h1>
<h2 id="objectif"><a class="header" href="#objectif">Objectif</a></h2>
<p>DÃ©couvrir les bases concrÃ¨tes de Docker Ã  travers une application Node.js minimaliste.<br />
Ã la fin de lâexercice, vous devez avoir :</p>
<ul>
<li>Une image Docker fonctionnelle</li>
<li>Un conteneur lancÃ© Ã  partir de cette image</li>
<li>Une application accessible en local via un port exposÃ©</li>
</ul>
<hr />
<h2 id="fichiers-fournis"><a class="header" href="#fichiers-fournis">Fichiers fournis</a></h2>
<p>Vous partez dâun dossier <code>simple-backend/</code> contenant :</p>
<pre><code>simple-backend/
âââ app.js
âââ package.json
</code></pre>
<p>Contenu de <code>app.js</code> :</p>
<pre><code class="language-js">const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; res.send('Hello Docker'));
app.listen(3000, () =&gt; console.log('Listening on port 3000'));
</code></pre>
<p>Contenu de <code>package.json</code> :</p>
<pre><code class="language-json">{
  "dependencies": {
    "express": "^5.1.0"
  }
}
</code></pre>
<hr />
<h2 id="Ãtapes"><a class="header" href="#Ãtapes">Ãtapes</a></h2>
<ol>
<li>
<p>CrÃ©ez un fichier <code>Dockerfile</code> Ã  la racine du projet.<br />
Il doit :</p>
<ul>
<li>Utiliser lâimage officielle <code>node:latest</code></li>
<li>DÃ©finir un dossier de travail (<code>/app</code>)</li>
<li>Copier les fichiers nÃ©cessaires dans le conteneur</li>
<li>Installer les dÃ©pendances (<code>npm i</code>)</li>
<li>DÃ©finir la commande de dÃ©marrage de lâapplication (<code>node app.js</code>)</li>
</ul>
</li>
<li>
<p>Construisez lâimage Docker</p>
</li>
<li>
<p>Lancez un conteneur Ã  partir de lâimage (n'oubliez-pas de transferer le port 8080 vers le port 3000)</p>
</li>
<li>
<p>VÃ©rifiez que votre application fonctionne en ouvrant <a href="http://localhost:8080">http://localhost:8080</a></p>
</li>
<li>
<p>Affichez les logs du conteneur :</p>
</li>
</ol>
<pre><code>docker logs backend
</code></pre>
<ol start="6">
<li>ArrÃªtez puis supprimez le conteneur</li>
</ol>
<hr />
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<ol>
<li>Quelle diffÃ©rence entre une <strong>image</strong> et un <strong>conteneur</strong> ?</li>
<li>Si tu changes <code>app.js</code>, que dois-tu faire pour voir la mise Ã  jour dans le conteneur ?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--servir-un-site-statique-avec-nginx-dans-un-conteneur"><a class="header" href="#tp--servir-un-site-statique-avec-nginx-dans-un-conteneur">TP â Servir un site statique avec Nginx dans un conteneur</a></h1>
<h2 id="objectif-1"><a class="header" href="#objectif-1">Objectif</a></h2>
<p>Comprendre comment lancer un conteneur qui utilise une image officielle existante pour servir du contenu local.<br />
DÃ©couvrir le <strong>montage de rÃ©pertoire</strong> dans un conteneur (volume simple).</p>
<hr />
<h2 id="fichiers-Ã -crÃ©er"><a class="header" href="#fichiers-Ã -crÃ©er">Fichiers Ã  crÃ©er</a></h2>
<p>Dans un dossier <code>static-site/</code> :</p>
<pre><code>static-site/
âââ index.html
</code></pre>
<p>Contenu simple de <code>index.html</code> :</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Mon site DockerisÃ©&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;&lt;h1&gt;Bienvenue dans le monde des conteneurs&lt;/h1&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr />
<h2 id="Ãtapes-1"><a class="header" href="#Ãtapes-1">Ãtapes</a></h2>
<ol>
<li>
<p>CrÃ©ez un dossier <code>static-site/</code> contenant un fichier <code>index.html</code> comme ci-dessus.</p>
</li>
<li>
<p>Lancez un conteneur basÃ© sur lâimage officielle <code>nginx</code>, avec ce fichier servi Ã  la racine du site.<br />
Pour cela :</p>
<ul>
<li>Montez votre dossier local dans <code>/usr/share/nginx/html</code> (rÃ©pertoire utilisÃ© par dÃ©faut par Nginx dans le conteneur)</li>
<li>TransfÃ©rez le port <code>8081</code> (host) vers le port <code>80</code> (conteneur)</li>
<li>Donnez-lui un nom, par exemple <code>nginx-site</code></li>
</ul>
</li>
<li>
<p>Testez que le site est accessible sur <a href="http://localhost:8081">http://localhost:8081</a></p>
</li>
<li>
<p>Modifiez <code>index.html</code>, rechargez la page, vÃ©rifiez que la modification est visible</p>
</li>
</ol>
<blockquote>
<p>Cela prouve que le dossier local est bien <strong>montÃ© dans le conteneur</strong>.</p>
</blockquote>
<hr />
<h2 id="questions-1"><a class="header" href="#questions-1">Questions</a></h2>
<ol>
<li>Ã quoi sert le flag <code>--mount</code> dans <code>docker run</code> ?</li>
<li>Quelle est la diffÃ©rence entre copier des fichiers dans lâimage et les monter depuis lâextÃ©rieur ?</li>
<li>Quelle commande permet de voir les conteneurs qui tournent actuellement ?</li>
<li>Quelle commande permet de supprimer un conteneur arrÃªtÃ© ?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--construire-une-image-de-dÃ©veloppement-Ã -la-main-ubuntu"><a class="header" href="#tp--construire-une-image-de-dÃ©veloppement-Ã -la-main-ubuntu">TP â Construire une image de dÃ©veloppement Ã  la main (Ubuntu)</a></h1>
<h2 id="objectif-2"><a class="header" href="#objectif-2">Objectif</a></h2>
<p>CrÃ©er une image Docker personnalisÃ©e qui pourra te servir de base pour du dÃ©veloppement en ligne de commande.<br />
Pas de Dockerfile. Tu fais tout <strong>Ã  la main</strong>, comme un artisan qui cloue ses propres conteneurs.</p>
<hr />
<h2 id="contexte"><a class="header" href="#contexte">Contexte</a></h2>
<p>Tu pars dâune image de base : <code>ubuntu</code> (derniÃ¨re version).<br />
Tu installes ce dont <em>tu</em> as besoin pour coder/travailler dans un terminal.</p>
<h3 id="ton-image-finale-doit-contenir-au-minimum-"><a class="header" href="#ton-image-finale-doit-contenir-au-minimum-">Ton image finale doit contenir <strong>au minimum</strong> :</a></h3>
<ul>
<li><code>curl</code> ou Ã©quivalent</li>
<li><code>git</code></li>
<li>un Ã©diteur en ligne de commande (<code>nano</code>, <code>vim</code>, <code>micro</code>, autre)</li>
<li>un dossier <code>/workspace</code> vide prÃªt Ã  accueillir des projets</li>
</ul>
<hr />
<h2 id="Ãtapes-2"><a class="header" href="#Ãtapes-2">Ãtapes</a></h2>
<ol>
<li>Lance un conteneur Ubuntu interactif :</li>
</ol>
<pre><code>docker run -it ubuntu bash
</code></pre>
<ol start="2">
<li>
<p>Installe les outils nÃ©cessaires. Ã toi de trouver les bonnes commandes.</p>
</li>
<li>
<p>CrÃ©e un dossier <code>/workspace</code> dans le conteneur.</p>
</li>
<li>
<p>Une fois que tout est prÃªt fige ton travail :</p>
</li>
</ol>
<blockquote>
<p>Attention a bien faire ca dans un autre terminal</p>
</blockquote>
<pre><code>docker commit &lt;id_du_conteneur&gt; dev-env-&lt;tonprenom&gt;
</code></pre>
<ol start="5">
<li>Teste ton image : relance un conteneur Ã  partir de <code>dev-env-&lt;tonprenom&gt;</code> et vÃ©rifie que tout est bien en place.</li>
</ol>
<hr />
<h2 id="Ã-avoir-au-minimum"><a class="header" href="#Ã-avoir-au-minimum">Ã avoir au minimum</a></h2>
<ul>
<li>Le nom de ton image (<code>docker images</code>)</li>
<li>Une image ou:
<ul>
<li><code>git</code> fonctionne</li>
<li><code>curl</code> fonctionne</li>
<li>ton Ã©diteur fonctionne</li>
<li><code>/workspace</code> existe</li>
</ul>
</li>
</ul>
<hr />
<h2 id="questions-2"><a class="header" href="#questions-2">Questions</a></h2>
<ol>
<li>Quels paquets as-tu dÃ» installer ? (nom exact)</li>
<li>Pourquoi nâa-t-on pas utilisÃ© de Dockerfile ici ?</li>
<li>Quels sont les avantages de cette mÃ©thode ? Les inconvÃ©nients ?</li>
</ol>
<hr />
<h2 id="bonus-optionnel"><a class="header" href="#bonus-optionnel">Bonus (optionnel)</a></h2>
<p>Ajoute un alias ou une commande custom dans <code>.bashrc</code> (ex: <code>alias ll='ls -la'</code>)<br />
VÃ©rifie quâelle est bien prÃ©sente au prochain lancement de conteneur.</p>
<hr />
<p><em>Rappelle-toi : une image Docker, câest juste un conteneur figÃ©. Tu peux la bricoler Ã  la main, la commiter, la partager, mais sans traÃ§abilitÃ©, câest vite le bordel.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--construire-une-app-flask-dans-un-conteneur-ubuntu-image-autonome"><a class="header" href="#tp--construire-une-app-flask-dans-un-conteneur-ubuntu-image-autonome">TP â Construire une app Flask dans un conteneur Ubuntu (Image autonome)</a></h1>
<h2 id="objectif-3"><a class="header" href="#objectif-3">Objectif</a></h2>
<p>DÃ©velopper une petite application Flask et la faire tourner dans un conteneur Docker <strong>basÃ© sur Ubuntu</strong>.<br />
Tu commences comme tu veux (interactif, scriptÃ©).<br />
Mais <strong>Ã  la fin</strong>, tu dois livrer <strong>une image autonome</strong>.</p>
<hr />
<h2 id="dÃ©part"><a class="header" href="#dÃ©part">DÃ©part</a></h2>
<p>Tu pars dâun dossier <code>flask-docker/</code> contenant ces fichiers :</p>
<h3 id="apppy"><a class="header" href="#apppy"><code>app.py</code></a></h3>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello Docker"
</code></pre>
<h2 id="Ã-faire"><a class="header" href="#Ã-faire">Ã faire</a></h2>
<ol>
<li>Partir de lâimage <code>ubuntu</code> (derniÃ¨re version).</li>
<li>Installer tout ce quâil faut:
<ul>
<li><code>python3</code></li>
<li><code>pip</code></li>
<li><code>flask</code></li>
</ul>
</li>
<li>Pendant le dÃ©veloppement, fais comme tu veux : tu peux monter des fichiers, modifier en live, tâÃ©nerver.</li>
<li><strong>Mais Ã  la fin</strong>, ton projet doit Ãªtre <strong>contenu dans une image autonome</strong> :
<ul>
<li>Tout est <strong>copiÃ©</strong> dans lâimage (pas de <code>-v</code>, pas de montage)</li>
<li>Lâapp se lance automatiquement</li>
<li>Le conteneur expose <code>http://localhost:8080</code> quand on le run</li>
</ul>
</li>
</ol>
<hr />
<h2 id="interdiction"><a class="header" href="#interdiction">Interdiction</a></h2>
<ul>
<li>Pas dâimage <code>python:*</code></li>
<li>Pas de <code>bind mount</code> dans le <code>docker run</code> final</li>
<li>Pas de <code>flask run</code> lancÃ© manuellement dans un shell</li>
</ul>
<hr />
<h2 id="Ã-avoir"><a class="header" href="#Ã-avoir">Ã avoir</a></h2>
<ul>
<li><code>Dockerfile</code> final propre</li>
<li><code>app.py</code></li>
<li>La commande complÃ¨te <code>docker build</code> + <code>docker run</code> utilisÃ©e</li>
<li>Preuve que ton conteneur tourne et rÃ©pond bien sur <code>localhost:8080</code></li>
</ul>
<hr />
<h2 id="liens-utiles"><a class="header" href="#liens-utiles">Liens utiles</a></h2>
<ul>
<li><a href="https://flask.palletsprojects.com/en/latest/">Docs Flask</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile rÃ©fÃ©rence</a></li>
<li><a href="https://flask.palletsprojects.com/en/latest/cli/#run">Exemple <code>flask run</code></a></li>
</ul>
<hr />
<h2 id="bonus"><a class="header" href="#bonus">Bonus</a></h2>
<ul>
<li>Ajoute un <code>ENTRYPOINT</code> ou <code>CMD</code> propre</li>
<li>Utilise des variables dâenvironnement dans ton <code>Dockerfile</code> (ex : <code>FLASK_ENV=production</code>)</li>
<li>CrÃ©e un dossier <code>/app</code> dans lâimage pour bosser proprement</li>
</ul>
<hr />
<h2 id="aide"><a class="header" href="#aide">Aide</a></h2>
<ul>
<li>Tu peux utiliser l'option <code>--port port_number</code> pour changer le port par defaut de <code>flask</code> (si besoin)</li>
<li>Tu peux utiliser l'option <code>--host=0.0.0.0</code> pour que l'application ecoute sur tous les ports</li>
</ul>
<p><em>Ã la fin, tu dois avoir une image que tu peux envoyer Ã  nâimporte qui.<br />
Il la build, il la run, elle rÃ©pond. Pas de dÃ©pendance locale.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--backend--db-dans-deux-conteneurs-sans-compose"><a class="header" href="#tp--backend--db-dans-deux-conteneurs-sans-compose">TP â Backend + DB dans deux conteneurs (sans Compose)</a></h1>
<h2 id="objectif-4"><a class="header" href="#objectif-4">Objectif</a></h2>
<p>CrÃ©er une application en Python avec un backend qui communique avec une base de donnÃ©es, chaque composant tournant dans <strong>son propre conteneur</strong>, sur le <strong>mÃªme rÃ©seau Docker</strong>.</p>
<hr />
<h2 id="contraintes"><a class="header" href="#contraintes">Contraintes</a></h2>
<ul>
<li>Utilisation obligatoire de lâimage <code>mariadb</code> ou <code>mongo</code> (au choix selon ton aisance)</li>
<li>Le backend Python doit :
<ul>
<li>Se connecter Ã  la DB via son <strong>nom de conteneur</strong></li>
<li>Ãtre accessible sur le port <code>5000</code> (depuis lâextÃ©rieur)</li>
<li>Implementer le CRUD</li>
</ul>
</li>
<li>Pas de docker-compose</li>
<li>Le tout doit Ãªtre lanÃ§able en ligne de commande :</li>
</ul>
<pre><code class="language-bash">docker network create app-network
docker run (avec les bons flags) mongo/mariadb
docker build -t backend .
docker run (avec les bons flags) backend
</code></pre>
<p>Le backend doit proposer au minimum :</p>
<ul>
<li>POST /items â crÃ©er un Ã©lÃ©ment</li>
<li>GET /items â lister les Ã©lÃ©ments</li>
<li>GET /items/<id> â voir un Ã©lÃ©ment</li>
<li>DELETE /items/<id> â supprimer un Ã©lÃ©ment</li>
</ul>
<hr />
<h2 id="Ã-avoir-1"><a class="header" href="#Ã-avoir-1">Ã avoir</a></h2>
<ul>
<li>Le code du backend (<code>main.py</code>, <code>requirements.txt</code>, etc.)</li>
<li>Le <code>Dockerfile</code> du backend</li>
<li>La commande exacte de <code>docker run</code> pour la DB</li>
<li>La commande exacte de <code>docker run</code> pour le backend</li>
<li>Preuve que la communication backend â DB fonctionne (ex : un GET sur <code>/status</code> retourne âDB OKâ)</li>
</ul>
<blockquote>
<p>Ce TP ne teste pas ta capacitÃ© Ã  coder un backend, mais ta capacitÃ© Ã  <strong>faire dialoguer des conteneurs entre eux</strong>, proprement, sans docker-compose.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--tÃ©lÃ©charger-une-vidÃ©o-ou-une-musique-avec-yt-dlp-dans-un-conteneur"><a class="header" href="#tp--tÃ©lÃ©charger-une-vidÃ©o-ou-une-musique-avec-yt-dlp-dans-un-conteneur">TP â TÃ©lÃ©charger une vidÃ©o ou une musique avec yt-dlp dans un conteneur</a></h1>
<h2 id="objectif-5"><a class="header" href="#objectif-5">Objectif</a></h2>
<p>CrÃ©er un conteneur Docker basÃ© sur Ubuntu, capable de tÃ©lÃ©charger <strong>lâaudio dâune vidÃ©o YouTube au format MP3</strong>, sans rien installer sur ton systÃ¨me hÃ´te.</p>
<hr />
<h2 id="contraintes-1"><a class="header" href="#contraintes-1">Contraintes</a></h2>
<ul>
<li>Tu pars de lâimage <code>ubuntu</code> (derniÃ¨re version)</li>
<li>Tu dois installer dans le conteneur :
<ul>
<li><code>python3</code>, <code>pip</code></li>
<li><code>ffmpeg</code></li>
<li><code>yt-dlp</code> via <code>pip</code></li>
</ul>
</li>
<li>Lâapp doit :
<ul>
<li>TÃ©lÃ©charger lâaudio dâune vidÃ©o YouTube</li>
<li>Sauvegarder le fichier <code>.mp3</code> dans un dossier montÃ© depuis lâhÃ´te (<code>./downloads</code>)</li>
<li>Utiliser les options suivantes :
<pre><code>--restrict-filename -x --audio-format mp3
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Exemple de ligne de commande (vous pouvez la tester):</p>
<pre><code class="language-bash">yt-dlp --restrict-filenames -x --audio-format mp3 https://youtu.be/dQw4w9WgXcQ?si=rnTHt9xqOZdI1leO
</code></pre>
<hr />
<h2 id="Ã-faire-1"><a class="header" href="#Ã-faire-1">Ã faire</a></h2>
<ol>
<li>
<p>CrÃ©e un <code>Dockerfile</code> qui :</p>
<ul>
<li>Installe tous les outils nÃ©cessaires</li>
<li>Configure un dossier <code>/downloads</code></li>
<li>Utilise <code>CMD</code> ou un script Bash/Python pour tÃ©lÃ©charger</li>
</ul>
</li>
<li>
<p>Le conteneur doit se lancer avec une commande du style :</p>
</li>
</ol>
<pre><code class="language-bash">docker build -t yt-downloader .
docker run --rm -v $(pwd)/downloads:/downloads yt-downloader "https://www.youtube.com/watch?v=VIDEO_ID"
</code></pre>
<blockquote>
<p>Le lien doit Ãªtre passÃ© en argument ou via une variable dâenvironnement
Si aucune URL nâest fournie, le conteneur doit afficher une erreur claire et sâarrÃªter immÃ©diatement.</p>
</blockquote>
<hr />
<h2 id="Ã-avoir-a-la-fin"><a class="header" href="#Ã-avoir-a-la-fin">Ã avoir a la fin</a></h2>
<ul>
<li><code>Dockerfile</code></li>
<li>Optionnel : script <code>download.sh</code> (ou <code>download.py</code>) qui appelle <code>yt-dlp</code></li>
<li>Commande <code>docker run</code> utilisÃ©e</li>
<li>Un exemple de fichier tÃ©lÃ©chargÃ©</li>
</ul>
<hr />
<h2 id="bonus-1"><a class="header" href="#bonus-1">Bonus</a></h2>
<ul>
<li>GÃ¨re les erreurs de tÃ©lÃ©chargement</li>
<li>Ajoute la date ou un tag dans le nom du fichier</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--dockerise-moi-ce-backend-en-ruby-avec-sinatra"><a class="header" href="#tp--dockerise-moi-ce-backend-en-ruby-avec-sinatra">TP â Dockerise-moi ce backend en Ruby (avec Sinatra)</a></h1>
<h2 id="objectif-6"><a class="header" href="#objectif-6">Objectif</a></h2>
<p>Tu vas crÃ©er une image Docker <strong>basÃ©e sur Ubuntu</strong>, dans laquelle tourne une petite app HTTP Ã©crite en <strong>Ruby avec Sinatra</strong>.</p>
<hr />
<h2 id="contexte-1"><a class="header" href="#contexte-1">Contexte</a></h2>
<p>Tu pars de ce code minimal, stockÃ© dans un fichier <code>app.rb</code> :</p>
<pre><code class="language-ruby">require 'sinatra'

get '/' do
  'Hello Docker'
end

set :bind =&gt; "0.0.0.0"
set :port =&gt; port_number
</code></pre>
<hr />
<h2 id="contraintes-2"><a class="header" href="#contraintes-2">Contraintes</a></h2>
<ul>
<li>Tu dois partir de lâimage <code>ubuntu</code> (pas <code>ruby</code>, pas <code>alpine</code>)</li>
<li>Tu dois <strong>chercher toi-mÃªme</strong> :
<ul>
<li>Quels paquets installer</li>
<li>Comment installer le module <code>sinatra</code></li>
</ul>
</li>
<li>Le serveur doit Ã©couter sur le port <code>8080</code> de lâhÃ´te</li>
<li>Pas de <code>puma</code>, pas de framework Rails, juste Sinatra en mode brut</li>
<li>Le conteneur doit lancer lâapp automatiquement au dÃ©marrage</li>
</ul>
<blockquote>
<p>Attention, tu dois installer <code>rackup</code> en plus de <code>sinatra</code> mais pas <code>puma</code></p>
</blockquote>
<hr />
<h2 id="ce-que-tu-dois-faire"><a class="header" href="#ce-que-tu-dois-faire">Ce que tu dois faire</a></h2>
<ol>
<li>CrÃ©e un <code>Dockerfile</code> basÃ© sur <code>ubuntu</code></li>
<li>Installe tout ce quâil faut pour :
<ul>
<li>Faire tourner Ruby</li>
<li>Installer <code>sinatra</code> via <code>gem</code></li>
</ul>
</li>
<li>Copie le fichier <code>app.rb</code> dans lâimage</li>
<li>Configure ton <code>Dockerfile</code> pour lancer lâapp automatiquement</li>
<li>Expose le port <code>8080</code></li>
</ol>
<hr />
<h2 id="Ã-avoir-2"><a class="header" href="#Ã-avoir-2">Ã avoir</a></h2>
<ul>
<li><code>Dockerfile</code></li>
<li>Le fichier <code>app.rb</code></li>
<li>Commandes <code>docker build</code> + <code>docker run</code> utilisÃ©es</li>
<li>Preuve que <a href="http://localhost:8080">http://localhost:8080</a> retourne âHello Dockerâ</li>
</ul>
<hr />
<h2 id="bonus-2"><a class="header" href="#bonus-2">Bonus</a></h2>
<ul>
<li>Utilise un <code>CMD</code> clair dans ton <code>Dockerfile</code></li>
</ul>
<hr />
<h2 id="liens-utiles-1"><a class="header" href="#liens-utiles-1">Liens utiles</a></h2>
<ul>
<li><a href="https://sinatrarb.com/intro.html">Sinatra</a></li>
<li><a href="https://www.ruby-lang.org/en/documentation/installation/">Ruby</a></li>
</ul>
<blockquote>
<p>Ce TP tâapprend Ã  dockeriser une app dans un langage que tu connais pas. Et câest Ã§a, Ãªtre un dev solide : savoir sâadapter, chercher.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercice"><a class="header" href="#exercice">Exercice</a></h1>
<p><strong>Contenerization using multistages builds</strong></p>
<p>Here is a sample C++ program:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main(void){
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return (0);
}
</code></pre>
<p>Here is the sequence of instructions that you should follow :</p>
<details>
<summary>Part 1: Project files retrieval</summary>
<ol>
<li>Run a container interactively using the base image alpine and <strong>bind</strong> a volume called <code>project_files</code> to the folder <code>/project</code> on your container.</li>
<li>Create the <code>hello_word.cpp</code> file <strong>within</strong> the container in the <code>/project</code> directory and commit the result as a new image called <code>project_files</code></li>
</ol>
</details>
<details>
<summary>Part 2: Project building</summary>
<p>At this point in the exercise you should have a new base image containing only alpine and the <code>hello_world.cpp</code> file in the <code>/project</code> folder.</p>
<ol start="3">
<li>Run another container interactively based on the image  <code>project_files</code></li>
<li>Install the tools needed in order to build the sample c++ program.</li>
<li>Build the sample program and move the executable to <code>/project/bin</code>, creating the directory if needed</li>
<li>Commit the result as a new layer, calling it : <code>executable</code></li>
</ol>
</details>
<details>
<summary>Part 3: Writting the Dockerfile</summary>
<p>At this point, you should be able to run : <code>docker run executable /project/bin/hello_world</code> and everything should be working</p>
<ol start="7">
<li>Now that you know how to do this from the command line, this step is pretty straightforward, you should put all the previous steps but in your Dockerfile. It has to start with the instruction <code>FROM project_files</code></li>
</ol>
</details>
<details>
<summary>Part 4: Multistage Build</summary>
<p>Running <code>docker build -t dockerfile_executable . &amp;&amp; docker run dockerfile_executable</code> should print <code>Hello World!</code> to <code>stdout</code></p>
<ol start="8">
<li>Split the build into multiple stages, the final image should contain only the executable.</li>
</ol>
</details>
<details>
<summary>Part 5: Comparison between both types of build</summary>
<p>Here is an example of what you may see when running <code>docker image history multistage_image</code> for the image generated during the multistages build</p>
<pre><code class="language-bash">IMAGE          CREATED       CREATED BY                            SIZE      COMMENT
df5a49f5c822   2 hours ago   ENTRYPOINT ["./hello_world"]          0B        buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   COPY /test/hello_world . # buildkit   72.9kB    buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   WORKDIR /RUN                          0B        buildkit.dockerfile.v0
</code></pre>
<p>Find a way to compare the size of the two generated images and explain briefly why splitting builds into multiple stages affects the size of the resulting image</p>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
