<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker-K8s</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course/part1/intro.html"><strong aria-hidden="true">1.</strong> Introduction à Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course/part1/contenerisation.html"><strong aria-hidden="true">1.1.</strong> Histoire de la conteneurisation</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/docker/first_image.html"><strong aria-hidden="true">2.</strong> Premiere image node</a></li><li class="chapter-item expanded "><a href="exercises/docker/first_bind_mount.html"><strong aria-hidden="true">3.</strong> Premier serveur nginx</a></li><li class="chapter-item expanded "><a href="exercises/docker/image_by_hand.html"><strong aria-hidden="true">4.</strong> Image a la main</a></li><li class="chapter-item expanded "><a href="exercises/docker/flask_app.html"><strong aria-hidden="true">5.</strong> Flask Application</a></li><li class="chapter-item expanded "><a href="exercises/docker/first_app.html"><strong aria-hidden="true">6.</strong> Premier Network</a></li><li class="chapter-item expanded "><a href="exercises/docker/mp3_download.html"><strong aria-hidden="true">7.</strong> Telechargement de mp3 sur youtube</a></li><li class="chapter-item expanded "><a href="exercises/docker/unknown_language.html"><strong aria-hidden="true">8.</strong> Dockerisation d'un langage inconnu</a></li><li class="chapter-item expanded "><a href="exercises/docker/ms_builds.html"><strong aria-hidden="true">9.</strong> Builds Multistage</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docker-K8s</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="partie-1--introduction-à-la-conteneurisation-et-à-docker"><a class="header" href="#partie-1--introduction-à-la-conteneurisation-et-à-docker"><strong>Partie 1 : Introduction à la Conteneurisation et à Docker</strong></a></h1>
<h2 id="introduction"><a class="header" href="#introduction"><strong>Introduction</strong></a></h2>
<p>Au cours des dernières décennies, l'infrastructure informatique a connu une évolution spectaculaire, passant de serveurs physiques imposants à des technologies modernes telles que les conteneurs. Cette transition a transformé la manière dont les entreprises développent, testent, déploient et gèrent leurs applications.</p>
<p>La conteneurisation est devenue une pièce maîtresse dans l'écosystème du cloud et des environnements modernes. Elle répond aux défis de flexibilité, de scalabilité et d'efficacité posés par les approches traditionnelles. Contrairement aux machines virtuelles, les conteneurs sont légers, portables et permettent de s’assurer que les applications fonctionnent de manière cohérente, quel que soit l’environnement dans lequel elles sont exécutées.</p>
<p>Docker, l’outil le plus populaire de conteneurisation, a démocratisé cette technologie. Il offre une interface simple et intuitive pour créer, partager et gérer des conteneurs. Mais avant d’approfondir les aspects pratiques de Docker, il est essentiel de comprendre les concepts fondamentaux de la conteneurisation : son origine, ses caractéristiques, ses avantages, et ses cas d’usage.</p>
<p>Dans cette première partie, nous explorerons :</p>
<p>L’évolution des infrastructures informatiques, en retraçant le chemin des serveurs physiques aux conteneurs.
Les caractéristiques clés des conteneurs, notamment leur légèreté, leur portabilité et leur capacité d’isolation.
Les avantages stratégiques de la conteneurisation, tels que l’efficacité des ressources, la scalabilité rapide, et la consistance des environnements.
Les cas d’usage courants, qui illustreront pourquoi cette technologie est devenue incontournable pour des architectures modernes comme les microservices ou les pipelines CI/CD.</p>
<p>Enrichie de démonstrations pratiques et de quiz interactifs, cette partie vous donnera les bases nécessaires pour comprendre pourquoi la conteneurisation est une révolution pour l’informatique d’entreprise et pour les développeurs. À la fin de cette section, vous aurez une vision claire de ce que la conteneurisation peut apporter à vos projets, ainsi qu'une bonne compréhension des concepts fondamentaux pour passer à l’utilisation de Docker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i1-quest-ce-que-la-conteneurisation-"><a class="header" href="#i1-quest-ce-que-la-conteneurisation-"><strong>I.1 Qu'est-ce que la Conteneurisation ?</strong></a></h1>
<h2 id="i1a-Évolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><a class="header" href="#i1a-Évolution-des-infrastructures--des-serveurs-physiques-aux-conteneurs"><strong>I.1.a Évolution des infrastructures : des serveurs physiques aux conteneurs</strong></a></h2>
<p>L'évolution de l'infrastructure informatique est fondamentale pour comprendre pourquoi et comment les conteneurs ont transformé l'informatique moderne.</p>
<ol>
<li>
<p><strong>Serveurs physiques</strong><br />
À l'origine, chaque application fonctionnait sur un serveur physique dédié. Cette configuration impliquait souvent un surdimensionnement des ressources pour gérer les charges maximales, conduisant à un gaspillage considérable.<br />
<em>Exemple : Imaginez un serveur dédié uniquement à une application de gestion de fichiers, mais n’utilisé qu'à 30 % de sa capacité la majorité du temps.</em></p>
</li>
<li>
<p><strong>Machines virtuelles (VMs)</strong><br />
L’introduction des <strong>hyperviseurs</strong> (par exemple, VMware, Hyper-V) a permis de partitionner un serveur physique en plusieurs machines virtuelles, chacune exécutant son propre système d'exploitation. Bien que cette technologie ait optimisé l’utilisation des ressources, elle nécessitait encore une copie complète du système d’exploitation par VM, augmentant la consommation en mémoire et en stockage.<br />
→ Pour approfondir : <a href="https://www.redhat.com/fr/topics/containers/containers-vs-vms">Red Hat – VMs vs Containers</a>.</p>
</li>
<li>
<p><strong>Conteneurs</strong><br />
Contrairement aux VMs, les conteneurs partagent le noyau du système d’exploitation avec leur hôte. Cela les rend légers, rapides à démarrer, et facilement portables. Par exemple, un conteneur peut contenir uniquement une application et ses dépendances, sans inclure un système d'exploitation complet.<br />
→ En savoir plus : <a href="https://docs.docker.com/get-started/overview/">Documentation Docker – Qu'est-ce qu'un conteneur ?</a>.</p>
</li>
</ol>
<p><img src="course/part1/../../img/part1/Container_Evolution.svg" alt="History of contenerization" /></p>
<hr />
<h2 id="i1b-caractéristiques-clés-des-conteneurs"><a class="header" href="#i1b-caractéristiques-clés-des-conteneurs"><strong>I.1.b Caractéristiques clés des conteneurs</strong></a></h2>
<ul>
<li><strong>Légèreté :</strong> Les conteneurs utilisent moins de ressources qu'une VM, car ils ne nécessitent pas un système d'exploitation complet.</li>
<li><strong>Portabilité :</strong> Une fois créé, un conteneur peut être exécuté de manière identique sur un ordinateur local, un serveur on-premise ou dans un environnement cloud.</li>
<li><strong>Isolation :</strong> Grâce aux technologies de namespaces et cgroups, chaque conteneur est isolé du reste du système, évitant ainsi des conflits entre applications.<br />
→ Découvrez les bases des namespaces et cgroups dans la <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">documentation Linux</a>.</li>
</ul>
<hr />
<h2 id="i1c-les-avantages-de-la-conteneurisation"><a class="header" href="#i1c-les-avantages-de-la-conteneurisation"><strong>I.1.c Les avantages de la conteneurisation</strong></a></h2>
<ul>
<li><strong>Efficacité des ressources :</strong> Contrairement aux VMs, les conteneurs partagent le noyau avec l’hôte, ce qui réduit considérablement l’utilisation de la mémoire et des CPU.</li>
<li><strong>Scalabilité rapide :</strong> Les conteneurs peuvent être créés, dupliqués, ou supprimés en quelques secondes, ce qui les rend idéaux pour gérer des charges variables.</li>
<li><strong>Consistance des environnements :</strong> Avec les conteneurs, "ça marche sur ma machine" devient un problème du passé, car chaque conteneur inclut tout ce dont l'application a besoin pour fonctionner.</li>
</ul>
<hr />
<h2 id="i1d-cas-dusage-courants-des-conteneurs"><a class="header" href="#i1d-cas-dusage-courants-des-conteneurs"><strong>I.1.d Cas d’usage courants des conteneurs</strong></a></h2>
<ul>
<li><strong>Microservices :</strong> Permettent de diviser une application complexe en composants plus petits et indépendants.</li>
<li><strong>CI/CD :</strong> Intégration et déploiement continus grâce à des environnements identiques pour le développement, les tests et la production.</li>
<li><strong>Tests :</strong> Facilite la création rapide d'environnements jetables pour tester de nouvelles fonctionnalités.<br />
→ Cas pratique : <a href="https://netflixtechblog.com/">Netflix et les conteneurs</a>: découvrez comment Netflix utilise les conteneurs pour le streaming mondial.</li>
</ul>
<hr />
<h2 id="exercices-pratiques"><a class="header" href="#exercices-pratiques"><strong>Exercices pratiques</strong></a></h2>
<h4 id="exercice-1--comparaison-entre-vms-et-conteneurs"><a class="header" href="#exercice-1--comparaison-entre-vms-et-conteneurs"><strong>Exercice 1 : Comparaison entre VMs et conteneurs</strong></a></h4>
<ol>
<li>Téléchargez <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> et <a href="https://www.virtualbox.org/">VirtualBox</a>.</li>
<li>Démarrez une machine virtuelle avec VirtualBox et installez un serveur web simple comme Apache. Notez les ressources consommées (RAM et CPU).</li>
<li>Démarrez un conteneur avec Docker (exemple : <code>docker run -d -p 8080:80 nginx</code>) et observez les ressources consommées.</li>
<li>Comparez le temps de démarrage, la mémoire et le CPU utilisés entre les deux configurations.</li>
</ol>
<h4 id="exercice-2--visualisation-des-namespaces-et-cgroups"><a class="header" href="#exercice-2--visualisation-des-namespaces-et-cgroups"><strong>Exercice 2 : Visualisation des namespaces et cgroups</strong></a></h4>
<ol>
<li>Lancez un conteneur avec Docker :
<pre><code class="language-bash">docker run -it --name test-container ubuntu /bin/bash
</code></pre>
</li>
<li>Depuis l’hôte, observez les namespaces associés au conteneur en exécutant :
<pre><code class="language-bash">lsns
</code></pre>
</li>
<li>Affichez les cgroups actifs pour le conteneur avec :
<pre><code class="language-bash">cat /sys/fs/cgroup/&lt;group_path&gt;/tasks
</code></pre>
</li>
<li>Résumez vos observations : que voyez-vous en termes d’isolation ?</li>
</ol>
<h2 id="quizz-dintroduction"><a class="header" href="#quizz-dintroduction"><strong>Quizz d'introduction</strong></a></h2>
<p>Vous pouvez maintenant tester votre compréhension des notions de base de Docker avec le quizz suivant :</p>
<div class="quiz-placeholder" data-quiz-name="&quot;intro_quizz&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Les conteneurs sont légers car ils n'ont pas besoin d'une instance séparée de système d'exploitation. Ils partagent le noyau de l'hôte.\n&quot;,&quot;id&quot;:&quot;f9d735c0-50dc-483f-8c10-822a08289b52&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Oui, les conteneurs partagent le noyau du système d’exploitation de l’hôte.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Non, les conteneurs possèdent leur propre noyau.&quot;,&quot;Seulement s'ils fonctionnent sur Linux.&quot;],&quot;prompt&quot;:&quot;Les conteneurs partagent-ils le noyau du système d’exploitation de l’hôte ?&quot;}},{&quot;context&quot;:&quot;Les machines virtuelles utilisent un hyperviseur pour émuler un système d'exploitation complet, tandis que les conteneurs s'appuient sur le système de l'hôte, ce qui les rend plus légers et rapides.\n&quot;,&quot;id&quot;:&quot;35c26965-2496-4582-9387-0c35b4e88683&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Les conteneurs partagent le noyau du système d’exploitation de l’hôte, tandis que les machines virtuelles émulent un système complet.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Les conteneurs sont plus lourds que les machines virtuelles.&quot;,&quot;Les machines virtuelles n'ont pas besoin de système d'exploitation.&quot;,&quot;Les conteneurs nécessitent un hyperviseur supplémentaire pour fonctionner.&quot;],&quot;prompt&quot;:&quot;Quelle est la principale différence entre les conteneurs et les machines virtuelles ?&quot;}},{&quot;context&quot;:&quot;Un conteneur encapsule tout ce dont une application a besoin pour fonctionner : son code, ses dépendances, et ses configurations, garantissant une cohérence totale entre les environnements.\n&quot;,&quot;id&quot;:&quot;55e1ea81-626a-4249-87d2-61dbb395a33a&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;application, dépendances&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est une unité légère et portable d'___ et de ses ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont idéaux pour des scénarios nécessitant une scalabilité, une portabilité et une cohérence, comme les microservices ou les pipelines CI/CD.\n&quot;,&quot;id&quot;:&quot;ec577900-6ec8-4305-946f-3d0850e74b8e&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Une architecture basée sur les microservices.&quot;,&quot;Des pipelines d'intégration et de déploiement continus (CI/CD).&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Exécution d'une seule application sur un matériel dédié.&quot;,&quot;Déploiement d’une application monolithique sans mises à jour fréquentes.&quot;,&quot;Traitement par lots sur des serveurs bare-metal.&quot;],&quot;prompt&quot;:&quot;Quels scénarios bénéficient le plus de la conteneurisation ? (Choisissez deux)&quot;}},{&quot;context&quot;:&quot;Les serveurs physiques exécutent directement les applications sur le matériel. Les VMs émulent des environnements OS complets. Les conteneurs partagent le noyau de l’hôte.\n&quot;,&quot;id&quot;:&quot;f532170e-dd96-46a6-91c0-e7bdd59dfc1c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Serveurs physiques : Application unique, non virtualisée.&quot;,&quot;Machines virtuelles : Lourd, émulation complète d'OS.&quot;,&quot;Conteneurs : Léger, partage le noyau de l'hôte.&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Conteneurs : Lourds, émulation complète d'OS.&quot;,&quot;Serveurs physiques : Partage des ressources, processus isolés.&quot;,&quot;Machines virtuelles : Partagent le noyau de l'hôte.&quot;],&quot;prompt&quot;:&quot;Associez les technologies suivantes à leurs caractéristiques : serveurs physiques, machines virtuelles, conteneurs.&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'assurer une isolation au sein des conteneurs, séparant les processus et ressources de l'hôte et des autres conteneurs.\n&quot;,&quot;id&quot;:&quot;6c07415e-b848-499f-8bc1-806143d72bd1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Isoler les processus, systèmes de fichiers et interfaces réseau.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Contrôler la quantité de ressources (CPU, RAM) qu’un conteneur peut utiliser.&quot;,&quot;Gérer les dépendances logicielles à l’intérieur d’un conteneur.&quot;],&quot;prompt&quot;:&quot;Dans une architecture conteneurisée, quel est le rôle des namespaces ?&quot;}},{&quot;context&quot;:&quot;Les namespaces permettent d'isoler les processus, les systèmes de fichiers, et les interfaces réseau des conteneurs, garantissant une séparation totale entre les conteneurs et l'hôte.\n&quot;,&quot;id&quot;:&quot;cfb52846-c478-4a66-a918-28241abf55ee&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;processus, systèmes de fichiers, interfaces réseau&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Dans une architecture conteneurisée, les namespaces servent à isoler ___, ___ et ___.&quot;}},{&quot;context&quot;:&quot;Les conteneurs sont conçus pour être plus légers et démarrer plus rapidement que les machines virtuelles, car ils n'ont pas besoin d'inclure un système d'exploitation complet.\n&quot;,&quot;id&quot;:&quot;56d269f9-466c-4526-ad36-b7fd5c06b5ba&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;léger, rapidement&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Un conteneur est plus ___ et démarre plus ___ qu'une machine virtuelle.&quot;}}]}" data-quiz-fullscreen="true"></div>
<script type="text/javascript" src="../../quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="../../quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="tp--dockeriser-un-backend-simple-nodejs"><a class="header" href="#tp--dockeriser-un-backend-simple-nodejs">TP – Dockeriser un backend simple (Node.js)</a></h1>
<h2 id="objectif"><a class="header" href="#objectif">Objectif</a></h2>
<p>Découvrir les bases concrètes de Docker à travers une application Node.js minimaliste.<br />
À la fin de l’exercice, vous devez avoir :</p>
<ul>
<li>Une image Docker fonctionnelle</li>
<li>Un conteneur lancé à partir de cette image</li>
<li>Une application accessible en local via un port exposé</li>
</ul>
<hr />
<h2 id="fichiers-fournis"><a class="header" href="#fichiers-fournis">Fichiers fournis</a></h2>
<p>Vous partez d’un dossier <code>simple-backend/</code> contenant :</p>
<pre><code>simple-backend/
├── app.js
├── package.json
</code></pre>
<p>Contenu de <code>app.js</code> :</p>
<pre><code class="language-js">const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; res.send('Hello Docker'));
app.listen(3000, () =&gt; console.log('Listening on port 3000'));
</code></pre>
<p>Contenu de <code>package.json</code> :</p>
<pre><code class="language-json">{
  "dependencies": {
    "express": "^5.1.0"
  }
}
</code></pre>
<hr />
<h2 id="Étapes"><a class="header" href="#Étapes">Étapes</a></h2>
<ol>
<li>
<p>Créez un fichier <code>Dockerfile</code> à la racine du projet.<br />
Il doit :</p>
<ul>
<li>Utiliser l’image officielle <code>node:latest</code></li>
<li>Définir un dossier de travail (<code>/app</code>)</li>
<li>Copier les fichiers nécessaires dans le conteneur</li>
<li>Installer les dépendances (<code>npm i</code>)</li>
<li>Définir la commande de démarrage de l’application (<code>node app.js</code>)</li>
</ul>
</li>
<li>
<p>Construisez l’image Docker</p>
</li>
<li>
<p>Lancez un conteneur à partir de l’image (n'oubliez-pas de transferer le port 8080 vers le port 3000)</p>
</li>
<li>
<p>Vérifiez que votre application fonctionne en ouvrant <a href="http://localhost:8080">http://localhost:8080</a></p>
</li>
<li>
<p>Affichez les logs du conteneur :</p>
</li>
</ol>
<pre><code>docker logs backend
</code></pre>
<ol start="6">
<li>Arrêtez puis supprimez le conteneur</li>
</ol>
<hr />
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<ol>
<li>Quelle différence entre une <strong>image</strong> et un <strong>conteneur</strong> ?</li>
<li>Si tu changes <code>app.js</code>, que dois-tu faire pour voir la mise à jour dans le conteneur ?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--servir-un-site-statique-avec-nginx-dans-un-conteneur"><a class="header" href="#tp--servir-un-site-statique-avec-nginx-dans-un-conteneur">TP – Servir un site statique avec Nginx dans un conteneur</a></h1>
<h2 id="objectif-1"><a class="header" href="#objectif-1">Objectif</a></h2>
<p>Comprendre comment lancer un conteneur qui utilise une image officielle existante pour servir du contenu local.<br />
Découvrir le <strong>montage de répertoire</strong> dans un conteneur (volume simple).</p>
<hr />
<h2 id="fichiers-à-créer"><a class="header" href="#fichiers-à-créer">Fichiers à créer</a></h2>
<p>Dans un dossier <code>static-site/</code> :</p>
<pre><code>static-site/
└── index.html
</code></pre>
<p>Contenu simple de <code>index.html</code> :</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Mon site Dockerisé&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;&lt;h1&gt;Bienvenue dans le monde des conteneurs&lt;/h1&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr />
<h2 id="Étapes-1"><a class="header" href="#Étapes-1">Étapes</a></h2>
<ol>
<li>
<p>Créez un dossier <code>static-site/</code> contenant un fichier <code>index.html</code> comme ci-dessus.</p>
</li>
<li>
<p>Lancez un conteneur basé sur l’image officielle <code>nginx</code>, avec ce fichier servi à la racine du site.<br />
Pour cela :</p>
<ul>
<li>Montez votre dossier local dans <code>/usr/share/nginx/html</code> (répertoire utilisé par défaut par Nginx dans le conteneur)</li>
<li>Transférez le port <code>8081</code> (host) vers le port <code>80</code> (conteneur)</li>
<li>Donnez-lui un nom, par exemple <code>nginx-site</code></li>
</ul>
</li>
<li>
<p>Testez que le site est accessible sur <a href="http://localhost:8081">http://localhost:8081</a></p>
</li>
<li>
<p>Modifiez <code>index.html</code>, rechargez la page, vérifiez que la modification est visible</p>
</li>
</ol>
<blockquote>
<p>Cela prouve que le dossier local est bien <strong>monté dans le conteneur</strong>.</p>
</blockquote>
<hr />
<h2 id="questions-1"><a class="header" href="#questions-1">Questions</a></h2>
<ol>
<li>À quoi sert le flag <code>--mount</code> dans <code>docker run</code> ?</li>
<li>Quelle est la différence entre copier des fichiers dans l’image et les monter depuis l’extérieur ?</li>
<li>Quelle commande permet de voir les conteneurs qui tournent actuellement ?</li>
<li>Quelle commande permet de supprimer un conteneur arrêté ?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--construire-une-image-de-développement-à-la-main-ubuntu"><a class="header" href="#tp--construire-une-image-de-développement-à-la-main-ubuntu">TP – Construire une image de développement à la main (Ubuntu)</a></h1>
<h2 id="objectif-2"><a class="header" href="#objectif-2">Objectif</a></h2>
<p>Créer une image Docker personnalisée qui pourra te servir de base pour du développement en ligne de commande.<br />
Pas de Dockerfile. Tu fais tout <strong>à la main</strong>, comme un artisan qui cloue ses propres conteneurs.</p>
<hr />
<h2 id="contexte"><a class="header" href="#contexte">Contexte</a></h2>
<p>Tu pars d’une image de base : <code>ubuntu</code> (dernière version).<br />
Tu installes ce dont <em>tu</em> as besoin pour coder/travailler dans un terminal.</p>
<h3 id="ton-image-finale-doit-contenir-au-minimum-"><a class="header" href="#ton-image-finale-doit-contenir-au-minimum-">Ton image finale doit contenir <strong>au minimum</strong> :</a></h3>
<ul>
<li><code>curl</code> ou équivalent</li>
<li><code>git</code></li>
<li>un éditeur en ligne de commande (<code>nano</code>, <code>vim</code>, <code>micro</code>, autre)</li>
<li>un dossier <code>/workspace</code> vide prêt à accueillir des projets</li>
</ul>
<hr />
<h2 id="Étapes-2"><a class="header" href="#Étapes-2">Étapes</a></h2>
<ol>
<li>Lance un conteneur Ubuntu interactif :</li>
</ol>
<pre><code>docker run -it ubuntu bash
</code></pre>
<ol start="2">
<li>
<p>Installe les outils nécessaires. À toi de trouver les bonnes commandes.</p>
</li>
<li>
<p>Crée un dossier <code>/workspace</code> dans le conteneur.</p>
</li>
<li>
<p>Une fois que tout est prêt fige ton travail :</p>
</li>
</ol>
<blockquote>
<p>Attention a bien faire ca dans un autre terminal</p>
</blockquote>
<pre><code>docker commit &lt;id_du_conteneur&gt; dev-env-&lt;tonprenom&gt;
</code></pre>
<ol start="5">
<li>Teste ton image : relance un conteneur à partir de <code>dev-env-&lt;tonprenom&gt;</code> et vérifie que tout est bien en place.</li>
</ol>
<hr />
<h2 id="À-avoir-au-minimum"><a class="header" href="#À-avoir-au-minimum">À avoir au minimum</a></h2>
<ul>
<li>Le nom de ton image (<code>docker images</code>)</li>
<li>Une image ou:
<ul>
<li><code>git</code> fonctionne</li>
<li><code>curl</code> fonctionne</li>
<li>ton éditeur fonctionne</li>
<li><code>/workspace</code> existe</li>
</ul>
</li>
</ul>
<hr />
<h2 id="questions-2"><a class="header" href="#questions-2">Questions</a></h2>
<ol>
<li>Quels paquets as-tu dû installer ? (nom exact)</li>
<li>Pourquoi n’a-t-on pas utilisé de Dockerfile ici ?</li>
<li>Quels sont les avantages de cette méthode ? Les inconvénients ?</li>
</ol>
<hr />
<h2 id="bonus-optionnel"><a class="header" href="#bonus-optionnel">Bonus (optionnel)</a></h2>
<p>Ajoute un alias ou une commande custom dans <code>.bashrc</code> (ex: <code>alias ll='ls -la'</code>)<br />
Vérifie qu’elle est bien présente au prochain lancement de conteneur.</p>
<hr />
<p><em>Rappelle-toi : une image Docker, c’est juste un conteneur figé. Tu peux la bricoler à la main, la commiter, la partager, mais sans traçabilité, c’est vite le bordel.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--construire-une-app-flask-dans-un-conteneur-ubuntu-image-autonome"><a class="header" href="#tp--construire-une-app-flask-dans-un-conteneur-ubuntu-image-autonome">TP — Construire une app Flask dans un conteneur Ubuntu (Image autonome)</a></h1>
<h2 id="objectif-3"><a class="header" href="#objectif-3">Objectif</a></h2>
<p>Développer une petite application Flask et la faire tourner dans un conteneur Docker <strong>basé sur Ubuntu</strong>.<br />
Tu commences comme tu veux (interactif, scripté).<br />
Mais <strong>à la fin</strong>, tu dois livrer <strong>une image autonome</strong>.</p>
<hr />
<h2 id="départ"><a class="header" href="#départ">Départ</a></h2>
<p>Tu pars d’un dossier <code>flask-docker/</code> contenant ces fichiers :</p>
<h3 id="apppy"><a class="header" href="#apppy"><code>app.py</code></a></h3>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello Docker"
</code></pre>
<h2 id="À-faire"><a class="header" href="#À-faire">À faire</a></h2>
<ol>
<li>Partir de l’image <code>ubuntu</code> (dernière version).</li>
<li>Installer tout ce qu’il faut:
<ul>
<li><code>python3</code></li>
<li><code>pip</code></li>
<li><code>flask</code></li>
</ul>
</li>
<li>Pendant le développement, fais comme tu veux : tu peux monter des fichiers, modifier en live, t’énerver.</li>
<li><strong>Mais à la fin</strong>, ton projet doit être <strong>contenu dans une image autonome</strong> :
<ul>
<li>Tout est <strong>copié</strong> dans l’image (pas de <code>-v</code>, pas de montage)</li>
<li>L’app se lance automatiquement</li>
<li>Le conteneur expose <code>http://localhost:8080</code> quand on le run</li>
</ul>
</li>
</ol>
<hr />
<h2 id="interdiction"><a class="header" href="#interdiction">Interdiction</a></h2>
<ul>
<li>Pas d’image <code>python:*</code></li>
<li>Pas de <code>bind mount</code> dans le <code>docker run</code> final</li>
<li>Pas de <code>flask run</code> lancé manuellement dans un shell</li>
</ul>
<hr />
<h2 id="À-avoir"><a class="header" href="#À-avoir">À avoir</a></h2>
<ul>
<li><code>Dockerfile</code> final propre</li>
<li><code>app.py</code></li>
<li>La commande complète <code>docker build</code> + <code>docker run</code> utilisée</li>
<li>Preuve que ton conteneur tourne et répond bien sur <code>localhost:8080</code></li>
</ul>
<hr />
<h2 id="liens-utiles"><a class="header" href="#liens-utiles">Liens utiles</a></h2>
<ul>
<li><a href="https://flask.palletsprojects.com/en/latest/">Docs Flask</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile référence</a></li>
<li><a href="https://flask.palletsprojects.com/en/latest/cli/#run">Exemple <code>flask run</code></a></li>
</ul>
<hr />
<h2 id="bonus"><a class="header" href="#bonus">Bonus</a></h2>
<ul>
<li>Ajoute un <code>ENTRYPOINT</code> ou <code>CMD</code> propre</li>
<li>Utilise des variables d’environnement dans ton <code>Dockerfile</code> (ex : <code>FLASK_ENV=production</code>)</li>
<li>Crée un dossier <code>/app</code> dans l’image pour bosser proprement</li>
</ul>
<hr />
<h2 id="aide"><a class="header" href="#aide">Aide</a></h2>
<ul>
<li>Tu peux utiliser l'option <code>--port port_number</code> pour changer le port par defaut de <code>flask</code> (si besoin)</li>
<li>Tu peux utiliser l'option <code>--host=0.0.0.0</code> pour que l'application ecoute sur tous les ports</li>
</ul>
<p><em>À la fin, tu dois avoir une image que tu peux envoyer à n’importe qui.<br />
Il la build, il la run, elle répond. Pas de dépendance locale.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--backend--db-dans-deux-conteneurs-sans-compose"><a class="header" href="#tp--backend--db-dans-deux-conteneurs-sans-compose">TP — Backend + DB dans deux conteneurs (sans Compose)</a></h1>
<h2 id="objectif-4"><a class="header" href="#objectif-4">Objectif</a></h2>
<p>Créer une application en Python avec un backend qui communique avec une base de données, chaque composant tournant dans <strong>son propre conteneur</strong>, sur le <strong>même réseau Docker</strong>.</p>
<hr />
<h2 id="contraintes"><a class="header" href="#contraintes">Contraintes</a></h2>
<ul>
<li>Utilisation obligatoire de l’image <code>mariadb</code> ou <code>mongo</code> (au choix selon ton aisance)</li>
<li>Le backend Python doit :
<ul>
<li>Se connecter à la DB via son <strong>nom de conteneur</strong></li>
<li>Être accessible sur le port <code>5000</code> (depuis l’extérieur)</li>
<li>Implementer le CRUD</li>
</ul>
</li>
<li>Pas de docker-compose</li>
<li>Le tout doit être lançable en ligne de commande :</li>
</ul>
<pre><code class="language-bash">docker network create app-network
docker run (avec les bons flags) mongo/mariadb
docker build -t backend .
docker run (avec les bons flags) backend
</code></pre>
<p>Le backend doit proposer au minimum :</p>
<ul>
<li>POST /items → créer un élément</li>
<li>GET /items → lister les éléments</li>
<li>GET /items/<id> → voir un élément</li>
<li>DELETE /items/<id> → supprimer un élément</li>
</ul>
<hr />
<h2 id="À-avoir-1"><a class="header" href="#À-avoir-1">À avoir</a></h2>
<ul>
<li>Le code du backend (<code>main.py</code>, <code>requirements.txt</code>, etc.)</li>
<li>Le <code>Dockerfile</code> du backend</li>
<li>La commande exacte de <code>docker run</code> pour la DB</li>
<li>La commande exacte de <code>docker run</code> pour le backend</li>
<li>Preuve que la communication backend → DB fonctionne (ex : un GET sur <code>/status</code> retourne “DB OK”)</li>
</ul>
<blockquote>
<p>Ce TP ne teste pas ta capacité à coder un backend, mais ta capacité à <strong>faire dialoguer des conteneurs entre eux</strong>, proprement, sans docker-compose.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--télécharger-une-vidéo-ou-une-musique-avec-yt-dlp-dans-un-conteneur"><a class="header" href="#tp--télécharger-une-vidéo-ou-une-musique-avec-yt-dlp-dans-un-conteneur">TP – Télécharger une vidéo ou une musique avec yt-dlp dans un conteneur</a></h1>
<h2 id="objectif-5"><a class="header" href="#objectif-5">Objectif</a></h2>
<p>Créer un conteneur Docker basé sur Ubuntu, capable de télécharger <strong>l’audio d’une vidéo YouTube au format MP3</strong>, sans rien installer sur ton système hôte.</p>
<hr />
<h2 id="contraintes-1"><a class="header" href="#contraintes-1">Contraintes</a></h2>
<ul>
<li>Tu pars de l’image <code>ubuntu</code> (dernière version)</li>
<li>Tu dois installer dans le conteneur :
<ul>
<li><code>python3</code>, <code>pip</code></li>
<li><code>ffmpeg</code></li>
<li><code>yt-dlp</code> via <code>pip</code></li>
</ul>
</li>
<li>L’app doit :
<ul>
<li>Télécharger l’audio d’une vidéo YouTube</li>
<li>Sauvegarder le fichier <code>.mp3</code> dans un dossier monté depuis l’hôte (<code>./downloads</code>)</li>
<li>Utiliser les options suivantes :
<pre><code>--restrict-filename -x --audio-format mp3
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Exemple de ligne de commande (vous pouvez la tester):</p>
<pre><code class="language-bash">yt-dlp --restrict-filenames -x --audio-format mp3 https://youtu.be/dQw4w9WgXcQ?si=rnTHt9xqOZdI1leO
</code></pre>
<hr />
<h2 id="À-faire-1"><a class="header" href="#À-faire-1">À faire</a></h2>
<ol>
<li>
<p>Crée un <code>Dockerfile</code> qui :</p>
<ul>
<li>Installe tous les outils nécessaires</li>
<li>Configure un dossier <code>/downloads</code></li>
<li>Utilise <code>CMD</code> ou un script Bash/Python pour télécharger</li>
</ul>
</li>
<li>
<p>Le conteneur doit se lancer avec une commande du style :</p>
</li>
</ol>
<pre><code class="language-bash">docker build -t yt-downloader .
docker run --rm -v $(pwd)/downloads:/downloads yt-downloader "https://www.youtube.com/watch?v=VIDEO_ID"
</code></pre>
<blockquote>
<p>Le lien doit être passé en argument ou via une variable d’environnement
Si aucune URL n’est fournie, le conteneur doit afficher une erreur claire et s’arrêter immédiatement.</p>
</blockquote>
<hr />
<h2 id="À-avoir-a-la-fin"><a class="header" href="#À-avoir-a-la-fin">À avoir a la fin</a></h2>
<ul>
<li><code>Dockerfile</code></li>
<li>Optionnel : script <code>download.sh</code> (ou <code>download.py</code>) qui appelle <code>yt-dlp</code></li>
<li>Commande <code>docker run</code> utilisée</li>
<li>Un exemple de fichier téléchargé</li>
</ul>
<hr />
<h2 id="bonus-1"><a class="header" href="#bonus-1">Bonus</a></h2>
<ul>
<li>Gère les erreurs de téléchargement</li>
<li>Ajoute la date ou un tag dans le nom du fichier</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tp--dockerise-moi-ce-backend-en-ruby-avec-sinatra"><a class="header" href="#tp--dockerise-moi-ce-backend-en-ruby-avec-sinatra">TP — Dockerise-moi ce backend en Ruby (avec Sinatra)</a></h1>
<h2 id="objectif-6"><a class="header" href="#objectif-6">Objectif</a></h2>
<p>Tu vas créer une image Docker <strong>basée sur Ubuntu</strong>, dans laquelle tourne une petite app HTTP écrite en <strong>Ruby avec Sinatra</strong>.</p>
<hr />
<h2 id="contexte-1"><a class="header" href="#contexte-1">Contexte</a></h2>
<p>Tu pars de ce code minimal, stocké dans un fichier <code>app.rb</code> :</p>
<pre><code class="language-ruby">require 'sinatra'

get '/' do
  'Hello Docker'
end

set :bind =&gt; "0.0.0.0"
set :port =&gt; port_number
</code></pre>
<hr />
<h2 id="contraintes-2"><a class="header" href="#contraintes-2">Contraintes</a></h2>
<ul>
<li>Tu dois partir de l’image <code>ubuntu</code> (pas <code>ruby</code>, pas <code>alpine</code>)</li>
<li>Tu dois <strong>chercher toi-même</strong> :
<ul>
<li>Quels paquets installer</li>
<li>Comment installer le module <code>sinatra</code></li>
</ul>
</li>
<li>Le serveur doit écouter sur le port <code>8080</code> de l’hôte</li>
<li>Pas de <code>puma</code>, pas de framework Rails, juste Sinatra en mode brut</li>
<li>Le conteneur doit lancer l’app automatiquement au démarrage</li>
</ul>
<blockquote>
<p>Attention, tu dois installer <code>rackup</code> en plus de <code>sinatra</code> mais pas <code>puma</code></p>
</blockquote>
<hr />
<h2 id="ce-que-tu-dois-faire"><a class="header" href="#ce-que-tu-dois-faire">Ce que tu dois faire</a></h2>
<ol>
<li>Crée un <code>Dockerfile</code> basé sur <code>ubuntu</code></li>
<li>Installe tout ce qu’il faut pour :
<ul>
<li>Faire tourner Ruby</li>
<li>Installer <code>sinatra</code> via <code>gem</code></li>
</ul>
</li>
<li>Copie le fichier <code>app.rb</code> dans l’image</li>
<li>Configure ton <code>Dockerfile</code> pour lancer l’app automatiquement</li>
<li>Expose le port <code>8080</code></li>
</ol>
<hr />
<h2 id="À-avoir-2"><a class="header" href="#À-avoir-2">À avoir</a></h2>
<ul>
<li><code>Dockerfile</code></li>
<li>Le fichier <code>app.rb</code></li>
<li>Commandes <code>docker build</code> + <code>docker run</code> utilisées</li>
<li>Preuve que <a href="http://localhost:8080">http://localhost:8080</a> retourne “Hello Docker”</li>
</ul>
<hr />
<h2 id="bonus-2"><a class="header" href="#bonus-2">Bonus</a></h2>
<ul>
<li>Utilise un <code>CMD</code> clair dans ton <code>Dockerfile</code></li>
</ul>
<hr />
<h2 id="liens-utiles-1"><a class="header" href="#liens-utiles-1">Liens utiles</a></h2>
<ul>
<li><a href="https://sinatrarb.com/intro.html">Sinatra</a></li>
<li><a href="https://www.ruby-lang.org/en/documentation/installation/">Ruby</a></li>
</ul>
<blockquote>
<p>Ce TP t’apprend à dockeriser une app dans un langage que tu connais pas. Et c’est ça, être un dev solide : savoir s’adapter, chercher.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercice"><a class="header" href="#exercice">Exercice</a></h1>
<p><strong>Contenerization using multistages builds</strong></p>
<p>Here is a sample C++ program:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main(void){
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return (0);
}
</code></pre>
<p>Here is the sequence of instructions that you should follow :</p>
<details>
<summary>Part 1: Project files retrieval</summary>
<ol>
<li>Run a container interactively using the base image alpine and <strong>bind</strong> a volume called <code>project_files</code> to the folder <code>/project</code> on your container.</li>
<li>Create the <code>hello_word.cpp</code> file <strong>within</strong> the container in the <code>/project</code> directory and commit the result as a new image called <code>project_files</code></li>
</ol>
</details>
<details>
<summary>Part 2: Project building</summary>
<p>At this point in the exercise you should have a new base image containing only alpine and the <code>hello_world.cpp</code> file in the <code>/project</code> folder.</p>
<ol start="3">
<li>Run another container interactively based on the image  <code>project_files</code></li>
<li>Install the tools needed in order to build the sample c++ program.</li>
<li>Build the sample program and move the executable to <code>/project/bin</code>, creating the directory if needed</li>
<li>Commit the result as a new layer, calling it : <code>executable</code></li>
</ol>
</details>
<details>
<summary>Part 3: Writting the Dockerfile</summary>
<p>At this point, you should be able to run : <code>docker run executable /project/bin/hello_world</code> and everything should be working</p>
<ol start="7">
<li>Now that you know how to do this from the command line, this step is pretty straightforward, you should put all the previous steps but in your Dockerfile. It has to start with the instruction <code>FROM project_files</code></li>
</ol>
</details>
<details>
<summary>Part 4: Multistage Build</summary>
<p>Running <code>docker build -t dockerfile_executable . &amp;&amp; docker run dockerfile_executable</code> should print <code>Hello World!</code> to <code>stdout</code></p>
<ol start="8">
<li>Split the build into multiple stages, the final image should contain only the executable.</li>
</ol>
</details>
<details>
<summary>Part 5: Comparison between both types of build</summary>
<p>Here is an example of what you may see when running <code>docker image history multistage_image</code> for the image generated during the multistages build</p>
<pre><code class="language-bash">IMAGE          CREATED       CREATED BY                            SIZE      COMMENT
df5a49f5c822   2 hours ago   ENTRYPOINT ["./hello_world"]          0B        buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   COPY /test/hello_world . # buildkit   72.9kB    buildkit.dockerfile.v0
&lt;missing&gt;      2 hours ago   WORKDIR /RUN                          0B        buildkit.dockerfile.v0
</code></pre>
<p>Find a way to compare the size of the two generated images and explain briefly why splitting builds into multiple stages affects the size of the resulting image</p>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
